[ 오버 로딩 ]

메서드 오버로딩은 같은 이름을 가진 메서드를 여러가지 정의하는 것을 말한다.

오버 로딩의 조건은 1. 메서드 이름이 같아야 하고, 2. 매개변수의 갯수나 타입이 달라야 한다.
위의 조건이 성립되지 않으면 오버 로딩이 될 수 없으며, 메서드 중복 정의로 오류가 발생할 수 있다.

또한 오버로딩은 이름이 같아도 매개 변수로 구분할 수 있지만, 반환 타입으로는 구분할 수 없다.

오버로딩을 활용하면 메서드의 이름을 간단하게 구현할 수 있어, 메서드의 역할을 쉽게 알 수 있고 범용적으로 사용할 수 있다.
	ㄴ 만약 메서드의 이름이 모두 달라야 한다면, 메서드의 이름은 더 구체적이며 길어질 것이고 사용자도 이러한 메서드들을 모두 구분해야 한다.
	
[ 가변 인자 ]
가변 인자 ( variable arguments ) 를 활용하여 매개 변수의 값을 동적으로 받을 수 있다.

가변 인자는 "자료형... 변수명" 으로 선언하며, 매개 변수에는 가변 인자가 항상 끝에 와야 한다.
만약 가변 인자 뒤에 다른 매개 변수가 있다 하면 컴파일 오류가 발생한다.

String... args 와 같은 매개변수가 있다 하면 해당 매개 변수에 0개~N개까지 문자열을 매개변수로 제공해도 되며,
더 나아가 배열도 줄 수 있다. ex) new String[] {"A" , "C"}

가변 인자는 메서드가 호출될 때 마다 내부적으로 배열을 새로 생성해서 활용하기 때문에 비효율적이다. 따라서 꼭 필요한 경우에만 활용하는 것이 좋다.
그렇다고 가변 인자가 아닌 배열을 사용할 경우, 값이 없을 때 길이가 0인 배열을 만들어주어야 한다. 즉, 값이 없다고 빈 값을 보내면 안된다. ( 매개 변수의 갯수를 맞춰야 하기 때문이다. )

[ 생성자 ]
생성자는 인스턴스가 생성될 때 실행되는 '인스턴스 초기화 메서드' 이다.
주로 인스턴스 변수를 초기화 하거나, 인스턴스 생성 시 실행해야 할 작업을 위해 활용된다.

생성자는 일반 메서드와 유사 하지만 반환 값이 없다. ( void 도 아니다. )
그리고 생성자의 이름은 클래스의 이름과 같다.
생성자 역시 메서드 처럼 메서드 오버로딩이 가능하다.

클래스이름(매개변수){
	코드..
}

new 연산자가 인스턴스를 생성하는 것이지, 생성자가 인스턴스를 생성하는 것은 아니다.
Car car = new Car();
위의 인스턴스 생성 코드는 다음과 같은 순서로 진행된다.
1. new 연산자에 의해 heap 메모리에 Car 클래스의 인스턴스가 생성된다.
2. 생성자 Card() 가 호출되어 수행된다.
3. 생성된 Car 클래스의 인스턴스 주소 값이 대입 연산자에 의해 car 참조 변수에 들어간다.

여기서 인스턴스를 생성하기 위한 코드 중 "new Car()" 중 Car() 이 생성자였던 것이다.
인스턴스를 생성하기 위해 클래스 내에 있는 생성자 중 1개를 반드시 호출해야 한다.

- 기본 생성자
만약 클래스 구현 시 생성자를 하나도 만들지 않은 경우에는 컴파일러는 소스 코드 (.java)를 컴파일 할 때 기본 생성자를 생성한다. 
컴파일러가 기본 생성자를 생성할 때는 하단의 코드와 같이 매개변수와 구현부가 하나도 없는 생성자를 만든다.
클래스이름() {
}

만약 인스턴스 초기화 작업이 필요 없다면, 컴파일러가 만들어주는 기본 생성자를 활용해도 좋다.
# 이때 컴파일러가 만들어주는 기본 생성자의 접근자는 클래스의 접근자와 동일하게 만든다.

단, 기본 생성자는 클래스 내에 선언된 생성자가 하나도 없을 때 뿐이다. 만약 소스 코드 내에 생성자가 1개라도 구현되어 있다면 컴파일러는 기본 생성자를 만들지 않는다.

생성자에서 매개 변수를 입력 받아, 해당 매개변수의 값으로 인스턴스의 값을 초기화 한다면, 인스턴스의 생성과 함께 값을 초기화 할 수 있다.
만약 기본 생성자를 사용한다면 인스턴스의 생성과 초기화를 각각 해줘야 할 필요가 없어진다.

- 생성자 간의 호출 ( this() )
같은 클래스 내에서 한 생성자가 다른 생성자를 호출할 수 있다. 메서드 처럼 다른 생성자를 호출할 수 있지만 하단의 두 가지의 조건을 만족해야 한다.
1. 다른 생성자를 호출 시 코드의 첫째 줄에서 호출해야 한다.
2. 생성자 호출 시 생성자의 이름이 아닌 this() 로 호출해야 한다.

생성자는 멤버 변수를 초기화하는 목적으로 하기 때문에 항상 코드의 가장 앞인, 첫번째 코드에 위치해야 한다.
	ㄴ 다른 생성자도 초기화 하기 때문에, 생성자 내부 초기화 로직 시작 전에 초기화 해야 한다.
	
- this
'this'는 참조 변수로 인스턴스 자신을 가리킨다. 즉 this 에는 인스턴스 주소가 저장되어 있다.
참조 변수를 사용하여 인스턴스 변수들을 접근할 수 있으며, static 멤버에는 접근할 수 없다.
	ㄴ this 로도 static 멤버를 호출할 수 없는 이유는, 호출 시점에 인스턴스가 생성되지 않았을 수도 있기 때문이다.

만약 생성자의 매개 변수명과 멤버 변수명이 같을 경우, 두 변수를 구분하기 위해서 this 키워드를 활용할 수 있다.
"this.변수명" 으로 해당 변수는 지역 변수임을 지정해줄 수 있다.
따라서 this.data = data; 처럼 우측의 생성자 매개 변수 값을 좌측의 멤버 변수에 넣을 수 있다.

만약, this 를 선언하지 않고 data = data를 했을 경우에 둘다 지역 변수로 간주한다.

정리하면 this 는 참조 변수이고, this() 는 생성자이다.

[ 변수의 초기화 ]
변수를 선언하고 처음으로 값을 저장하는 것을 변수의 초기화라고 한다.
변수의 초기화는 선택적이기는 하지만, 선언 후 초기화 하는 것이 좋다.

멤버 변수는 초기화를 하지 않아도 자료형에 맞게 초기화가 되지만, 지역 변수는 반드시 초기화를 해야 한다.
class OOP_4 {
	int a;
	int b = a; // a의 0 값이 b에 들어간다.
	
	public int test(int a) {
		int b;
		int c = b; // 왼쪽의 경우 지역 변수는 초기화되지 않아 초기화할 수 없다.
	}
}

즉, 멤버 변수 ( 클래스변수, 지역변수 ) 와 배열의 초기화는 선택적이지만, 지역 변수의 초기화는 필수이다.

지역 변수와 달리 멤버 변수를 초기화 하는 방법은 명시적 초기화, 생성자, 초기화 블럭이 있다.

1. 명시적 초기화
변수를 선언과 동시에 초기화 하는 것을 말한다.
class OOP_5 {
	int door = 4;
}
가장 간단한 방법이다.

2. 초기화 블록
초기화 블록은 '클래스 초기화 블록'과 '인스턴스 초기화 블록' 두 가지 종류가 있다.
- 클래스 초기화 블록 : 클래스 변수를 초기화 하는데 사용된다.
static {
}
클래스 내에 위의 블록을 선언하고, {} 블록 안에서 조건문, 반복문 등 다양한 문법을 활용할 수 있다.
클래스 초기화 블록은 클래스가 메모리에 로딩될 때 한 번만 수행된다.

- 인스턴스 초기화 블록 : 인스턴스 변수를 초기화 하는데 사용된다.
클래스 내에 {} 블록을 선언하고, 그 안에서 다양한 문법을 활용하여 초기화 한다.
인스턴스 초기화 블록은 인스턴스가 생성될 때 마다 실행된다.
이때 인스턴스 초기화 블록은 생성자보다 먼저 수행된다.

인스턴스 변수를 초기화 하는 역할은 생성자가 하게되고, 모든 생성자가 공통적으로 수행하는 작업을 인스턴스 초기화 블록에 사용된다.
즉, 생성자에 있는 중복되는 코드들을 인스턴스 초기화 블록에 빼는데 활용된다.

[ 멤버변수의 초기화 시기와 순서 ]
클래스 변수의 초기화시점 : 클래스가 메모리에 로딩됐을 때 한번
인스턴스 변수의 초기화 시점 : 인스턴스가 생성될 때 마다 각 인스턴스 별로 초기화

클래스 변수의 초기화 순서 : 기본 값 -> 명시적 초기화 -> 클래스 초기화 블록
인스턴스 변수의 초기화 순서 : 기본 값 -> 명시적 초기화 -> 인스턴스 초기화 블록 -> 생성자

# 클래스가 메모리에 로딩이 될 때에는 클래스에 대한 정보가 요구될 때 이다. ( 인스턴스를 생성하거나 클래스 멤버를 사용할 때 )
	ㄴ 클래스 로딩 시점은 JVM 마다 다르다. ( 프로그램이 시작될 때 필요한 클래스를 미리 등록하는 경우도 있다. )
	
[ 상속 ]
상속은 기존 클래스를 활용하여 새로운 클래스를 만드는 것을 말한다.
기존 클래스를 활용하기 때문에 더 적은 코드로 클래스를 구현할 수 있다. 이를 통해 코드를 공통으로 관리할 수 있으며, 그 결과 중복을 줄이고 재사용성을 높아지는 장점이 있다.

자바에서는 상속을 받는 클래스의 이름 옆에 상속해주는 클래스를 extends 키워드와 함께 작성해주면된다.
extends 는 확장이라는 뜻을 가지고 있으며, 조상 클래스를 확장 ( extend ) 한다는 의미를 가지고 있다.
	ㄴ 이때 상속해 주는 클래스를 조상 클래스라 한다.
	ㄴ 상속을 받는 클래스를 자손 클래스라 한다.

	
Class Child extends Parent {
}

상속은 보통 2개 이상의 클래스가 공통의 코드를 가지게 될 때, 상속 관계를 이용하여 이들의 조상 클래스에 공통의 코드를 작성해준다.
그렇게 되면 코드 변경 시 한 곳만 수정하면 되기 때문에 유지 보수가 용이하며 버그 발생 가능성이 줄어들게 된다.

이때 자손 클래스는 조상 클래스의 모든 멤버를 가지게 된다.
단, 멤버인 멤버 변수와 메서드만 상속을 받을 뿐, 생성자와 초기화 블록 등은 상속되지 않는다.
	ㄴ 자손 클래스는 조상 클래스보다 멤버 변수가 항상 같거나 많다.
	ㄴ 접근 제어자가 private 이거나 default 인 멤버의 경우에도 조상 클래스의 상속을 받지만 자손 클래스에서는 접근이 안된다.
추가로 자손 클래스의 인스턴스를 생성하면 조상 클래스의 멤버도 함께 생성되기 때문에 조상 클래스의 인스턴스를 생성할 필요는 없다.

[Child] -> [Parent]
# 상속 계층도로 다음과 같이 표현할 수 있다. [] 는 타원으로 표현되고, 자손 클래스에서 조상 클래스로 화살표가 이어준다.

조상 클래스에서 멤버 ( 변수나 메서드 ) 가 변경될 경우에 자손 클래스는 영향을 받게 된다.
하지만 자손 클래스의 멤버를 변경할 경우에 조상 클래스는 영향을 받지 않는다.

