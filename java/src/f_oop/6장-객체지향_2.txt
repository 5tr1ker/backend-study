[ 오버 로딩 ]

메서드 오버로딩은 같은 이름을 가진 메서드를 여러가지 정의하는 것을 말한다.

오버 로딩의 조건은 1. 메서드 이름이 같아야 하고, 2. 매개변수의 갯수나 타입이 달라야 한다.
위의 조건이 성립되지 않으면 오버 로딩이 될 수 없으며, 메서드 중복 정의로 오류가 발생할 수 있다.

또한 오버로딩은 이름이 같아도 매개 변수로 구분할 수 있지만, 반환 타입으로는 구분할 수 없다.

오버로딩을 활용하면 메서드의 이름을 간단하게 구현할 수 있어, 메서드의 역할을 쉽게 알 수 있고 범용적으로 사용할 수 있다.
	ㄴ 만약 메서드의 이름이 모두 달라야 한다면, 메서드의 이름은 더 구체적이며 길어질 것이고 사용자도 이러한 메서드들을 모두 구분해야 한다.
	
[ 가변 인자 ]
가변 인자 ( variable arguments ) 를 활용하여 매개 변수의 값을 동적으로 받을 수 있다.

가변 인자는 "자료형... 변수명" 으로 선언하며, 매개 변수에는 가변 인자가 항상 끝에 와야 한다.
만약 가변 인자 뒤에 다른 매개 변수가 있다 하면 컴파일 오류가 발생한다.

String... args 와 같은 매개변수가 있다 하면 해당 매개 변수에 0개~N개까지 문자열을 매개변수로 제공해도 되며,
더 나아가 배열도 줄 수 있다. ex) new String[] {"A" , "C"}

가변 인자는 메서드가 호출될 때 마다 내부적으로 배열을 새로 생성해서 활용하기 때문에 비효율적이다. 따라서 꼭 필요한 경우에만 활용하는 것이 좋다.
그렇다고 가변 인자가 아닌 배열을 사용할 경우, 값이 없을 때 길이가 0인 배열을 만들어주어야 한다. 즉, 값이 없다고 빈 값을 보내면 안된다. ( 매개 변수의 갯수를 맞춰야 하기 때문이다. )

[ 생성자 ]
생성자는 인스턴스가 생성될 때 실행되는 '인스턴스 초기화 메서드' 이다.
주로 인스턴스 변수를 초기화 하거나, 인스턴스 생성 시 실행해야 할 작업을 위해 활용된다.

생성자는 일반 메서드와 유사 하지만 반환 값이 없다. ( void 도 아니다. )
그리고 생성자의 이름은 클래스의 이름과 같다.
생성자 역시 메서드 처럼 메서드 오버로딩이 가능하다.

클래스이름(매개변수){
	코드..
}

new 연산자가 인스턴스를 생성하는 것이지, 생성자가 인스턴스를 생성하는 것은 아니다.
Car car = new Car();
위의 인스턴스 생성 코드는 다음과 같은 순서로 진행된다.
1. new 연산자에 의해 heap 메모리에 Car 클래스의 인스턴스가 생성된다.
2. 생성자 Card() 가 호출되어 수행된다.
3. 생성된 Car 클래스의 인스턴스 주소 값이 대입 연산자에 의해 car 참조 변수에 들어간다.

여기서 인스턴스를 생성하기 위한 코드 중 "new Car()" 중 Car() 이 생성자였던 것이다.
인스턴스를 생성하기 위해 클래스 내에 있는 생성자 중 1개를 반드시 호출해야 한다.

- 기본 생성자
만약 클래스 구현 시 생성자를 하나도 만들지 않은 경우에는 컴파일러는 소스 코드 (.java)를 컴파일 할 때 기본 생성자를 생성한다. 
컴파일러가 기본 생성자를 생성할 때는 하단의 코드와 같이 매개변수와 구현부가 하나도 없는 생성자를 만든다.
클래스이름() {
}

만약 인스턴스 초기화 작업이 필요 없다면, 컴파일러가 만들어주는 기본 생성자를 활용해도 좋다.
# 이때 컴파일러가 만들어주는 기본 생성자의 접근자는 클래스의 접근자와 동일하게 만든다.

단, 기본 생성자는 클래스 내에 선언된 생성자가 하나도 없을 때 뿐이다. 만약 소스 코드 내에 생성자가 1개라도 구현되어 있다면 컴파일러는 기본 생성자를 만들지 않는다.

생성자에서 매개 변수를 입력 받아, 해당 매개변수의 값으로 인스턴스의 값을 초기화 한다면, 인스턴스의 생성과 함께 값을 초기화 할 수 있다.
만약 기본 생성자를 사용한다면 인스턴스의 생성과 초기화를 각각 해줘야 할 필요가 없어진다.

- 생성자 간의 호출 ( this() )
같은 클래스 내에서 한 생성자가 다른 생성자를 호출할 수 있다. 메서드 처럼 다른 생성자를 호출할 수 있지만 하단의 두 가지의 조건을 만족해야 한다.
1. 다른 생성자를 호출 시 코드의 첫째 줄에서 호출해야 한다.
2. 생성자 호출 시 생성자의 이름이 아닌 this() 로 호출해야 한다.

생성자는 멤버 변수를 초기화하는 목적으로 하기 때문에 항상 코드의 가장 앞인, 첫번째 코드에 위치해야 한다.
	ㄴ 다른 생성자도 초기화 하기 때문에, 생성자 내부 초기화 로직 시작 전에 초기화 해야 한다.
	
- this
'this'는 참조 변수로 인스턴스 자신을 가리킨다. 즉 this 에는 인스턴스 주소가 저장되어 있다.
참조 변수를 사용하여 인스턴스 변수들을 접근할 수 있으며, static 멤버에는 접근할 수 없다.
	ㄴ this 로도 static 멤버를 호출할 수 없는 이유는, 호출 시점에 인스턴스가 생성되지 않았을 수도 있기 때문이다.

만약 생성자의 매개 변수명과 멤버 변수명이 같을 경우, 두 변수를 구분하기 위해서 this 키워드를 활용할 수 있다.
"this.변수명" 으로 해당 변수는 지역 변수임을 지정해줄 수 있다.
따라서 this.data = data; 처럼 우측의 생성자 매개 변수 값을 좌측의 멤버 변수에 넣을 수 있다.

만약, this 를 선언하지 않고 data = data를 했을 경우에 둘다 지역 변수로 간주한다.

정리하면 this 는 참조 변수이고, this() 는 생성자이다.

[ 변수의 초기화 ]
변수를 선언하고 처음으로 값을 저장하는 것을 변수의 초기화라고 한다.
변수의 초기화는 선택적이기는 하지만, 선언 후 초기화 하는 것이 좋다.

멤버 변수는 초기화를 하지 않아도 자료형에 맞게 초기화가 되지만, 지역 변수는 반드시 초기화를 해야 한다.
class OOP_4 {
	int a;
	int b = a; // a의 0 값이 b에 들어간다.
	
	public int test(int a) {
		int b;
		int c = b; // 왼쪽의 경우 지역 변수는 초기화되지 않아 초기화할 수 없다.
	}
}

즉, 멤버 변수 ( 클래스변수, 지역변수 ) 와 배열의 초기화는 선택적이지만, 지역 변수의 초기화는 필수이다.

지역 변수와 달리 멤버 변수를 초기화 하는 방법은 명시적 초기화, 생성자, 초기화 블럭이 있다.

1. 명시적 초기화
변수를 선언과 동시에 초기화 하는 것을 말한다.
class OOP_5 {
	int door = 4;
}
가장 간단한 방법이다.

2. 초기화 블록
초기화 블록은 '클래스 초기화 블록'과 '인스턴스 초기화 블록' 두 가지 종류가 있다.
- 클래스 초기화 블록 : 클래스 변수를 초기화 하는데 사용된다.
static {
}
클래스 내에 위의 블록을 선언하고, {} 블록 안에서 조건문, 반복문 등 다양한 문법을 활용할 수 있다.
클래스 초기화 블록은 클래스가 메모리에 로딩될 때 한 번만 수행된다.

- 인스턴스 초기화 블록 : 인스턴스 변수를 초기화 하는데 사용된다.
클래스 내에 {} 블록을 선언하고, 그 안에서 다양한 문법을 활용하여 초기화 한다.
인스턴스 초기화 블록은 인스턴스가 생성될 때 마다 실행된다.
이때 인스턴스 초기화 블록은 생성자보다 먼저 수행된다.

인스턴스 변수를 초기화 하는 역할은 생성자가 하게되고, 모든 생성자가 공통적으로 수행하는 작업을 인스턴스 초기화 블록에 사용된다.
즉, 생성자에 있는 중복되는 코드들을 인스턴스 초기화 블록에 빼는데 활용된다.

[ 멤버변수의 초기화 시기와 순서 ]
클래스 변수의 초기화시점 : 클래스가 메모리에 로딩됐을 때 한번
인스턴스 변수의 초기화 시점 : 인스턴스가 생성될 때 마다 각 인스턴스 별로 초기화

클래스 변수의 초기화 순서 : 기본 값 -> 명시적 초기화 -> 클래스 초기화 블록
인스턴스 변수의 초기화 순서 : 기본 값 -> 명시적 초기화 -> 인스턴스 초기화 블록 -> 생성자

# 클래스가 메모리에 로딩이 될 때에는 클래스에 대한 정보가 요구될 때 이다. ( 인스턴스를 생성하거나 클래스 멤버를 사용할 때 )
	ㄴ 클래스 로딩 시점은 JVM 마다 다르다. ( 프로그램이 시작될 때 필요한 클래스를 미리 등록하는 경우도 있다. )
	
[ 상속 ]
상속은 기존 클래스를 활용하여 새로운 클래스를 만드는 것을 말한다.
기존 클래스를 활용하기 때문에 더 적은 코드로 클래스를 구현할 수 있다. 이를 통해 코드를 공통으로 관리할 수 있으며, 그 결과 중복을 줄이고 재사용성을 높아지는 장점이 있다.

자바에서는 상속을 받는 클래스의 이름 옆에 상속해주는 클래스를 extends 키워드와 함께 작성해주면된다.
extends 는 확장이라는 뜻을 가지고 있으며, 조상 클래스를 확장 ( extend ) 한다는 의미를 가지고 있다.
	ㄴ 이때 상속해 주는 클래스를 조상 클래스라 한다.
	ㄴ 상속을 받는 클래스를 자손 클래스라 한다.

	
Class Child extends Parent {
}

상속은 보통 2개 이상의 클래스가 공통의 코드를 가지게 될 때, 상속 관계를 이용하여 이들의 조상 클래스에 공통의 코드를 작성해준다.
그렇게 되면 코드 변경 시 한 곳만 수정하면 되기 때문에 유지 보수가 용이하며 버그 발생 가능성이 줄어들게 된다.

이때 자손 클래스는 조상 클래스의 모든 멤버를 가지게 된다.
단, 멤버인 멤버 변수와 메서드만 상속을 받을 뿐, 생성자와 초기화 블록 등은 상속되지 않는다.
	ㄴ 자손 클래스는 조상 클래스보다 멤버 변수가 항상 같거나 많다.
	ㄴ 접근 제어자가 private 이거나 default 인 멤버의 경우에도 조상 클래스의 상속을 받지만 자손 클래스에서는 접근이 안된다.
추가로 자손 클래스의 인스턴스를 생성하면 조상 클래스의 멤버도 함께 생성되기 때문에 조상 클래스의 인스턴스를 생성할 필요는 없다.

[Child] -> [Parent]
# 상속 계층도로 다음과 같이 표현할 수 있다. [] 는 타원으로 표현되고, 자손 클래스에서 조상 클래스로 화살표가 이어준다.

조상 클래스에서 멤버 ( 변수나 메서드 ) 가 변경될 경우에 자손 클래스는 영향을 받게 된다.
하지만 자손 클래스의 멤버를 변경할 경우에 조상 클래스는 영향을 받지 않는다.

[ 포함관계 ]
상속을 사용하지 않고 클래스를 재사용할 수 있는데, 클래스 간에 "포함관계"를 맺어주면 클래스를 재사용할 수 있다.
포함 관계는 한 클래스의 멤버에 다른 클래스의 참조 변수를 선언하는 것을 말한다.

이는 한 클래스에 모든 멤버를 구현하지 않고, 여러 개의 클래스로 나눈 후 포함 관계를 맺어주면, 클래스가 간결해지고 재사용성을 높일 수 있다.
Class Car {
	Engine engine;
	Mission mission;
}
위와 같이 한 Car 클래스에 모두 정의하지 않고, 단위 클래스로 나눈 다음에 클래스 내의 멤버 변수로 활용할 수 있다.

[ 포함관계 vs 상속관계 ]
따지고 보면 두 관계에 대해서 코드에는 큰 차이가 없는데, 포함관계로 할지 상속관계로 할지 고민이 될 수 있다. 
그럴때에는 하단의 문장을 활용하여 어울리는 문장의 관계를 맺어주면 된다.

포함관계 : ~는 ~를 가지고 있다. ( ~ has a ~ )
상속관계 : ~는 ~이다. ( ~ is a ~ ) 

예를 들어 "차는 엔진이다." 는 문장이 부자연스럽기 때문에 상속관계와는 맞지 않는다.
반대로 차는 엔진을 가지고 있다. 라는 문장은 자연스럽기 때문에  포함관계로 구현하면 된다.

다른 예시로 SportCar 와 Car 클래스가 있을 때, SportCar 는 Car 이다. 가 더 어울리기 때문에 두 클래스는 상속관계를 맺어주면 된다.
클래스 간의 관계를 매번 이렇게 맞아 떨어지진 않지만, 기본적인 원칙에 대한 감은 찾을 수 있다.


- toString()
toString() 은 인스턴스의 정보를 문자열로 반환시켜 주는 메서드이다.
객체 참조 변수를 그대로 출력하면 해당 참조 변수의 주소에 있는 인스턴스의 toString() 을 호출한다.
ex ) System.out.println(c);

toString() 은 참조변수를 출력하거나, 문자열과의 결합에는 해당 toString()이 자동으로 호출되어 문자열로 변환하여 처리된다.
toString() 은 모든 클래스의 조상인 Object 클래스에 정의되어 있어서 모든 클래스에서 호출할 수 있다.

[ 단일 상속 ]
다른 객체지향언어인 C++ 과는 달리 자바에서는 단일 상속만 허용된다.
즉 한 클래스는 최대 하나인 클래스만 상속받을 수 있다.
다중 상속을 허용할 경우 복합 기능을 가진 클래스를 작성할 수 있다는 장점을 가지고 있지만, 클래스의 관계가 복잡해지고 조상 클래스의 멤버 이름이 같은 경우에 이름을 구분할 수 없다는 단점을 가지고있다.

만약 여러 클래스를 상속 받는다고 할 때, 조상 클래스 간에 같은 메서드가 있다고 하면 어떤 메서드를 상속 받을 지도 모호해지고,
이러한 메서드를 상속 받는다고 할지라도 조상 클래스의 어떤 메서드를 호출할지 지정하는 것도 쉽지 않다.
메서드 앞에 클래스 이름을 붙이거나, 조상 클래스의 메서드를 모두 다르게 설정하는 것도 방법이겠지만 쉽지 않다.

이러한 점 때문에 Java에서는 다중 상속의 장점을 포기하고 단일 상속을 채택했다.
단일 상속을 사용하면 클래스간의 관계가 명확해진다는 장점은 가지고 있다.

[ Object 클래스 - 모든 클래스의 조상 ]
Object 클래스는 모든 클래스의 조상이다.
상속받지 않는 클래스에 대해 컴파일러는 Object 클래스를 상속 받을 수 있게 설정한다.

예를 들어 아래와 같이 아무것도 상속받지 않는 클래스가 있을 경우에, 컴파일 시점에 클래스 이름 뒤에 extends Object 가 붙게 된다.
Class Car {} -> Class Car extends Object {}

만일 이미 다른 클래스로 부터 상속을 받는 다고 할 경우, extends Object를 추가하지 않는다.
다만, 상속 계층도에 따라 조상 클래스를 따라 올라가면 결국 Object 클래스를 상속받는 조상 클래스를 볼 수 있다.

toString() 과 .equals() 메서드 등을 정의하지 않고도 사용할 수 있었던 이유도 Object 클래스에 정의되어 있기 때문이다.

[ 오버라이딩 ]
조상 클래스로부터 상속받은 메서드의 내용을 자손 클래스에서 재 정의하는 것을 오버 라이딩이라고 한다.
보통 상속받은 메서드를 그대로 사용해도 되지만, 자손 클래스에 맞게 재정의 하는 경우도 있다.
# override의 사전적 의미는 덮어쓰다 이다.

조상 클래스의 메서드를 오버라이딩 하면, 기존에 조상 클래스를 사용하던 사람들이 해당 메서드의 역할에 예상되는 결과를
자손 클래스에 맞게 받을 수 있기 때문에 새로운 클래스를 정의하는 것 보다는 오버라이딩 하는 것이 좋다.

- 오버 라이딩의 조건
자손 클래스에서 오버라이딩을 하기 위한 조건은 다음과 같다.
1. 메서드의 이름이 같아야한다.
2. 반환 타입이 같아야 한다.
3. 매개변수가 같아야 한다.
4. 접근 제어자는 조상 클래스의 메서드보다 좁은 범위로 설정할 수 없다.
	ㄴ 만약 조상 클래스의 메서드의 접근 제어자가 protected 일 경우, 자손 클래스에서 오버라이딩 할 때 protected 이거나 public 으로 해야한다.
	ㄴ 접근 제어자는 보통 조상 클래스와 같은 제어자로 설정한다. 접근 제어자를 넓은 범위에서 좁은 범위로 나열하면 다음과 갘다. public > protected > default > private
5. 조상 클래스의 메서드보다 많은 수의 예외 처리를 하면 안된다.
	ㄴ 이때 예외의 갯수를 줄이고자 예외의 조상 클래스인 Exception 으로 설정할 수 없다.
	ㄴ 즉 던져진 예외 클래스의 갯수가 작더라도 Exception은 범위가 더 크기 때문에 갯수가 작다고 할 수 없다.
6. 인스턴스 메서드를 static 메서드로, 혹은 반대로 설정할 수 없다.
	ㄴ 조상 클래스와 자손 클래스 모두 같은 static 메서드를 가지고 있을 경우, 이는 각자의 클래스에 선언된 별개의 멤버이다.
	
# 오버로딩 : 기존에 없는 메서드를 생성하는 것
# 오버라이딩 : 상속 받은 메서드의 구현부를 재정의 하는 것

[ super ]
super는 자손 클래스에서 조상 클래스의 멤버를 참조하는데 사용되는 참조 변수이다.
조상 클래스와 자손 클래스의 멤버 변수명이 같을 때, 이를 구분하기 위해 사용된다.

만일, 조상 클래스에서 상속 받은 멤버가 자손 클래스에 없다면 super 와 this 는 큰 차이가 없다.
	ㄴ 조상 클래스로 부터 상속받은 멤버도 자신의 멤버이기 때문이다.
	ㄴ 즉 super로 하든 this 로 하든 같은 값을 출력한다.
다만 조상 클래스에서 상속 받은 멤버와 자손 클래스에서 같은 변수명이 있다면 this와 super는 차이를 갖게 된다.
	ㄴ super는 조상 클래스의 멤버를, this는 자손 클래스를 참조한다.

# 마치 지역 변수와 멤버 변수의 이름이 같을 때 this 로 구분한 것과 같은거다.
# 물론 super는 변수 뿐만이 아니라 메서드에서도 사용이 가능하다.

- super()
this() 와 마찬가지로 생성자를 호출하는 코드이며, super() 는 조상 클래스의 생성자를 호출하는 역할을 한다.

상속 관계에 있는 두 클래스에서 자손 클래스의 인스턴스를 생성하면 조상 클래스의 멤버도 함께 가지고 생성된다. 이때 자손 클래스 멤버는 조상 클래스 멤버를 사용하기 전에 조상 클래스 멤버는 항상 초기화가 되어 있어야 한다.
그렇기 때문에 상속 관계에 있는 모든 클래스는 생성자의 첫 줄에서 다른 생성자나 조상의 생성자를 호출해야 한다.
	ㄴ 즉 생성자의 첫 줄에 this() 나 super() 를 호출하면 된다. 그렇지 않으면 컴파일러가 컴파일 과정에 super() 코드를 생성자의 첫 줄에 넣는다.
	ㄴ 만일 생성자에 다른 생성자를 호출하는 문장이 있다면 컴파일러가 super()를 생성하지 않는다.
	ㄴ 이때 컴파일러가 super()를 추가 후, 조상 클래스의 기본 메서드가 없다면 기본 생성자를 찾을 수 없다는 예외가 발생할 것이다.

# 즉 상속관계에서 자손 클래스를 사용하기 전 조상 클래스는 항상 초기화되어야 한다. -> 생성자의 첫 줄에서 조상의 생성자를 먼저 호출하게 된다.
	ㄴ 순서는 조상 생성자를 호출 한 후 자손 생성자가 호출된다.
	
[ Package ]
패키지는 클래스들의 묶음을 말하며, 클래스 뿐만이 아니라 인터페이스도 포함시킬 수 있다.
클래스의 이름이 같아도 패키지가 다르면 충돌이 발생하지 않는다.

클래스의 진짜이름은 패키지의 정보도 함께 포함되어 있다.
예를 들어 String.class 클래스는 java.lang.String 처럼 java.lang 패키지 안에 속해있다.

클래스가 물리적으로 하나의 클래스 파일인 것 처럼 패키지도 물리적으로 하나의 디렉토리이다.
따라서 java.lang.String 을 보면, java 폴더 안에 lang 폴더 안에 String.class 라는 클래스 파일이 실제로 존재한다.
패키지는 점'.' 으로 구분된다. 또한 점을 활용하여 계층 구조를 만들 수 있다.

패키지의 선언은 소스 파일의 최 상단에 하단의 코드를 입력하면 된다. 이때 공백과 주석을 제외한 첫번째 문장에 와야하고 단 하나만 작성되어야 한다.
이때 패키지 명에 대소문자 모두 허용하지만 소문자로 작성하는 것을 추천한다.
package '패키지명';

패키지명을 설정할 경우 해당 소스코드에 있는 모든 클래스와 인터페이스는 해당 패키지 ( 디렉토리 ) 에 생성된다.
만약 패키지 명을 적어주지 않으면 '이름 없는 패키지' 로 설정이 되어, 패키지를 설정하지 않은 모든 클래스는 해당 패키지에 모두 보관된다.

[ import ]
만약 다른 패키지에 있는 클래스를 사용하려고 하면 [ 패키지이름.클래스 ] 이름으로 사용할 수 있다.
	ㄴ 같은 패키지에 속한 클래스라면 import문 없이 클래스 명만으로도 접근할 수 있다.
하지만 import 문을 활용하면 패키지 이름을 생략하고 클래스 명만 활용하여 소스 코드를 작성할 수 있다.

# import 의 역할은 컴파일러에게 소스코드에 사용된 클래스의 패키지 명을 알려주기 위함이다.
이때 컴파일러는 컴파일 시 import 문을 통해 소스코드에 사용된 클래스들의 패키지를 알아내고, 클래스 이름 앞에 패키지 명을 붙여준다.
	ㄴ 그렇기 때문에 import 문이 많다고 소스 코드의 성능에 영향을 미치진 않고, 컴파일 시간이 더 걸릴 뿐이다.
	
import문은 소스 파일 내에서 package 문과 class 선언 문 사이에 위치하게 된다.
또한 package 와는 달리 여러번 선언할 수 있다.

import를 선언하는 방법은 다음과 같다.

import 패키지명.*
import 패키지명.클래스명

패키지 명을 생략하고 싶은 클래스 명을 작성해주면 되는데, * 처럼 해당 패키지에 있는 모든 클래스를 패키지 없이 사용할 수 있게 할 수 있다.
이때 컴파일러는 컴파일 시에 더 오래 걸릴 뿐, 성능은 차이는 전혀 없다.

다만 import를 많이 사용할 경우, 해당 클래스가 어떤 package 에 속해있는지 알 수 없다는 단점을 가지고 있다.
그리고 * 를 사용할 경우 하위의 패키지의 클래스를 포함하지는 않는다.
예를 들어 java.util.* 과 java.text.* 이 있을 경우 , java.* 은 할 수 없다는 뜻이다.

여기서 System과 String 은 java.lang 패키지에 속해있는데, import 문 없이 그냥 사용할 수 있었다.
그 이유는 java.lang 패키지는 묵시적으로 import 가 자동으로 되는데, 그 이유는 해당 패키지를 빈번히 사용하기 때문에 자동으로 import 할 수 있게 지정한 것이다.


- static import 문
static import 문을 사용하면 특정 클래스의 static 멤버를 클래스 이름 없이 호출할 수 있다.

import static java.lang.Integer.*;	# Integer 클래스 내의 모둔 static 메서드
import static java.lang.Math.random; # Math 클래스 내에 random() 함수만
import static java.lang.System.out; # out.println() 으로만 참조 가능

위의 선언을 했다면 아래의 코드로 실행시킬 수 있다.
out.println(random());

[ 제어자 modifier ]
제어자(modifier) 는 클래스나 메서드, 변수의 선언부에 함께 사용되어 부가적인 의미를 부여한다.
제어자의 종류는 접근 제어자와 그 외 제어자로 나뉜다.

접근 제어자 : public , private , default , protected
그 외 : static , final , abstract , native , transient , synchronized , volatile , strictfp

접근 제어자는 2개 이상으로 조합해서 사용할 수 있으며, 접근 제어자는 맨 왼쪽에 선언하는 것이 좋다.
이때 접근 제어자는 4개 중 하나만 사용할 수 있다.

- static ( 공통의, 클래스의 )
static은 '공통의' , '클래스의' 의 의미를 가지고 있으며, 메모리를 공유하기 때문에 모든 인스턴스가 해당 변수의 값을 공유한다.
또한 클래스가 메모리에 로드될 때 함께 생성되므로, 인스턴스의 생성 없이 사용할 수 있다.

static 은 멤버변수와 메서드에서 사용될 수 있다.
static 멤버 변수 : 모든 인스턴스가 공유하게 되는 클래스 변수가 되며, 인스턴스 생성 없이도 호출할 수 있다.
static 메서드 : 인스턴스를 생성하지 않아도 호출할 수 있지만, 인스턴스 변수에 접근할 수 없다.

만약 멤버변수를 사용하지 않는다면 static 메서드로 정의하는 것이 좋다.

- final ( 마지막의, 변경될 수 없는 )

final은 '마지막의', '변경될 수 없는' 의 의미를 가지고 있으며 거의 모든 곳에서 사용될 수 있다.

final 클래스 : final 클래스는 다른 클래스의 조상이 될 수 없다. ( 상속해서 확장할 수 없다. )
final 메서드 : final 메서드는 오버라이딩해서 재정의할 수 없다.
final 변수 : final 변수는 값을 변경할 수 없는 상수가 된다.

이때 final 변수는 선언과 동시에 초기화 해야 하지만, 생성자를 활용하면 생성자로부터 받은 매개변수의 값으로 초기화할 수 있다.
즉, 모든 인스턴스가 final 변수에 각기 다른 값을 가질 수 있다.

- abstract - 미완성의, 추상의
abstract는 '미완성의', '추상의' 의미를 가지고 있다.
클래스에 사용되며, 메서드의 선언부만 작성하고 실제 구현부는 구현되지 않은 추상 메서드를 선언하는데 사용된다.

abstract 클래스 : 클래스 내에 추상 메서드가 선언되어 있음을 알린다.
abstract 메서드 : 선언부만 작성하고 구현부는 작성하지 않은 추상 메서드를 의미한다. 

abstract class AbstractTest{
	abstract void move();
	void stop() {
		// 코드..
	}
}
위의 코드는 추상 클래스의 예제이며, 추상 클래스는 미완성 클래스이기 때문에 인스턴스를 생성할 수 없다.
위의 예제처럼 abstract 클래스네에 추상 메서드는 0개 이상 존재해야 한다. ( 즉, 추상 메서드가 없는 경우도 있다. )

가끔 추상 메서드가 하나도 없는데, abstract class로 선언된 클래스가 있다.
이는 해당 클래스를 상속하여 메서드들을 오버라이딩하게 하는 목적으로 구현된다.