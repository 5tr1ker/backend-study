[ 다형성 - polymorphism ]
객체지향개념의 다형성은 여러 형태를 가질 수 있는 능력을 뜻하며, 자바에서는 하나의 참조 변수가 여러 타입의 객체를 참조할 수 있도록 함으로써 구현하였다.
구체적으로 조상클래스의 참조 변수로 자손 클래스의 인스턴스를 참조할 수 있게 하였다.

즉, 상속 관계에 있는 두 클래스 Car와 SportCar가 있을 경우 ( Car 가 조상 ) Car c = new SportCar() 로 인스턴스를 참조할 수 있는 것이다.
SportCar sc = new SportCar();
Car c = new SportCar();
주의할 점은 인스턴스 타입이 같아도, 참조 변수의 타입에 따라 사용할 수 있는 멤버의 개수가 달라질 수 있다.
위의 코드와 같이 같은 인스턴스 타입이다 하더라도, 참조 변수 c는 SportCar 클래스에만 있는 멤버를 사용할 수 없다.

반대로 자손 클래스를 참조 변수로 하고, 조상 클래스의 인스턴스를 참조할 수 없다.
SportCar sc = new Car(); <- 불가

그 이유는 자손 클래스는 조상 클래스보다 멤버의 개수가 많기 때문에 조상 클래스에 존재하지 않는 멤버에 접근할 수 있다.
	ㄴ 조상 클래스에는 없고 자손 클래스에만 존재하는 멤버에 접근하려고 할 때, 문제가 발생할 수 있기 때문에 허용하지 않은 것이다.
	
# 보통 상속을 통해 확장하게 되면 조상클래스의 멤버 개수는 자손 클래스의 멤버 개수보다 같거나 적어지게 된다.
# 즉, 참조 변수가 사용할 수 있는 멤버의 개수는 인스턴스의 멤버의 갯수보다 같거나 작아야 한다.

# 중요한 것은 참조변수의 타입에 따라, 사용할 수 있는 인스턴스의 멤버 개수가 달라진다는 것이다.

SportCar sc = (SportCar) new Car();
위와 같이 강제로 형 변환을 할 경우 ClassCastException 예외가 발생한다.
# 즉 조상 클래스의 인스턴스를 자손 클래스의 참조 변수로 받을 수는 없다.

- 참조변수의 형 변환
상속 관계에 있는 클래스들 사이에는 형 변환하는 것이 가능하다.
이때 자손 클래스에서 조상 클래스로의 형 변환을 업캐스팅 이라고 하고,
조상 클래스를 자손 클래스로 형 변환 하는 것을 다운 캐스팅이라고 한다.

# 업캐스팅은 형변환 생략이 가능하다.
# 보통 자손 클래스에서 조상 클래스로의 형 변환은 다뤄야할 멤버의 개수가 줄어들기 때문에 문제가 발생할 가능성이 작다.
# 그와의 반대로 조상 클래스에서 자손 클래스로의 형 변환은 다뤄야할 멤버가 많아져 위험성이 있기 때문에 형 변환 연산자를 생략할 수 없다. ( 추가로 안전하게 형 변환을 위해 instanceof 연산자를 써서 타입을 확인하면 좋다 )

# 참조변수의 형 변환은 단순히 참조변수의 타입을 바꾸는 것이지 인스턴스를 변환하는 것은 아니기 때문에, 인스턴스에는 아무런 영향을 미치지 않는다. ( 인스턴스의 멤버 사용 범위를 조절하는 것 뿐이다. )
# 여기서 조상 클래스의 참조 변수와 자손 클래스의 참조 변수는 사용할 수 있는 멤버 개수가 다르다.

[ instanceof 연산자 ]
instanceof 연산자를 활용하면 참조변수가 참조하고 있는 인스턴스의 타입을 알 수 있다.
주로 조건문에 함께 사용되며 연산 결과로 boolean 값을 얻는다.

왼쪽에는 참조 변수가 오고, 오른쪽에는 클래스 이름이 위치한다.
if(c instanceof Car)

instanceof 로 true 결과를 얻을 경우 해당 클래스 타입으로 형 변환이 가능하다는 것을 알 수 있다.
# instanceof는 같은 타입 뿐만 아니라, 조상 클래스와의 연산에서도 true의 값을 얻게된다.

- 참조변수와 인스턴스의 연결

조상 클래스와 자손 클래스에 같은 이름의 인스턴스 변수가 선언되어 있을 경우 참조 변수에 따라서 다른 결과를 얻게 된다.
	ㄴ 조상 클래스의 참조 변수일 경우 조상 클래스의 멤버 변수가 호출되고, 자손 클래스의 참조 변수일 경우 자손 클래스의 멤버 변수가 호출된다.
	ㄴ 만약 조상 클래스에만 정의되어 있을 경우엔 같은 값을 가지게 된다. 그 이유는 조상의 멤버 변수 그대로 자손에서 사용하기 때문이다.
반대로 같은 이름의 메서드일 경우, 다른 참조변수라 하더라도 항상 오버라이딩된 메서드가 호출된다.

이때 중복 정의되어 있을 경우 this 와 super를 통해서 자손 클래스와 조상 클래스를 구분할 수 있다.

[ 추상클래스 ]
추상 클래스는 미완성 설계도와 같으며, 미완성 메서드 ( 추상 메서드 ) 를 가지고 있는 클래스를 말한다.
추상 클래스는 인스턴스를 생성할 수 없으며, 상속을 통해 메서드를 구현해야 한다.

추상 클래스는 class 앞에 abstract 키워드를 붙여주기만 하면 된다.
여기서 추상 클래스는 추상 메서드만 가지고 있을 뿐 일반 클래스와 다를 것이 없다.
생성자도 가질 수 있고 멤버 변수도 가질 수 있다.

- 추상 메서드
추상 메서드는 메서드에서 선언부만 있는 것을 말한다.
메서드를 선언만 하는 이유는 상속받은 클래스에 따라 달라질 수 있기 때문이다.
따라서 자손 클래스는 상황에 맞게 클래스를 구현해야 한다.

추상 메서드 역시 abstract 키워드를 붙여주고, {} 괄호 대신 세미콜론만 붙여주면 된다.
abstract void method();

이때 추상 클래스의 자손 클래스는 추상 메서드를 모두 오버라이딩 해야 하며, 한 개라도 오버라이딩을 하지 않을 경우 자손 클래스도 추상 클래스로 지정해주어야 한다.

만약 어차피 자손에서 구현한다고 하면 몸통이 빈 메서드를 해도 되지 않을까? 왜 굳이 추상 메서드를 쓰는 이유가 뭘까?
	ㄴ 그 이유는 추상 메서드로 지정하면, 오버라이딩 해야 하는 것을 알릴 수 있다. 일반 몸통일 경우 자손 클래스를 구현할 때 놓칠 수 있기 때문이다.
	ㄴ 즉, 자손 클래스에서 추상 메서드를 반드시 구현하도록 하는 것이다.

# 구체화는 상속을 통해 클래스를 구체적으로 구현 및 확장하는 것이라 할 수 있으며,
# 추상화는 기존 클래스에서 공통 부분을 추출하여 조상 클래스로 만드는 것이라고 볼 수 있다.
# 이를 통해 구체화와 추상화는 반대의 성질을 가지고 있음을 알 수 있다.
# 상속계층도를 내려갈수록 클래스가 구체화되는 것을 볼 수 있고, 반대로 올라갈 수록 추상화의 정도가 심해진다는 것을 알 수 있다.
# 따라서 추상클래스를 사용하는 이유는 여러 클래스들의 공통 부분을 추출하여 추상화하기 위해 사용한다고 볼 수 있다.
# 추상 : 개념에서 공통적인 성질을 뽑아 이를 일반적인 개념으로 파악하는 활동

[ 인터페이스 ]
인터페이스는 일종의 추상 클래스이며, 추상 클래스보다 추상화 정도가 더 높아서 추상 메서드와 상수만 선언할 수 있다.
즉, 몸통을 가진 메서드와 멤버 변수를 가질 수 없다.

# 즉 인터페이스와 추상 클래스는 추상적인 개념을 설계한다. 여기서 인터페이스는 추상 클래스보다 더 추상적인 개념을 가진다.
# 상속 계층도를 따라 올라갈 수록 추상적인 개념이 많아지는데, 이는 인터페이스가 더 많아질 수 있다.
# 추상 클래스는 부분만 완성된 "미완성 설계도"라고 한다면, 인터페이스는 아무것도 없고 밑그림만 그려져있는 "기본 설계도"라고 할 수 있다.
인터페이스 역시 완성된 설계도가 아니기 때문에 인스턴스를 생성할 수 없다.

인터페이스를 작성할 때는 class 대신에 interface를 붙여주면 되고 public 또는 default를 붙일 수 있다.
인터페이스에 작성되는 멤버는 다음과 같은 제약 사항이 있다.
1. 모든 멤버변수는 public static final 이어야 하며 생략할 수 있다.
2. 모든 메서드는 public abstract 이어야 하며 생략할 수 있다.
	ㄴ 단 static 메서드와 디폴트 메서드는 예외 ( JDK 1.8 이상 )
모든 멤버에 예외없이 적용되기 때문에 제어자를 생략할 수 있으며, 생략 시 컴파일러가 컴파일 시에 추가해준다.

public interface InterfaceStudy {
    int value = 30;
    int key = 16;

    void print();
    void walk();
}

public interface AnotherInterface extends InterfaceStudy{
}

이때 인터페이스는 다중상속이 가능하다.
인터페이스를 상속받는 인터페이스는 extends 키워드를 통해 상속을 받는다.

- 인터페이스의 구현
인터페이스는 해당 인터페이스를 구현하는 클래스에 대해 implements 키워드를 활용하여 상속을 한다.
public class InterfaceImplements extends Car implements InterfaceStudy {

    @Override
    public void print() {

    }

    @Override
    public void walk() {

    }
}

만약 인터페이스에 있는 추상 메서드 중 일부만 구현한다면 해당 클래스를 abstract 클래스로 선언해야 하며,
위의 예제와 같이 implements 와 extends 를 동시에 할 수 있다.

# extends는 확장 한다는 의미이며, implements 는 구현한다는 의미를 가지고 있다.

# 인터페이스의 이름은 able ( ~을 할 수 있는 ) 로 끝나는 경우가 많다, 그 이유는 특정 행위를 하는데 필요한 메서드를 제공한다는 의미를 강조하기 위해서이며,
# 해당 인터페이스를 구현할 경우 ~을 할 수 있는 능력을 갖추었다는 의미를 갖는다.
# ex ) public interface Fightable { void attack(); void walk(); }

그리고 인터페이스도 다형성의 특성을 활용해 인터페이스 참조 변수에 해당 인터페이스의 구현체의 인스턴스를 참조할 수 있다.
// InterfaceStudy -> 인터페이스
// InterfaceImplements -> 구현체
InterfaceStudy is1 = new InterfaceImplements();

InterfaceStudy method(InterfaceStudy study) {
	return new InterfaceImplements();
}
위의 코드는 매개 변수와 반환 타입이 모두 인터페이스이다.
이것은 인자로 해당 인터페이스를 구현한 클래스의 인스턴스를 넘겨받아야 하며, 반환값으로는 해당 인터페이스를 구현한 클래스의 인스턴스를 반환한다는 뜻이다.