[ 다형성 - polymorphism ]
객체지향개념의 다형성은 여러 형태를 가질 수 있는 능력을 뜻하며, 자바에서는 하나의 참조 변수가 여러 타입의 객체를 참조할 수 있도록 함으로써 구현하였다.
구체적으로 조상클래스의 참조 변수로 자손 클래스의 인스턴스를 참조할 수 있게 하였다.

즉, 상속 관계에 있는 두 클래스 Car와 SportCar가 있을 경우 ( Car 가 조상 ) Car c = new SportCar() 로 인스턴스를 참조할 수 있는 것이다.
SportCar sc = new SportCar();
Car c = new SportCar();
주의할 점은 인스턴스 타입이 같아도, 참조 변수의 타입에 따라 사용할 수 있는 멤버의 개수가 달라질 수 있다.
위의 코드와 같이 같은 인스턴스 타입이다 하더라도, 참조 변수 c는 SportCar 클래스에만 있는 멤버를 사용할 수 없다.

반대로 자손 클래스를 참조 변수로 하고, 조상 클래스의 인스턴스를 참조할 수 없다.
SportCar sc = new Car(); <- 불가

그 이유는 자손 클래스는 조상 클래스보다 멤버의 개수가 많기 때문에 조상 클래스에 존재하지 않는 멤버에 접근할 수 있다.
	ㄴ 조상 클래스에는 없고 자손 클래스에만 존재하는 멤버에 접근하려고 할 때, 문제가 발생할 수 있기 때문에 허용하지 않은 것이다.
	
# 보통 상속을 통해 확장하게 되면 조상클래스의 멤버 개수는 자손 클래스의 멤버 개수보다 같거나 적어지게 된다.
# 즉, 참조 변수가 사용할 수 있는 멤버의 개수는 인스턴스의 멤버의 갯수보다 같거나 작아야 한다.

# 중요한 것은 참조변수의 타입에 따라, 사용할 수 있는 인스턴스의 멤버 개수가 달라진다는 것이다.

SportCar sc = (SportCar) new Car();
위와 같이 강제로 형 변환을 할 경우 ClassCastException 예외가 발생한다.
# 즉 조상 클래스의 인스턴스를 자손 클래스의 참조 변수로 받을 수는 없다.

- 참조변수의 형 변환
상속 관계에 있는 클래스들 사이에는 형 변환하는 것이 가능하다.
이때 자손 클래스에서 조상 클래스로의 형 변환을 업캐스팅 이라고 하고,
조상 클래스를 자손 클래스로 형 변환 하는 것을 다운 캐스팅이라고 한다.

# 업캐스팅은 형변환 생략이 가능하다.
# 보통 자손 클래스에서 조상 클래스로의 형 변환은 다뤄야할 멤버의 개수가 줄어들기 때문에 문제가 발생할 가능성이 작다.
# 그와의 반대로 조상 클래스에서 자손 클래스로의 형 변환은 다뤄야할 멤버가 많아져 위험성이 있기 때문에 형 변환 연산자를 생략할 수 없다. ( 추가로 안전하게 형 변환을 위해 instanceof 연산자를 써서 타입을 확인하면 좋다 )

# 참조변수의 형 변환은 단순히 참조변수의 타입을 바꾸는 것이지 인스턴스를 변환하는 것은 아니기 때문에, 인스턴스에는 아무런 영향을 미치지 않는다. ( 인스턴스의 멤버 사용 범위를 조절하는 것 뿐이다. )
# 여기서 조상 클래스의 참조 변수와 자손 클래스의 참조 변수는 사용할 수 있는 멤버 개수가 다르다.

[ instanceof 연산자 ]
instanceof 연산자를 활용하면 참조변수가 참조하고 있는 인스턴스의 타입을 알 수 있다.
주로 조건문에 함께 사용되며 연산 결과로 boolean 값을 얻는다.

왼쪽에는 참조 변수가 오고, 오른쪽에는 클래스 이름이 위치한다.
if(c instanceof Car)

instanceof 로 true 결과를 얻을 경우 해당 클래스 타입으로 형 변환이 가능하다는 것을 알 수 있다.
# instanceof는 같은 타입 뿐만 아니라, 조상 클래스와의 연산에서도 true의 값을 얻게된다.

- 참조변수와 인스턴스의 연결

조상 클래스와 자손 클래스에 같은 이름의 인스턴스 변수가 선언되어 있을 경우 참조 변수에 따라서 다른 결과를 얻게 된다.
	ㄴ 조상 클래스의 참조 변수일 경우 조상 클래스의 멤버 변수가 호출되고, 자손 클래스의 참조 변수일 경우 자손 클래스의 멤버 변수가 호출된다.
	ㄴ 만약 조상 클래스에만 정의되어 있을 경우엔 같은 값을 가지게 된다. 그 이유는 조상의 멤버 변수 그대로 자손에서 사용하기 때문이다.
반대로 같은 이름의 메서드일 경우, 다른 참조변수라 하더라도 항상 오버라이딩된 메서드가 호출된다.

이때 중복 정의되어 있을 경우 this 와 super를 통해서 자손 클래스와 조상 클래스를 구분할 수 있다.

[ 추상클래스 ]
추상 클래스는 미완성 설계도와 같으며, 미완성 메서드 ( 추상 메서드 ) 를 가지고 있는 클래스를 말한다.
추상 클래스는 인스턴스를 생성할 수 없으며, 상속을 통해 메서드를 구현해야 한다.

추상 클래스는 class 앞에 abstract 키워드를 붙여주기만 하면 된다.
여기서 추상 클래스는 추상 메서드만 가지고 있을 뿐 일반 클래스와 다를 것이 없다.
생성자도 가질 수 있고 멤버 변수도 가질 수 있다.

- 추상 메서드
추상 메서드는 메서드에서 선언부만 있는 것을 말한다.
메서드를 선언만 하는 이유는 상속받은 클래스에 따라 달라질 수 있기 때문이다.
따라서 자손 클래스는 상황에 맞게 클래스를 구현해야 한다.

추상 메서드 역시 abstract 키워드를 붙여주고, {} 괄호 대신 세미콜론만 붙여주면 된다.
abstract void method();

이때 추상 클래스의 자손 클래스는 추상 메서드를 모두 오버라이딩 해야 하며, 한 개라도 오버라이딩을 하지 않을 경우 자손 클래스도 추상 클래스로 지정해주어야 한다.

만약 어차피 자손에서 구현한다고 하면 몸통이 빈 메서드를 해도 되지 않을까? 왜 굳이 추상 메서드를 쓰는 이유가 뭘까?
	ㄴ 그 이유는 추상 메서드로 지정하면, 오버라이딩 해야 하는 것을 알릴 수 있다. 일반 몸통일 경우 자손 클래스를 구현할 때 놓칠 수 있기 때문이다.
	ㄴ 즉, 자손 클래스에서 추상 메서드를 반드시 구현하도록 하는 것이다.

# 구체화는 상속을 통해 클래스를 구체적으로 구현 및 확장하는 것이라 할 수 있으며,
# 추상화는 기존 클래스에서 공통 부분을 추출하여 조상 클래스로 만드는 것이라고 볼 수 있다.
# 이를 통해 구체화와 추상화는 반대의 성질을 가지고 있음을 알 수 있다.
# 상속계층도를 내려갈수록 클래스가 구체화되는 것을 볼 수 있고, 반대로 올라갈 수록 추상화의 정도가 심해진다는 것을 알 수 있다.
# 따라서 추상클래스를 사용하는 이유는 여러 클래스들의 공통 부분을 추출하여 추상화하기 위해 사용한다고 볼 수 있다.
# 추상 : 개념에서 공통적인 성질을 뽑아 이를 일반적인 개념으로 파악하는 활동
