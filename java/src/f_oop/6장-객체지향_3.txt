[ 다형성 - polymorphism ]
객체지향개념의 다형성은 여러 형태를 가질 수 있는 능력을 뜻하며, 자바에서는 하나의 참조 변수가 여러 타입의 객체를 참조할 수 있도록 함으로써 구현하였다.
구체적으로 조상클래스의 참조 변수로 자손 클래스의 인스턴스를 참조할 수 있게 하였다.

즉, 상속 관계에 있는 두 클래스 Car와 SportCar가 있을 경우 ( Car 가 조상 ) Car c = new SportCar() 로 인스턴스를 참조할 수 있는 것이다.
SportCar sc = new SportCar();
Car c = new SportCar();
주의할 점은 인스턴스 타입이 같아도, 참조 변수의 타입에 따라 사용할 수 있는 멤버의 개수가 달라질 수 있다.
위의 코드와 같이 같은 인스턴스 타입이다 하더라도, 참조 변수 c는 SportCar 클래스에만 있는 멤버를 사용할 수 없다.

반대로 자손 클래스를 참조 변수로 하고, 조상 클래스의 인스턴스를 참조할 수 없다.
SportCar sc = new Car(); <- 불가

그 이유는 자손 클래스는 조상 클래스보다 멤버의 개수가 많기 때문에 조상 클래스에 존재하지 않는 멤버에 접근할 수 있다.
	ㄴ 조상 클래스에는 없고 자손 클래스에만 존재하는 멤버에 접근하려고 할 때, 문제가 발생할 수 있기 때문에 허용하지 않은 것이다.
	
# 보통 상속을 통해 확장하게 되면 조상클래스의 멤버 개수는 자손 클래스의 멤버 개수보다 같거나 적어지게 된다.
# 즉, 참조 변수가 사용할 수 있는 멤버의 개수는 인스턴스의 멤버의 갯수보다 같거나 작아야 한다.

# 중요한 것은 참조변수의 타입에 따라, 사용할 수 있는 인스턴스의 멤버 개수가 달라진다는 것이다.

SportCar sc = (SportCar) new Car();
위와 같이 강제로 형 변환을 할 경우 ClassCastException 예외가 발생한다.
# 즉 조상 클래스의 인스턴스를 자손 클래스의 참조 변수로 받을 수는 없다.

- 참조변수의 형 변환
상속 관계에 있는 클래스들 사이에는 형 변환하는 것이 가능하다.
이때 자손 클래스에서 조상 클래스로의 형 변환을 업캐스팅 이라고 하고,
조상 클래스를 자손 클래스로 형 변환 하는 것을 다운 캐스팅이라고 한다.

# 업캐스팅은 형변환 생략이 가능하다.
# 보통 자손 클래스에서 조상 클래스로의 형 변환은 다뤄야할 멤버의 개수가 줄어들기 때문에 문제가 발생할 가능성이 작다.
# 그와의 반대로 조상 클래스에서 자손 클래스로의 형 변환은 다뤄야할 멤버가 많아져 위험성이 있기 때문에 형 변환 연산자를 생략할 수 없다. ( 추가로 안전하게 형 변환을 위해 instanceof 연산자를 써서 타입을 확인하면 좋다 )

# 참조변수의 형 변환은 단순히 참조변수의 타입을 바꾸는 것이지 인스턴스를 변환하는 것은 아니기 때문에, 인스턴스에는 아무런 영향을 미치지 않는다. ( 인스턴스의 멤버 사용 범위를 조절하는 것 뿐이다. )
# 여기서 조상 클래스의 참조 변수와 자손 클래스의 참조 변수는 사용할 수 있는 멤버 개수가 다르다.

[ instanceof 연산자 ]
instanceof 연산자를 활용하면 참조변수가 참조하고 있는 인스턴스의 타입을 알 수 있다.
주로 조건문에 함께 사용되며 연산 결과로 boolean 값을 얻는다.

왼쪽에는 참조 변수가 오고, 오른쪽에는 클래스 이름이 위치한다.
if(c instanceof Car)

instanceof 로 true 결과를 얻을 경우 해당 클래스 타입으로 형 변환이 가능하다는 것을 알 수 있다.
# instanceof는 같은 타입 뿐만 아니라, 조상 클래스와의 연산에서도 true의 값을 얻게된다.

- 참조변수와 인스턴스의 연결

조상 클래스와 자손 클래스에 같은 이름의 인스턴스 변수가 선언되어 있을 경우 참조 변수에 따라서 다른 결과를 얻게 된다.
	ㄴ 조상 클래스의 참조 변수일 경우 조상 클래스의 멤버 변수가 호출되고, 자손 클래스의 참조 변수일 경우 자손 클래스의 멤버 변수가 호출된다.
	ㄴ 만약 조상 클래스에만 정의되어 있을 경우엔 같은 값을 가지게 된다. 그 이유는 조상의 멤버 변수 그대로 자손에서 사용하기 때문이다.
반대로 같은 이름의 메서드일 경우, 다른 참조변수라 하더라도 항상 오버라이딩된 메서드가 호출된다.

이때 중복 정의되어 있을 경우 this 와 super를 통해서 자손 클래스와 조상 클래스를 구분할 수 있다.

[ 추상클래스 ]
추상 클래스는 미완성 설계도와 같으며, 미완성 메서드 ( 추상 메서드 ) 를 가지고 있는 클래스를 말한다.
추상 클래스는 인스턴스를 생성할 수 없으며, 상속을 통해 메서드를 구현해야 한다.

추상 클래스는 class 앞에 abstract 키워드를 붙여주기만 하면 된다.
여기서 추상 클래스는 추상 메서드만 가지고 있을 뿐 일반 클래스와 다를 것이 없다.
생성자도 가질 수 있고 멤버 변수도 가질 수 있다.

- 추상 메서드
추상 메서드는 메서드에서 선언부만 있는 것을 말한다.
메서드를 선언만 하는 이유는 상속받은 클래스에 따라 달라질 수 있기 때문이다.
따라서 자손 클래스는 상황에 맞게 클래스를 구현해야 한다.

추상 메서드 역시 abstract 키워드를 붙여주고, {} 괄호 대신 세미콜론만 붙여주면 된다.
abstract void method();

이때 추상 클래스의 자손 클래스는 추상 메서드를 모두 오버라이딩 해야 하며, 한 개라도 오버라이딩을 하지 않을 경우 자손 클래스도 추상 클래스로 지정해주어야 한다.

만약 어차피 자손에서 구현한다고 하면 몸통이 빈 메서드를 해도 되지 않을까? 왜 굳이 추상 메서드를 쓰는 이유가 뭘까?
	ㄴ 그 이유는 추상 메서드로 지정하면, 오버라이딩 해야 하는 것을 알릴 수 있다. 일반 몸통일 경우 자손 클래스를 구현할 때 놓칠 수 있기 때문이다.
	ㄴ 즉, 자손 클래스에서 추상 메서드를 반드시 구현하도록 하는 것이다.

# 구체화는 상속을 통해 클래스를 구체적으로 구현 및 확장하는 것이라 할 수 있으며,
# 추상화는 기존 클래스에서 공통 부분을 추출하여 조상 클래스로 만드는 것이라고 볼 수 있다.
# 이를 통해 구체화와 추상화는 반대의 성질을 가지고 있음을 알 수 있다.
# 상속계층도를 내려갈수록 클래스가 구체화되는 것을 볼 수 있고, 반대로 올라갈 수록 추상화의 정도가 심해진다는 것을 알 수 있다.
# 따라서 추상클래스를 사용하는 이유는 여러 클래스들의 공통 부분을 추출하여 추상화하기 위해 사용한다고 볼 수 있다.
# 추상 : 개념에서 공통적인 성질을 뽑아 이를 일반적인 개념으로 파악하는 활동

[ 인터페이스 ]
인터페이스는 일종의 추상 클래스이며, 추상 클래스보다 추상화 정도가 더 높아서 추상 메서드와 상수만 선언할 수 있다.
즉, 몸통을 가진 메서드와 멤버 변수를 가질 수 없다.

# 즉 인터페이스와 추상 클래스는 추상적인 개념을 설계한다. 여기서 인터페이스는 추상 클래스보다 더 추상적인 개념을 가진다.
# 상속 계층도를 따라 올라갈 수록 추상적인 개념이 많아지는데, 이는 인터페이스가 더 많아질 수 있다.
# 추상 클래스는 부분만 완성된 "미완성 설계도"라고 한다면, 인터페이스는 아무것도 없고 밑그림만 그려져있는 "기본 설계도"라고 할 수 있다.
인터페이스 역시 완성된 설계도가 아니기 때문에 인스턴스를 생성할 수 없다.

인터페이스를 작성할 때는 class 대신에 interface를 붙여주면 되고 public 또는 default를 붙일 수 있다.
인터페이스에 작성되는 멤버는 다음과 같은 제약 사항이 있다.
1. 모든 멤버변수는 public static final 이어야 하며 생략할 수 있다.
2. 모든 메서드는 public abstract 이어야 하며 생략할 수 있다.
	ㄴ 단 static 메서드와 디폴트 메서드는 예외 ( JDK 1.8 이상 )
모든 멤버에 예외없이 적용되기 때문에 제어자를 생략할 수 있으며, 생략 시 컴파일러가 컴파일 시에 추가해준다.

public interface InterfaceStudy {
    int value = 30;
    int key = 16;

    void print();
    void walk();
}

public interface AnotherInterface extends InterfaceStudy{
}

이때 인터페이스는 다중상속이 가능하다.
인터페이스를 상속받는 인터페이스는 extends 키워드를 통해 상속을 받는다. ( 인터페이스는 인터페이스로부터만 상속받을 수 있다. )

- 인터페이스의 구현
인터페이스는 해당 인터페이스를 구현하는 클래스에 대해 implements 키워드를 활용하여 상속을 한다.
public class InterfaceImplements extends Car implements InterfaceStudy {

    @Override
    public void print() {

    }

    @Override
    public void walk() {

    }
}

만약 인터페이스에 있는 추상 메서드 중 일부만 구현한다면 해당 클래스를 abstract 클래스로 선언해야 하며,
위의 예제와 같이 implements 와 extends 를 동시에 할 수 있다.

# extends는 확장 한다는 의미이며, implements 는 구현한다는 의미를 가지고 있다.

# 인터페이스의 이름은 able ( ~을 할 수 있는 ) 로 끝나는 경우가 많다, 그 이유는 특정 행위를 하는데 필요한 메서드를 제공한다는 의미를 강조하기 위해서이며,
# 해당 인터페이스를 구현할 경우 ~을 할 수 있는 능력을 갖추었다는 의미를 갖는다.
# ex ) public interface Fightable { void attack(); void walk(); }
# C++ 은 다중상속이 허용하기 때문에 자바에서는 다중상속이 안되는 단점으로 부각되는 것에 대응하기 위해서 인터페이스의 다중 상속을 허용한다.
# 하지만 자바에선 다중상속을 위해 인터페이스를 활용하진 않고 인터페이스를 통해 여러가지 능력을 갖추기 위해 다중 상속을 활용한다.

그리고 인터페이스도 다형성의 특성을 활용해 인터페이스 참조 변수에 해당 인터페이스의 구현체의 인스턴스를 참조할 수 있다.
// InterfaceStudy -> 인터페이스
// InterfaceImplements -> 구현체
InterfaceStudy is1 = new InterfaceImplements();

InterfaceStudy method(InterfaceStudy study) {
	return new InterfaceImplements();
}
위의 코드는 매개 변수와 반환 타입이 모두 인터페이스이다.
이것은 인자로 해당 인터페이스를 구현한 클래스의 인스턴스를 넘겨받아야 하며, 반환값으로는 해당 인터페이스를 구현한 클래스의 인스턴스를 반환한다는 뜻이다.

- 인터페이스의 장점
1. 개발 시간을 단축시킬 수 있다.
인터페이스는 메서드의 호출과 구현이 분리되어 있기 때문에 인터페이스가 모두 구현될 때 까지 기다릴 필요 없이 선언부를 이용해서 프로그램을 작성할 수 있다.

2. 표준화가 가능하다.
프로젝트에 사용되는 기본 틀인 인터페이스를 작성한 다음, 개발자들이 해당 인터페이스를 구현하게 함으로써 일관적인 프로그램을 작성할 수 있다.

3. 서로 관계없는 클래스들 간에 관계를 맺어줄 수 있다.
서로 상속 관계도 아니고, 조상 클래스도 다를 경우 하나의 인터페이스를 구현하게 함으로써 관계를 맺어줄 수 있다.
# 상속 관계를 바꾸기도 애매하고, 공통적인 사항이 없을 때 인터페이스를 구현해서 공통 관계를 만들어 줄 수 있다. ( 다형성을 이용해 매개변수로 이들을 받으려고 할 때 유용하다. )
# 단지 인스턴스의 타입 체크를 위해서 사용될 수 있으며, 그로 인해 구현체가 없는 ( 빈 몸통인 ) 인터페이스가 존재할 수 있다.
# 다만 몸통이 빈 인터페이스로 공통점을 만들어 매개변수로 받는다 하더라도, 해당 인터페이스에 멤버가 없기 때문에 사용할 수 없다. 따라서 instanceof 키워드를 사용해서 다른 클래스로 캐스팅해서 사용해야 한다.

4. 독립적인 프로그래밍이 가능하다.
인터페이스는 클래스의 선언과 구현을 나눌 수 있기 때문에 실제 구현에 독립적인 프로그램을 작성할 수 있다.
이는 클래스와 클래스의 직접적인 관계를 간접적인 관계로 변경하여, 한 클래스의 변경이 다른 클래스에 영향을 미치지 않게 한다.

# 예를 들면 Database 인터페이스를 만들고 이를 MySQL과 PostgreSQL 로 구현할 경우 PostGreSQL를 변경한다 하더라도 MySQL이 영향받지는 않는다.

만약 다형성을 위한 인터페이스를 사용하는데, 동일한 소스 코드를 공유해야 한다면 해당 인터페이스를 구현한 Impl 클래스를 포함관계로 해놓고 해당 Impl 클래스를 호출하면 된다.
예를 들어 아래와 같이 Liftable 인터페이스가 있고 이를 구현하는 코드가 같을 경우 Liftable 인터페이스를 구현한 LiftableImpl 클래스를 포함관계로 넣고,
Liftable 인터페이스를 구현하는 클래스가 이를 활용하게 하면, 공통의 코드를 LiftableImpl 에서 관리할 수 있게 된다.
class Barrack implements Liftable {
	LiftableImpl l = new LiftableImpl();
	
	@Override
	void liftOff() {
		l.liftOff();
	}
}

즉 인터페이스를 사용하면 다음과 같은 이점이 있다.
1. 클래스간에 간접적인 관계를 만들어주어, 한 클래스의 변경이 다른 클래스에 영향을 주지 못하게 한다.
	ㄴ 만약 한 클래스가 다른 클래스를 직접적으로 참조한다면, 한 클래스의 변경 시 다른 클래스 역시 변경해주어야 한다.
2. 매개변수로 해당 인터페이스를 구현한 클래스의 인스턴스를 받을 수 있다. ( 다형성 )
	ㄴ 만약 상속 관계가 전혀 없을 경우 인터페이스를 통해 공통 관계를 맺어줄 수 있다.

[ 디폴트 메서드와 static 메서드 ]
원래 인터페이스에는 추상 메서드만 선언할 수 있었는데 JDK1.8 부터는 디폴트 메서드와 static 메서드를 선언할 수 있게 되었다.

static 메서드는 다른 클래스처럼 클래스가 메모리에 로드될 때 사용할 수 있으며 인터페이스.메서드명 을 활용해서 호출할 수 있다.

디폴트 메서드는 추상 메서드의 기본적인 구현을 제공하는 메서드로, 추상 메서드가 아니기 때문에 몸통 {} 을 가지고 있어야 하며,
인터페이스에 추가되었다 하더라도, 이를 구현하는 클래스에 추가하지 않아도 된다.
	ㄴ 기존 인터페이스에 추상 메서드가 추가될 시 이를 구현하는 모든 클래스는 추가된 추상 메서드를 구현해주어야 한다.
	ㄴ 즉 조상 클래스의 하나의 클래스가 생기는 것 보다, 인터페이스에 하나의 추상 클래스가 추가되는 것은 사고다.
	
다만 디폴트 메서드도 기존의 메서드와 충돌할 가능성이 있는데, 이 충돌을 해결하기 위한 규칙이 있다.
1. 여러 인터페이스의 디폴트 메서드가 충돌할 경우 인터페이스를 구현하는 클래스에서 디폴트 메서드를 오버라이딩해야한다.
2. 인터페이스의 디폴트 메서드와 조상 클래스가 충돌할 경우, 디폴트 메서드는 무시되고 조상 메서드가 상속된다.


[ 내부 클래스 ]
내부 클래스 ( inner Class ) 는 클래스 내에 선언된 클래스를 말한다.
이렇게 클래스 안에 클래스를 선언하는 이유는 두 클래스가 서로 긴밀한 관계에 있기 때문이다.

# 내부 클래스는 보통 GUI어플리케이션의 이벤트 처리 외에는 잘 사용되지 않는다.

내부 클래스를 사용하면 다음과 같은 장점이 있다.
1. 두 클래스의 멤버들 간에 쉽게 접근할 수 있다.
2. 불필요한 클래스를 감춤으로써 복잡성을 줄일 수 있다. ( 캡슐화 )

Class B {
	Class A {
	
	}
}
위와 같이 사용되며 B클래스는 외부 클래스 , A 클래스는 내부 클래스라고 불린다.

- 내부 클래스의 종류
내부 클래스의 종류는 변수와 같이 선언되는 위치에 따라 종류가 나뉜다.
1. 인스턴스 클래스 : 외부 클래스의 멤버변수 선언위치에 선언되며, 외부 클래스의 인스턴스 멤버처럼 사용된다.
2. 스태틱 클래스 : 외부 클래스의 멤버 변수 선언 위치에 선언된다.
3. 지역 클래스 : 외부 클래스의 메서드나 초기화 블럭 안에 사용된다.

- 내부 클래스의 제어자와 접근성

내부 클래스는 외부 클래스의 멤버 변수의 선언 위치가 동일하다.
또한 내부 클래스는 외부 클래스의 멤버와 같이 사용되며, 인스턴스 멤버와 static 멤버와 같은 규칙이 적용된다.
그리고 내부 클래스는 클래스이기 때문에 abstract와 final 등 제어자를 사용할 수 있으며, 멤버 변수들처럼 접근 제어자도 사용할 수 있다.

내부 클래스 중에서 static 클래스만 static 멤버를 가질 수 있다.
단 final과 static이 붙은 변수는 상수이므로 모든 내부 클래스에서 정의가 가능하다.

그리고 인스턴스 클래스는 외부 클래스의 인스턴스 멤버와 스태틱 클래스의 멤버에 직접 접근할 수 있지만, 스태틱 클래스는 외부 클래스나 인스턴스 클래스를 객체 생성 후 접근해야 한다.
	ㄴ 이것은 마치 인스턴스 멤버가 클래스 멤버에 접근하기 위해 객체 생성하는 것 처럼 동일하다.
	ㄴ 즉 인스턴스 클래스는 인스턴스 멤버의 선언 위치가 규칙이 동일하다.
	
여기서 지역 클래스 ( 메서드 내의 클래스 ) 는 final이 붙은 지역 변수만 접근할 수 있다.
그 이유는 메서드가 종료되어 지역 변수가 소멸되었을 때, 지역 클래스의 인스턴스가 소멸된 지역 변수를 참조할 수 있기 때문이다.

JDK1.8 부터는 지역 클래스에서 접근하려는 지역 변수 앞에 final을 붙여준다. 이는 편의상 생략하면 컴파일러가 final을 붙여주는 것이기 때문에 해당 지역 변수를 수정하려 할 경우 컴파일 오류가 발생한다.

외부 클래스가 아닌 클래스에서 내부 클래스를 선언하고 내부 클래스의 멤버에 접근하기 위해서는 먼저 외부 클래스의 인스턴스를 생성하고, 내부 클래스를 생성해야 한다.
다만 이러한 경우가 발생했다는 것은 내부 클래스로 선언해서는 안되는 경우이다. 분리하도록 하자.
# static 내부 클래스는 외부 클래스 없이 바로 인스턴스를 생성할 수 있다.
Outer oc = new Outer(); // 외부 클래스 인스턴스 생성
Outer.Inner in = oc.new Inner(); // 내부 클래스의 인스턴스 생성

Outer.Static os = new Outer.Static(); // static 클래스의 경우 바로 생성할 수 있다.

내부 클래스를 컴파일 하면 다음과 같은 class 파일이 생성된다.
Outer.class
Outer$Inner.class
Outer$Static.class
Outer$1LocalInner.class

컴파일 시 '외부 클래스명$내부 클래스명.class' 형식으로 클래스 파일이 생성된다.
다만 지역 내부 클래스는 서로 다른 메서드들 간에 동일한 클래스 이름이 존재할 수 있기 때문에 지역 내부 클래스는 앞에 숫자가 붙는다. ( LocalInner )

class Outer {

	int outerIv = 50;
	
	class Inner {
		int outerIv = 25;
	}
	
	void method1() {
		int outerIv = 12;
		class LocalInner {
		 // 해당 지역 내부 클래스는 다른 메서드에서 중복되는 이름이 발생할 수 있다.
		 
		}
	}
}

그리고 위의 코드와 같이 외부 클래스와 내부 클래스의 변수 명이 같을 경우 this 와 Outer.this 를 활용해서 서로 구별할 수 있다.

void method1() {
	outerIv <- method1 메서드에 있는 변수
	this.outerIv <- Inner 내부 클래스에 있는 변수
	Outer.this.outerIv <- 외부 클래스에 있는 변수 ( 외부클래스.class )
}