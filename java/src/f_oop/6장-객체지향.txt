객체지향이론은 "실제 세계는 사물(객체) 로 이루어져 있고, 발생하는 모든 사건은 사물간의 상호작용이다." 라는 기본 개념을 가지고 있다.
실제 사물의 속성과 기능을 분석하고, 데이터와 메서드로 정의 함으로 써, 현실 세계에 있는 사물을 컴퓨터로 표현하고자 했다.
객체지향이론은 상속, 캡슐화, 추상화의 개념을 중심으로 점차 구체적으로 발전시켰으며, 1960년대에 시뮬라 라는 첫 객체지향언어가 등장했다.

객체지향언어는 절차지향언어와 전혀 다른 것이 아닌, 절차지향언어에서 몇가지 규칙이 추가된 것이다.
객체지향언어가 절차지향언어보다 장점인 부분은 다음과 같다.
	1. 코드의 재사용성이 높고, 유지보수가 용이하다.
	- 기존의 코드를 재활용하기 용이하다.
	2. 코드의 관리가 용이하다.
	- 코드간의 관계를 이용하여, 쉽게 코드를 변경할 수 있다.
	3. 신뢰성이 높은 프로그램이 가능하다.
	- 제어자와 메서드를 통해 데이터를 보호하고, 코드의 중복을 제거하여 코드 불일치로 발생하는 오류를 예방할 수 있다.
	
# 클래스와 객체
클래스는 객체의 설계도이며 객체를 생성하는데 사용된다.
객체는 실제로 존재하는 것이며 사물 또는 개념이 될 수 있다.
	ㄴ 자동차, 의자와 같은 유형적인 것 뿐만이 아니라, 수학 공식과 같은 무형적인 개념도 객체가 될 수 있다.

쉽게 설명하면 TV설계도 ( 클래스 ) 를 활용하여 TV ( 객체 ) 를 만드는 것을 말한다.
이때 TV설계도( 클래스 ) 는 TV ( 객체 ) 에 대한 정의이다.

즉, 객체지향이론에서의 클래스는 "객체를 만들기 위한 틀이며, 속성과 기능으로 정의되어 있다." 고 볼 수 있다.

데이터 저장 개념의 발전 과정은 다음과 같다.
	ㄴ 1. 변수 : 하나의 데이터를 저장하는 공간
	ㄴ 2. 배열 : 같은 타입의 여러 변수를 저장하는 공간
	ㄴ 3. 구조체 : 서로 다른 타입이지만 연관된 여러 변수를 가지는 공간
	ㄴ 4. 클래스 : 서로 다른 타입의 변수와 함수를 가지는 공간
과거 절차 지향언어에는 변수와 함수는 서로 각각 관리가 되었지만, 객체지향언어에서는 변수와 함수가 서로 관계가 깊을 경우 이들을 묶어 하나의 클래스로 다룬다.
	ㄴ 그에 대한 예시로 String 클래스는 char[] ( 문자열 변수 ) 을 가지고 있으며, 문자열과 관련된 작업의 함수들을 하나로 묶여져 있다.
	ㄴ 즉, 서로 관련이 있는 변수들을 정의하고, 이들에 대한 작업을 수행하는 함수를 하나로 묶은 것이 클래스이다.

프로그래밍에서 객체란 클래스에서 정의된 대로 메모리에 생성된 것을 말한다.



# 객체와 인스턴스
클래스로부터 객체를 만드는 과정을 클래스의 인스턴스화 ( instantiate ) 라고 한다.
어떤 클래스로부터 만들어진 객체는, 해당 클래스의 인스턴스 라고 한다.

사실 인스턴스와 객체는 같은 의미이지만, 객체는 모든 인스턴스를 포함하는 포괄적인 의미를 가지고 있고,
인스턴스는 어떤 클래스의 객체인지를 구제척으로 강조하는 의미를 가지고 있다.
하지만 결국 인스턴스와 객체는 같은 의미이지만, 작은 차이가 있다. 꼭 구분해서 사용하진 않아도 되지만 문법상 자연스러운 표현을 하면 좋다.
	ㄴ A는 인스턴스다. 보단 A는 객체다.
	ㄴ A는 B의 객체다 보단 A는 B의 인스턴스다. 

코드를 작성할 때, 실제 사용되는 것은 클래스가 아닌 객체다.
따라서 클래스를 만들고, 해당 클래스의 인스턴스를 생성하여 활용해야 한다.

# 객체의 구성요소
객체는 속성과 기능으로 구분되어 있으며, 한 객체에는 여러 개의 기능과 속성을 가지고 있다.
또한 객체가 가지고 있는 속성과 기능은 그 객체의 멤버라고 한다.

객체가 가지고 있는 속성과 기능은 클래스에서도 모두 정의되어 있다.
즉, 객체를 생성되면, 해당 객체의 클래스가 정의한 속성과 기능을 객체가 모두 갖는다.

보통 프로그래밍할 때 속성과 기능을 다른 이름으로 부른다.
	ㄴ 속성 : 멤버변수 , 변수
	ㄴ 기능 : 메서드
	
# 인스턴스의 생성과 활용
Class a = new Class();
	ㄴ 클래스로 부터 인스턴스를 생성하는 방법은 new 연산자를 활용해서 생성한다. ( new 연산자로 인해 메모리의 빈 공간에 인스턴스가 생성된다. )
	ㄴ 이때 Class a 는 인스턴스의 참조 변수가 되며, 대입 연산자로 인해 인스턴스(객체)의 주소 값을 가지게 된다. ( 참조 변수는 인스턴스를 참조하게 된다. )
	ㄴ 물론 참조 값이기 때문에 기본 값은 null 이다.

위와 같이 선언 및 생성을 하면 참조 변수 a 를 통해 인스턴스로 접근할 수 있다.

이때 생성된 인스턴스의 속성에 접근하려면 다음과 같이 한다.
참조변수.멤버변수 = 5;
	ㄴ ex ) a.index = 10;
비슷하게 속성 ( 메서드 ) 에 접근하려면 다음과 같이 한다.
참조변수.메서드명()
	ㄴ ex ) a.method();
	
위와 같이 인스턴스의 멤버 변수와 메서드에 접근하려면 참조 변수를 통해서 접근해야 한다.
그리고 참조 변수의 타입은 인스턴스의 타입과 일치해야 한다.

Class a = new Class();
Class b = new Class();
a와 b는 같은 Class 로 부터 생성된 인스턴스라고 할지라도, 독립된 저장공간을 가지고 있다.
	ㄴ 즉 a의 값을 바꾼다고 해도 b의 값은 변하지 않는다.

만약 a = b; 와 같이 b에 저장 된 인스턴스 주소값을 a 와 함께 공유하게 된다면 a 클래스 내 값을 변경할 시 b의 값도 바뀌게 된다.
	ㄴ 물론 기존 a가 참조하고 있던 인스턴스는 더이상 사용할 수 없으므로, 가비지 컬렉터에 의해 제거된다.
	
# 객체 배열
객체도 배열로 다룰 수 있다. 객체 배열의 각각의 요소들은 객체에 대한 주소값을 가지게 된다.

Tv[] tvArr = new Tv[3];
위와 같이 Tv 클래스에 대한 객체 배열을 생성할 수 있다. 객체 주소를 저장할 수 있는 3개의 공간이 생성되며
참조 변수의 기본 값인 null로 초기화 된다.
- 이때 tvArr의 현재 상태는 객체를 다루기 위한 참조 변수들이 만들어진 것일뿐, 실제 객체를 생성해주어야 한다.
	ㄴ 즉 tvArr[0] = new Tv(); 와 같이 각각의 참조 변수들에 대해 객체의 주소를 넘겨주어야 한다.
	
물론 객체 배열 역시 초기화를 간단하게 할 수 있다.
Tv[] tvArr = {new Tv() , new Tv() , new Tv()};
물론 객체 배열에는 같은 타입의 객체만 저장할 수 있다.
	ㄴ 물론 나중에 나올 "다형성" 을 활용하여 하나의 배열에 여러 종류의 객체를 다룰 수 있다.
	
# 사용자 정의 타입 ( user-defined type )
프로그래밍언어에서 제공하는 자료형 ( primitive type ) 외에 프로그래머가 필요에 따라 타입을 새로 추가하는 것을 사용자 정의 타입이라고 한다.
다른 프로그래밍 언어에서도 사용자 정의 타입을 정의하는 방법을 제공하고 있으며, 자바와 같은 객체지향언어에서는 클래스가 곧 사용자 정의 타입이 된다.

Java 에서는 기본 형은 8개로 정해져 있지만, 참조형의 갯수는 정해져 있지 않은 이유는 사용자 정의 타입 때문이다.
	ㄴ 즉 프로그래머가 필요에 따라 새로운 타입을 계속 추가할 수 있다.