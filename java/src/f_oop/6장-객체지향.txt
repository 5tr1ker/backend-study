객체지향이론은 "실제 세계는 사물(객체) 로 이루어져 있고, 발생하는 모든 사건은 사물간의 상호작용이다." 라는 기본 개념을 가지고 있다.
실제 사물의 속성과 기능을 분석하고, 데이터와 메서드로 정의 함으로 써, 현실 세계에 있는 사물을 컴퓨터로 표현하고자 했다.
객체지향이론은 상속, 캡슐화, 추상화의 개념을 중심으로 점차 구체적으로 발전시켰으며, 1960년대에 시뮬라 라는 첫 객체지향언어가 등장했다.

객체지향언어는 절차지향언어와 전혀 다른 것이 아닌, 절차지향언어에서 몇가지 규칙이 추가된 것이다.
객체지향언어가 절차지향언어보다 장점인 부분은 다음과 같다.
	1. 코드의 재사용성이 높고, 유지보수가 용이하다.
	- 기존의 코드를 재활용하기 용이하다.
	2. 코드의 관리가 용이하다.
	- 코드간의 관계를 이용하여, 쉽게 코드를 변경할 수 있다.
	3. 신뢰성이 높은 프로그램이 가능하다.
	- 제어자와 메서드를 통해 데이터를 보호하고, 코드의 중복을 제거하여 코드 불일치로 발생하는 오류를 예방할 수 있다.
	
# 클래스와 객체
클래스는 객체의 설계도이며 객체를 생성하는데 사용된다.
객체는 실제로 존재하는 것이며 사물 또는 개념이 될 수 있다.
	ㄴ 자동차, 의자와 같은 유형적인 것 뿐만이 아니라, 수학 공식과 같은 무형적인 개념도 객체가 될 수 있다.

쉽게 설명하면 TV설계도 ( 클래스 ) 를 활용하여 TV ( 객체 ) 를 만드는 것을 말한다.
이때 TV설계도( 클래스 ) 는 TV ( 객체 ) 에 대한 정의이다.

즉, 객체지향이론에서의 클래스는 "객체를 만들기 위한 틀이며, 속성과 기능으로 정의되어 있다." 고 볼 수 있다.

데이터 저장 개념의 발전 과정은 다음과 같다.
	ㄴ 1. 변수 : 하나의 데이터를 저장하는 공간
	ㄴ 2. 배열 : 같은 타입의 여러 변수를 저장하는 공간
	ㄴ 3. 구조체 : 서로 다른 타입이지만 연관된 여러 변수를 가지는 공간
	ㄴ 4. 클래스 : 서로 다른 타입의 변수와 함수를 가지는 공간
과거 절차 지향언어에는 변수와 함수는 서로 각각 관리가 되었지만, 객체지향언어에서는 변수와 함수가 서로 관계가 깊을 경우 이들을 묶어 하나의 클래스로 다룬다.
	ㄴ 그에 대한 예시로 String 클래스는 char[] ( 문자열 변수 ) 을 가지고 있으며, 문자열과 관련된 작업의 함수들을 하나로 묶여져 있다.
	ㄴ 즉, 서로 관련이 있는 변수들을 정의하고, 이들에 대한 작업을 수행하는 함수를 하나로 묶은 것이 클래스이다.

프로그래밍에서 객체란 클래스에서 정의된 대로 메모리에 생성된 것을 말한다.



# 객체와 인스턴스
클래스로부터 객체를 만드는 과정을 클래스의 인스턴스화 ( instantiate ) 라고 한다.
어떤 클래스로부터 만들어진 객체는, 해당 클래스의 인스턴스 라고 한다.

사실 인스턴스와 객체는 같은 의미이지만, 객체는 모든 인스턴스를 포함하는 포괄적인 의미를 가지고 있고,
인스턴스는 어떤 클래스의 객체인지를 구제척으로 강조하는 의미를 가지고 있다.
하지만 결국 인스턴스와 객체는 같은 의미이지만, 작은 차이가 있다. 꼭 구분해서 사용하진 않아도 되지만 문법상 자연스러운 표현을 하면 좋다.
	ㄴ A는 인스턴스다. 보단 A는 객체다.
	ㄴ A는 B의 객체다 보단 A는 B의 인스턴스다. 

코드를 작성할 때, 실제 사용되는 것은 클래스가 아닌 객체다.
따라서 클래스를 만들고, 해당 클래스의 인스턴스를 생성하여 활용해야 한다.

# 객체의 구성요소
객체는 속성과 기능으로 구분되어 있으며, 한 객체에는 여러 개의 기능과 속성을 가지고 있다.
또한 객체가 가지고 있는 속성과 기능은 그 객체의 멤버라고 한다.

객체가 가지고 있는 속성과 기능은 클래스에서도 모두 정의되어 있다.
즉, 객체를 생성되면, 해당 객체의 클래스가 정의한 속성과 기능을 객체가 모두 갖는다.

보통 프로그래밍할 때 속성과 기능을 다른 이름으로 부른다.
	ㄴ 속성 : 멤버변수 , 변수
	ㄴ 기능 : 메서드
	
# 인스턴스의 생성과 활용
Class a = new Class();
	ㄴ 클래스로 부터 인스턴스를 생성하는 방법은 new 연산자를 활용해서 생성한다. ( new 연산자로 인해 메모리의 빈 공간에 인스턴스가 생성된다. )
	ㄴ 이때 Class a 는 인스턴스의 참조 변수가 되며, 대입 연산자로 인해 인스턴스(객체)의 주소 값을 가지게 된다. ( 참조 변수는 인스턴스를 참조하게 된다. )
	ㄴ 물론 참조 값이기 때문에 기본 값은 null 이다.

위와 같이 선언 및 생성을 하면 참조 변수 a 를 통해 인스턴스로 접근할 수 있다.

이때 생성된 인스턴스의 속성에 접근하려면 다음과 같이 한다.
참조변수.멤버변수 = 5;
	ㄴ ex ) a.index = 10;
비슷하게 속성 ( 메서드 ) 에 접근하려면 다음과 같이 한다.
참조변수.메서드명()
	ㄴ ex ) a.method();
	
위와 같이 인스턴스의 멤버 변수와 메서드에 접근하려면 참조 변수를 통해서 접근해야 한다.
그리고 참조 변수의 타입은 인스턴스의 타입과 일치해야 한다.

Class a = new Class();
Class b = new Class();
a와 b는 같은 Class 로 부터 생성된 인스턴스라고 할지라도, 독립된 저장공간을 가지고 있다.
	ㄴ 즉 a의 값을 바꾼다고 해도 b의 값은 변하지 않는다.

만약 a = b; 와 같이 b에 저장 된 인스턴스 주소값을 a 와 함께 공유하게 된다면 a 클래스 내 값을 변경할 시 b의 값도 바뀌게 된다.
	ㄴ 물론 기존 a가 참조하고 있던 인스턴스는 더이상 사용할 수 없으므로, 가비지 컬렉터에 의해 제거된다.
	
# 객체 배열
객체도 배열로 다룰 수 있다. 객체 배열의 각각의 요소들은 객체에 대한 주소값을 가지게 된다.

Tv[] tvArr = new Tv[3];
위와 같이 Tv 클래스에 대한 객체 배열을 생성할 수 있다. 객체 주소를 저장할 수 있는 3개의 공간이 생성되며
참조 변수의 기본 값인 null로 초기화 된다.
- 이때 tvArr의 현재 상태는 객체를 다루기 위한 참조 변수들이 만들어진 것일뿐, 실제 객체를 생성해주어야 한다.
	ㄴ 즉 tvArr[0] = new Tv(); 와 같이 각각의 참조 변수들에 대해 객체의 주소를 넘겨주어야 한다.
	
물론 객체 배열 역시 초기화를 간단하게 할 수 있다.
Tv[] tvArr = {new Tv() , new Tv() , new Tv()};
물론 객체 배열에는 같은 타입의 객체만 저장할 수 있다.
	ㄴ 물론 나중에 나올 "다형성" 을 활용하여 하나의 배열에 여러 종류의 객체를 다룰 수 있다.
	
# 사용자 정의 타입 ( user-defined type )
프로그래밍언어에서 제공하는 자료형 ( primitive type ) 외에 프로그래머가 필요에 따라 타입을 새로 추가하는 것을 사용자 정의 타입이라고 한다.
다른 프로그래밍 언어에서도 사용자 정의 타입을 정의하는 방법을 제공하고 있으며, 자바와 같은 객체지향언어에서는 클래스가 곧 사용자 정의 타입이 된다.

Java 에서는 기본 형은 8개로 정해져 있지만, 참조형의 갯수는 정해져 있지 않은 이유는 사용자 정의 타입 때문이다.
	ㄴ 즉 프로그래머가 필요에 따라 새로운 타입을 계속 추가할 수 있다.
	
[ 변수와 메서드 ]

변수의 종류로는 클래스 변수, 인스턴스 변수, 지역 변수 3가지로 나뉜다. 변수는 선언된 위치에 따라 종류를 결정짓는다.
	ㄴ 멤버 변수를 제외한 변수를 지역 변수
	ㄴ 멤버 변수들 중 static 키워드가 붙은 것은 클래스 변수, 안붙으면 인스턴스 변수
	
class clazz {
	int a; // 멤버 변수 - 인스턴스 변수
	static int b; // 멤버 변수 - 클래스 변수
	
	public void method() {
		int c; // 지역 변수
	}
}

a와 b는 클래스 영역에 선언되어 있으므로 멤버 변수
그 중 b는 static 키워드로 선언되어 있으므로 클래스 변수
c는 메서드 영역에 선언되어 있으므로 지역 변수

1. 인스턴스 변수
클래스 내부에 선언되며, 클래스의 인스턴스가 생성될 때 사용할 수 있다.
독립적인 저장 공간을 가지고 있어, 각각의 인스턴스는 다른 값을 가질 수 있다.

2. 클래스 변수
클래스 변수는 인스턴스 변수 앞에 static 키워드를 붙여주면 생성된다.
클래스 변수는 모든 인스턴스들이 공통된 저장 공간을 공유한다.
클래스 변수는 인스턴스를 생성하지 않아도 사용할 수 있으며 "클래스이름.클래스변수" 로 접근할 수 있다.
클래스 변수는 클래스가 메모리에 로딩될 때 사용가능 하며, 프로그램이 종료될 떄 까지 사용할 수 있다.
만일 클래스 변수 앞에 public 접근자를 붙이면 프로그램 어디서든 접근할 수 있다.

클래스 변수의 경우 인스턴스.클래스변수 로 접근할 수 있는데, 클래스이름.클래스변수로 접근하는 것이 좋다. ( 가독성 때문 )
클래스 변수는 메모리 공간을 공유하고 있기 때문에 a 인스턴스가 변경할 경우에도 b 인스턴스 나 다른 인스턴스의 값도 함께 변경된다.

3. 지역 변수
지역 변수는 메서드 내부에 선언된 변수로, 메서드가 종료되면 소멸되어 사용할 수 없게 된다.
{} 블록 내부에 선언된 지역 변수는 {} 블록 내부에서만 사용할 수 있으며, {} 블록을 벗어나면 더이상 사용할 수 없다.

# 메서드
메서드는 특정 작업을 수행하는 문장들을 하나로 묶은 것을 말한다.
기본적으로 수학의 함수와 비슷하여, 특정 값을 넣으면 원하는 값을 얻을 수 있다.
	ㄴ 수학의 함수와는 다른점이 입력 값과 출력 값이 없을 수 있다.
	
메서드를 사용하는 이유

1. 높은 재 사용성
메서드는 한번 만들어 놓으면 다시 사용가능하며, 다른 프로그램에서도 사용할 수 있다.

2. 중복된 코드 제거
코드를 작성할 때, 같은 내용이 반복되는 부분을 하나의 메서드로 묶어서 관리하면, 
코드의 중복이 사라지게 되고, 이에 따라 코드의 길이가 짧아지게 된다.
만약 중복된 코드가 있을 경우 코드를 수정할 때 일이 많아지고 오류가 발생할 확률이 높아진다.

3. 프로그램의 구조화
소스의 코드가 커질 때, 하나의 메서드에 모두 작성할 경우 관리하기가 힘들어 질 것이다.
이에 작업의 단위에 따라 메서드로 나누어 관리하고, main에서 호출하면 한눈에 보기 쉽고 관리하기가 편할 것이다.
	ㄴ 예를 들어, 성적 처리 프로그램일 경우 showMenu() , inputRecord() , changeRecord() 처럼 메서드를 나눠 관리하는 것이다.
만약 구조화 하기 어렵다면 처음에 작업의 단위로 나눈 빈 메서드를 선언하고 나중에 소스 코드를 채워가는 것도 하나의 방법이다.
ex )
static int showMenu() { // 빈 메서드.. }
static void inputRecord() { // 빈 메서드.. }
...

# 메서드의 선언과 구현

메서드는 크게 '선언부' 와 '구현부'로 이루어져 있다.
선언부에는 메서드의 이름과 매개변수 선언, 반환 타입으로 구성되어 있고, 구현부에는 메서드가 수행할 작업들을 작성하는 공간이다.
만약 메서드를 구현한다고 하면 이러한 선언부와 구현부를 구현한다고 이해하면 된다.

메서드의 선언부는 나중에 해당 메서드를 호출할 때 활용된다.

- 매개변수 선언
매개변수는 메서드가 작업을 수행할 때, 필요로 하는 변수를 받기 위한 것이며, 0개 이상의 변수를 받을 수 있다.
변수 간에는 쉼표로 구분하며, 참조 변수도 받을 수 있다.
매개 변수도 메서드 내에서 선언된 것으로 간주되어 '지역 변수' 에 해당한다.

- 메서드 이름
선언된 메서드를 호출할 때 사용되며, 메서드의 이름은 보통 동사로 표현된다. ex ) addEntity()

- 반환 타입
메서드의 작업 결과인 '반환 값' 의 변수 타입을 지정한다.
만약 반환 값이 없다면 void 를 지정한다.

만약 반환 타입이 있을 경우 메서드의 구현부 안에 "return 반환값;" 이 반드시 포함해야 한다.
이 반환 값은 반환 타입과 일치하거나, 자동 형 변환이 가능해야 하며, return 문은 최대 1개 까지만 허용한다.
"return 반환값;" 해당 문장을 만나면 반환 값을 호출한 메서드로 반환된다.

예를 들면 int add(int a, int b) return a + b; 라는 메서드가 있을 때,
int result = add(3,5); 라는 문장을 수행하면 add 메서드는 8을 반환하게 된다.
그렇게 되면 int result = 8; 이라는 문장이 되어, result에 8이 저장되게 된다.
물론 result 변수는 반환 타입과 일치하거나, 자동 형 변환이 가능한 타입이여야 한다.

- 메서드 구현부
메서드 선언부 이후에 나오는 {} 괄호에 해당하며, 메서드가 호출되었을 때 수행될 작업을 정리하는 부분이다.

- 지역 변수
메서드 내부에 선언된 변수는 해당 메서드에서만 사용할 수 있는 지역 변수이다.
만약 서로 다른 메서드라면 같은 이름의 메서드를 사용할 수 있으며, 매개 변수도 지역 변수에 해당된다.

- 메서드 호출
메서드를 선언 및 구현하고 호출하지 않으면 아무 일도 일어나지 않는다.
메서드를 호출해야 메서드 구현부에 작성된 문장이 실행된다.
메서드를 실행시키는 방법은 다음과 같다.
	ㄴ addEntity(); // 반환 값과 매개 변수가 없는 메서드
	ㄴ int result = add(1 , 3); // 반환 값과 매개 변수가 있는 메서드
	
메서드를 호출할 때 () 괄호 안에 지정된 값들을 인자(argument) 또는 인수라고 한다.
인자의 갯수와 타입은, 호출된 메서드의 매개 변수 타입과 갯수가 일치해야 한다.
	ㄴ 이때 매개 변수 타입에 일치하거나 자동 형 변환이 되어야 한다.
메서드 호출 시 전달된 인자는 순서대로 호출된 메서드의 매개 변수에 차례대로 들어가게 된다.

만약 매개 변수의 타입이나 갯수가 다를경우 컴파일러가 경고를 발생시킨다.
그리고 반환 값의 경우 보통 변수에 저장하지만, 변수에 저장하지 않아도 된다.

만약 다른 클래스의 메서드를 호출하기 위해선, 해당 클래스를 선언 및 생성한 다음 참조 변수를 통해서 접근해야 한다.
Class cz = new Class(); // 참조 변수 생성
cz.method(); // 참조 변수를 통해서 메서드 접근

- 메서드 간 접근
같은 클래스 안에 있는 메서드는 참조 변수 없이 서로 호출이 가능하지만,
static 메서드는 인스턴스 메서드에 접근할 수 없다.

- return 문
메서드 안에서 return 문을 만나면, 현재 실행중인 메서드를 종료하고, 메서드가 호출된 부분으로 되돌아간다.
모든 메서드는 return 문이 하나 이상 존재해야 한다. 이때 반환 타입의 void 인 메서드는 return 문이 없어도 잘 작동했는데, 
이는 컴파일러가 메서드의 마지막에 return 문을 자동으로 추가해 주었기 때문이다.

이때 반환 값이 있는 ( void 가 아닌 ) 경우엔 return 문을 명시적으로 달아줘야 한다.
만약 return 문이 누락되었을 경우 missing return statement 오류가 발생한다.

또 if문 안에 return 문을 명시했다 하더라도 return 문이 없다는 오류가 발생할 수 있다.
그 이유는 조건식에 따라 return 문이 실행되지 않을 수 있기 때문이다.
ex )
int max(int a, int b) {
	if(a>b) {
		return a;
	}
}
위의 코드는 return 문이 없다는 오류가 발생한다. 이 오류를 해결하기 위해 메서드 마지막에 return을 추가하거나 else 문에 return 문을 추가해주어야 한다.
ex ) 
int max(int a, int b) {
	if(a>b) {
		return a;
	} else {
		return b;
	}
}

반환 값에는 항상 변수가 오는 것이 아니라 수식이 올 수 있다.
ex )
return a + b;
이때 수식이 반환되는 것이 아니라, 연산 결과가 반환된다.
물론 수식이 아닌 메서드가 올 수 있다.
return add(a , b);
이 코드 역시 메서드를 반환하는 것이 아니라 add() 의 수행 결과를 반환한다.
주의할 점은 add() 메서드의 반환 타입은 return 문을 가지고 있는 메서드의 반환 타입과 일치해야 한다.

[ JVM 의 메모리 구조 ]
응용 프로그램이 실행하면 JVM은 프로그램을 실행시키기 위한 메모리를 시스템에게 할당 받은 후, 여러 영역으로 나누어 관리한다. 
이때 메서드 영역, 힙 영역, 호출 스택 영역으로 나눈다.

- 메서드 영역
프로그램 실행 중 특정 클래스가 사용되면, JVM은 해당 클래스의 .class 파일을 읽고 분석하고, 해당 클래스의 대한 정보를 해당 메모리 영역에 저장한다. 
이때 클래스 변수도 함께 저장된다.

- 힙
인스턴스 변수들이 저장되는 공간이다.
프로그램 실행 중에 생성되는 모든 인스턴스는 해당 영역에 생성 및 관리된다.

- 호출스택 ( call stack )
메서드의 작업을 위한 메모리 공간을 제공한다.
메서드가 호출되면 호출 스택에 해당 메서드를 위한 공간이 생성되며, 해당 메모리에는 메서드의 지역 변수가 저장이 되며, 메서드가 종료되면 메모리를 반환하고 사라진다.
이때 호출 스택에는 호출된 메서드를 위한 메모리 공간이 스택처럼 쌓이게 된다.
즉, 실행중인 메서드가 다른 메서드를 호출하면 그 위에 하나의 메모리 공간 스택이 더 쌓인다.

호출 스택에 들어있는 메서드 저장 공간이 2개 이상일 때, 가장 상단에 있는 메서드가 실행 중이고 나머지 메모리 공간은 대기 상태에 있다. ( 즉, 호출 스택에 여러 개의 메서드 저장 공간이 있다 하더라도 1개만 실행된다 )
만약 반환 값이 있는 메서드일 경우, 반환 값을 호출자 ( caller ) 에게 넘겨준다.

호출 스택은 처음 main 메서드가 제일 하단에 위치하게 된다.