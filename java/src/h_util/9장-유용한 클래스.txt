[ java.lang 패키지 ]
java.lang 패키지는 자바프로그래밍을 하는데 필수적인 클래스들을 제공한다.
그렇기 때문에 해당 패키지는 import 문 없이도 사용할 수 있다. 가장 대표적인 String 클래스나 System 클래스도 import문 없이 사용했다.

- Object 클래스
Object 클래스는 모든 클래스의 최고 조상이며, 멤버 변수 없이 메서드만 총 13개를 가지고 있다.
이 메서드들은 보통 필요에 따라 해당 클래스에 맞게 오버라이딩해서 사용한다.

1. boolean equals(Object obj)
해당 메서드는 두 인스턴스가 같은지 비교하여 반환하는 메서드이다.
Object 클래스에서는 매개변수로 넘어온 참조 변수의 주소와, 해당 인스턴스의 주소 값을 비교하여 같으면 true, 다르면 false를 반환하게 되어있다.
즉 두 인스턴스가 같아야 true가 된다.

2. int hashCode()
해당 메서드는 인스턴스의 해시 코드를 반환한다. ( 해시 기법중에서 해시함수를 구현한 것이다 )
기본적으로는 인스턴스의 주소 값을 활용하여 해시 코드를 반환한다.
따라서 같은 인스턴스일 경우엔 다른 해시 코드를 반환 받게 된다.
# 해당 메서드는 HashMap 이나 HashSet 클래스를 활용할 때, 반드시 오버라이딩 해야 한다.

3. String toString()
해당 인스턴스에 대한 정보를 문자열로 반환한다. 
기본적으로 클래스의 이름 @ 해시코드 의 값이 반환된다.

4. protected Object clone()
현재 인스턴스의 멤버를 복제한 새로운 인스턴스를 생성한다.
기본적으로 기본 자료형 같은 경우에는 값이 복사가 되지만, 참조 변수 같은 경우엔 주소가 복사되기 때문에
복제 배열의 값 수정 시, 진짜 배열의 값도 수정된다.
# 만약 참조 변수도 복사하고 싶다면 오버라이딩을 통해 로직을 수정해야 한다.

또한 오버라이딩 시 public으로 설정해야 하며, Cloneable 인스터페이스를 구현해야 한다.
만약 Cloneable 인터페이스를 구현하지 않는 클래스에서 clone() 실행 시 예외가 발생한다.
# Cloneable 인터페이스를 구현한 클래스만 clone()를 사용할 수 있는 이유는 내부 데이터를 보호하기 위해서이다.
# 즉 해당 인터페이스를 구현한 클래스는 복제를 허용한 클래스라 볼 수 있다.

- 공변 반환타입
JDK1.5부터는 조상 메서드의 반환 타입을 조상 클래스에서 자손 클래스로 바꿀 수 있다.
예를 들면 Object clone() 메서드를 오버라이딩 할 때 Child clone() 으로 바꿀 수 있다.

- 얕은 복사와 깊은 복사
얕은 복사는 기본 자료형의 경우엔 문제가 없지만, 객체같은 경우엔 객체의 주소 값만 복제하기 때문에 원본의 값이 변경 시 복사본의 값도 함께 변경이 된다.
갚은 복사는 참조하고 있는 객체의 값도 함께 복사하기 때문에 원본과 복사본은 완전히 서로 다른 객체이므로 서로 영향을 주지 않는다.

여기서 clone() 메서드는 단순히 객체의 주소를 포함해 멤버의 값만 복사하는 얕은 복사이다.
기본형 배열은 clone()을 해도 크게 문제는 되지 않지만, 참조형 배열의 경우 두 객체는 같은 주소를 가진 배열이 된다.

5. Class getClass()
이 메서드는 해당 객체의 클래스 객체를 반환하는 메서드이다.
이 클래스 객체는 클래스에 대한 모든 정보를 가지고 있으며 클래스당 단 1개만 존재한다. 또한 클래스 객체는 클래스 파일이 클래스 로더에 의해서 메모리에 올라갈 때 생성된다.
	ㄴ 즉 클래스 로더는 .class 파일을 읽어서 Class 객체를 생성하고 안에 정보를 넣는 역할을 한다.
# 클래스 로더는 런타임 시점에 동적으로 필요한 클래스 파일을 읽어와 메모리에 등록한다. 만약 이미 객체가 등록되어 있다면 참조 주소를 반환하고, 없다면 class 파일을 가져와 등록 후 참조 변수 주소를 반환한다.

getClass() 메서드 외에 클래스 객체를 가져오는 방법은 많다.
1. new Card().getClass() // 생성된 객체로 부터 가져오기
2. Card.class // 리터럴을 통해서 가져오기
3. Class.forName("Card") // 클래스 이름으로 가져오기

Class 객체를 활용하면 멤버의 갯수나 이름, 메서드를 호출할 수 있다.

[ String 클래스 ]

- 불변 클래스
String 클래스 내부에는 문자열을 저장하는 char[] value; 변수가 있다.
String 클래스는 생성자로 넘어온 문자열을 value 변수에 저장한다. 이때 인스턴스가 생성된 이후에는 값은 변경될 수 없다.
String str = "a" + "b" + "c";
위의 문자열은 덧셈 연산자를 통해서 문자열을 붙이는 것 같지만 사실은 + 연산마다 새로운 인스턴스가 생성되고 있는 것이다.
따라서 메모리 공간에 영향을 미칠 수 있기 때문에, 문자열을 많이 다뤄야 하는 경우 StringBuffer 를 사용하는 것이 좋다.
# StringBuffer는 문자열을 변경 가능하기 때문에 하나의 인스턴스로 문자열을 다룰 수 있따.

- new 연산자 vs 문자열 리터럴

문자열을 만들 때는 문자열 리터럴을 사용하거나 new 연산자를 활용하거나 2가지 방법이 있다.
1. String str = "abc";
위의 경우는 문자열 리터럴을 통해서 문자열을 만드는 것이며, 문자열 리터럴은 이미 존재하는 것을 재사용 한다.
따라서 문자열 리터럴로 같은 객체를 생성했을 경우에 같은 주소값을 가지기 때문에 등가비교연산자(==) 를 사용하면 true를 결과로 얻는다.

2. String str = new String("abc");
new 연산자를 통해서 문자열을 생성하면 new 연산자를 통해서 새로운 인스턴스를 생성하는 것이기 때문에 항상 새로운 인스턴스가 생성된다.

- 문자열 리터럴
소스 코드에 있는 문자열 리터럴은 컴파일 시에 class 파일에 저장된다.
이때 중복되는 문자열 리터럴은 단 하나만 저장되며, 로드 시 하나의 String 인스턴스에 저장된다.
따라서 같은 문자열 리터럴을 사용하는 String 인스턴스는 모두 같은 주소를 공유하게 된다.

클래스 파일을 보면 소스 파일에 있는 모든 리터럴들이 보관되어 있다.
이 리터럴들은 클래스 로더에 의해 메모리에 올라갈 때, JVM 내에 있는 상수 저장소 ( constant pool ) 에 저장된다.

- String.format()
이 메서드는 형식화된 문자열을 만드는 메서드이다. Printf 와 사용하는 방법은 일치하다.
String.format("%s 값은 %d 이다." , "six" , 6);

- substring(int  start,int end)
문자열에서 특정 부분을 추출하는 메서드이다.
주의해야 할 점은 매개변수 중 int start 는 0번째 부터 시작하고, end 는 해당 위치의 포함하지 않는다.
즉, 하단의 코드의 출력 결과는 "abc" 가 된다.
System.out.println("abcabc".substring(0,3));


- String과 int 간의 형 변환 ( 문자열과 기본형간에 형 변환 )
1. Int -> String
int를 String으로 바꾸는 방법은, 숫자를 빈 문자열과 더하거나, valueOf() 를 사용하는 방법이 있다.
valueOf() 를 사용하는 것이 더 성능이 좋지만, 가독성의 이유로 빈 문자열을 더하는 것이다.
int value = 30;
System.out.println("" + value);
System.out.println(String.valueOf(30));

2. String -> Int
반대로 String 을 Int로 바꾸는 방법은 valueOf 를 쓰거나 parseInt 를 쓰면 된다.
String strValue = "151";
System.out.println(Integer.parseInt(strValue));
System.out.println(Integer.valueOf(strValue));

사실 parseInt와 valueOf() 는 크게 다르지 않다. valueOf는 parseInt를 호출하는 역할을 한다.
왜 굳이 valueOf가 만들어 졌냐면, 메서드의 이름을 통일하기 위해서이다.

3. String <-> 기본 자료형
기본 자료형을 String으로 바꾸는 것은 String.valueOf() 를 통일하면 되기 때문에 어렵진 않다.
다만 기본형의 경우 Boolean.parseBoolean() , Short.parseShort() , Long.parseLong() 등 기본 자료형에 대해서 문자열을 해당 기본형으로 바꿔주는 메서드가 있으니
그것을 사용하면 된다.

문자열을 정수로 바꾸는 parseInt 나 valueOf 를 사용할 경우 문자열에 공백이 포함되어 있으면 예외 ( NumberFormatException )
이 발생할 수 있다. 그렇기 때문에 정수형으로 형 변환하기 전에 공백을 제거하는 trim 을 적절히 잘 사용해야 한다.
System.out.println(Integer.parseInt(strValue.trim()));

[ StringBuffer 및 StringBuilder ]
String 클래스와 달리 StringBuffer는 문자열을 편집할 수 있는 클래스이며, 두 클래스는 char형 배열을 가지고 있다는 공통점을 가지고 있다.
StringBuffer는 내부적으로 문자열을 편집하기 위한 버퍼를 가지고 있으며 이 버퍼가 char형 배열이 된다. 이 배열은 편집할 문자열의 길이를 고려하여 넉넉하게 잡아야 한다.
만일 버퍼의 크기가 모자르다면, 새로운 길이의 버퍼를 만들게 된다.
	ㄴ 이때 새로운 길이의 배열을 생성 후 이전의 값을 복사해 온다.

StringBuffer(int length) 생성자를 활용하여 버퍼의 길이를 지정할 수 있다. 만약 지정하지 않으면 16개의 문자를 저장할 수 있는 버퍼가 생성된다.

        StringBuffer sb = new StringBuffer();
        sb.append("abc").append("de");

        System.out.println(sb);
위의 예제는 문자열 변경 가능한 StringBuffer의 예제이다.
append() 메서드는 반환 타입이 StringBuffer ( 자기 자신 ) 이므로, 연속적으로 append() 를 호출하는 것이 가능하다.

- StringBuffer의 문자열 비교
StringBuffer 클래스는 equals 메서드가 오버라이딩 되어있지 않아 등가비교연산자(==)를 사용한 것과 같은 결과를 얻는다.
하지만 toString()은 오버라이딩이 되어 있어 해당 인스턴스의 문자열을 반환하게 되어있다.

따라서 StringBuffer간에 문자열 비교는 .toString() 으로 문자열을 뽑아낸 다음 .equals() 메서드로 비교 연산을 수행하면 된다..
        StringBuffer sb = new StringBuffer();
        sb.append("abc").append("de");

        StringBuffer sb2 = new StringBuffer("abc").append("de");
        System.out.println("sb == sb2 : " + (sb==sb2));	// false
        System.out.println("sb equals sb2 : " + (sb.equals(sb2))); // false
        System.out.println("sb str == sb2 str : " + (sb.toString().equals(sb.toString()))); // true
		
        StringBuffer sb3 = new StringBuffer(32);
        System.out.println("버퍼 크기 : " + sb3.capacity());
        System.out.println("문자열 추가 : " + sb3.append("hello"));
        System.out.println("문자열 사이 추가 : " + sb3.insert(2 , " he"));
        System.out.println("문자열 사이 제거 : " + sb3.delete(5,32));
        System.out.println("문자열 바꾸기 : " + sb3.replace(0 , 2 , "sui"));
        System.out.println("문자열 뒤바꾸기 : " + sb3.reverse());
위의 예제 처럼 StringBuffer는 String 클래스에서 제공하는 대부분의 메서드를 가지고 있으며, 추가로 문자열을 제거, 수정하기 위한 메서드도 제공한다.

- StringBuilder란?
StringBuilder와 StringBuffer는 완전히 똑같은 기능을 제공하고 있다.
다만 차이점은 StringBuffer는 멀티 쓰레드에 안전하게 동기화되어 있고, StringBuilder는 동기화를 지원하지 않는 클래스이다.
이때 동기화는 성능을 떨어뜨리는 단점이 있기 때문에 싱글 쓰레드 환경에서는 StringBuilder를 사용하면 된다.

다만 StringBuffer도 성능이 좋기 때문에 싱글쓰레드에서 동기화를 사용한다고 해도 프로그램이 눈에 띄게 느려지거나 하진 않는다.

[ Math 클래스 ]
Math 클래스는 기본적인 수학 연산을 위한 메서드를 제공한다.
Math 클래스는 생성자의 접근 제어자가 private 이기 때문에 인스턴스로 만들 수 없다. 그 이유는 Math 클래스 내에 모든 메서드가 static 이며 멤버 변수가 없으며, 상수 값만 존재한다.
그렇기 때문에 인스턴스를 만들 필요가 없기 때문에 생성자의 접근 제어가 private인 것이다.

- 반올림 round()
해당 메서드는 소수점 첫째 자리에서 반올림해서 정수형으로 반환한다.
그렇기 때문에 특정 자릿수에서 반올림한 결과를 얻고 싶다면 아래의 식을 사용하면 된다.
if ) 4번째 자릿수에서 반올림
        double value = 12.3456712;
        value *= (1000);
        System.out.println(Math.round(value) / 1000.0 );
결과 값 : 12.346
위의 식 3번째 줄에서 정수형으로 나눈다면 결과 값은 12 가 나온다. 정수형 간에 연산은 소수점이 버려지고 정수 부분만 나온다.

- 올림 ceil() , 버림 floor() , 반환 값이 double은 반올림 rint()
rint()는 double() 과 차이가 없지만 반환 값에 차이가 있다.
그리고 음수의 경우 -1.5 에 대해 rint 는 -2.0 을 반환하지만 round는 -1 을 반환한다.

- 예외를 발생시키는 메서드
메서드 이름에 Exact 가 붙은 메서드는 오버플로우가 발생하면 예외 ( ArithmeticException ) 를 발생시킨다.
기존 연산자는 단순히 계산만 할 뿐 오버플로우가 발생한 것에 대해선 알려주지 않았다.
Math.addExact(10, 50);
Math.multiplyExact(123123, 124124)
Math.negateExact(Integer.MIN_VALUE)

- 그 외 메서드들
제곱근을 계산해주는 sqrt() 와 n 의 제곱을 계산해주는 pow() 가 존재한다.
        System.out.println(Math.sqrt(9.0)); // 3.0
        System.out.println(Math.pow(3 , 3)); // 9.0
abs() 절대값 , max(int,int) 더 큰 값을 반환 등등 여러 메서드를 제공한다.
		
- StrictMath 클래스
기존 Math 클래스는 최대한의 성능을 내기 위해 JVM이 설치된 OS 메서드를 활용한다.
그렇기 때문에 OS 마다 다른 연산 결과를 얻을 수 있다는 문제가 발생했다.
이러한 문제를 해결하기 위해, 각기 다른 OS에서도 항상 같은 결과를 얻을 수 있게 새로 작성된 것이 StrictMath 클래스이다.
# 물론 StrictMath 클래스는 Math 클래스보다 성능은 다소 느리다.