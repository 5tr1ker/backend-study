[ 예외 처리 ]
프로그램 실행 중 어떠한 원인으로 오작동하거나 비 정상적으로 종료되는 경우, 이러한 결과를 초래할 수 있는 원인을 프로그램 오류, 또는 에러라고 한다.

컴파일 에러 : 컴파일 할 때 발생하는 에러
	ㄴ 컴파일러가 소스 파일 ( .java ) 을 검사하여 오타나 잘못된 구문, 자료형 체크 등의 기본적인 검사를 수행 후 
	문제가 없으면 클래스 파일 ( .class ) 을 생성한다.
런타임 에러 : 실행 도중 발생하는 에러
	ㄴ 컴파일 에러가 발생하지 않았더라도, 실행 도중에 오류가 발생할 수 있다.
논리적 에러 : 의도한 것과 다르게 동작하는 것

# 컴파일러는 소스 코드의 기본적인 에러는 찾을 수 있지만, 런타임 시점에 발생할 수 있는 잠재적인 오류는 찾지 못한다. 따라서 개발자는
# 프로그램 실행 도중 발생할 수 있는 모든 경우의 수를 고려해서 프로그래밍 해야한다.

자바에서는 런타임 시점에 발생할 수 있는 오류를 "에러(error)" 와 "예외(exception)" 두가지로 구분하였다.
- 에러(error) : 메모리 부족 (OutOfMemoryError) 와 스택오버플러우(StackOverFlowError) 와 같이 발생하면 복구할 수 없는 심각한 오류
- 예외(exception) : 발생하더라도 수습할 수 있는 비교적 덜 심각한 오류
에러(error) 는 프로그램이 종료되는 것을 막을 수 없지만, 예외 ( exception ) 은 프로그램이 종료되는 것을 코드로 막을 수 있다.

자바에서는 예외가 발생할 수 있는 오류 ( Exception 과 Error ) 를 클래스로 정의하였으며, 이러한 클래스들도 최고 조상은 Object 클래스이다.
Object < Throwable < Exception < RuntimeException
					< Error	< OutOfMemoryError

예외 클래스들은 두 그룹으로 묶을 수 있다.
1. Exception 클래스와 그 자손들 ( IOException , ClassNotFountException 등등.. )
2. RuntimeException 클래스와 그 자손들 ( ArithmeticException, NullPointException 등등.. )

RuntimeException 클래스와 그 자손은 주로 프로그래머의 실수에 의해서 발생할 수 있는 예외들로 자바의 프로그래밍과 관계가 깊다.
	ㄴ 예를 들면 존재하지 않는 파일을 읽거나 ( FileNotFoundException ) , 값이 null인 참조변수를 조회한다거나 ( NullPointException ) , 정수를 0 으로 나누든가 ( ArithmeticException )에 해당한다.
	
Exception 클래스와 그 자손들은 주로 외부의 영향에 의해서 발생할 수 있으며, 프로그램 사용자들의 동작에 의해 발생할 수 있다.
	ㄴ 예를 들면 존재 하지 않는 파일을 입력했거나 ( FileNotFoundException ) , 데이터를 잘못 입력했다던가 ( DataFormatException ) 에 해당한다.
	
# 정리
# Exception 클래스와 자손 클래스 : 사용자의 실수 등, 외적인 요인에 의해 발생하는 예외
# RuntimeException 클래스와 자손 클래스 : 프로그래머의 실수로 인해서 발생할 수 있는 예외

[ 예외처리 try - catch ]
프로그램 실행 중 발생하는 에러는 어쩔 수 없지만, 예외같은 경우는 프로그래머가 대비를 할 수 있다.

예외 처리란? 프로그램 실행 도중 발생할 수 있는 예외에 대비한 코드를 작성하는 것이다.
예외 처리의 목적은? 예외의 발생으로 프로그램의 비 정상적인 종료를 막고, 정상적인 상태를 유지하기 위해서이다.

발생한 예외를 처리하지 못하면, 프로그램은 비정상적으로 종료되며 처리되지 못한 예외 ( uncaught exception ) 는 JVM의 예외 처리기 ( UncaughtExceptionHandler ) 가 예외의 원인을 화면에 출력한다.

try {

} catch (Exception e) {

} catch (Exception2 e) {
}...
위의 예제는 예외 처리를 위한 try-catch의 예제이다.
하나의 try 블록 다음엔 여러 종류의 Exception을 처리하기 위한 catch 블록이 1개 이상 올 수 있으며, 이중 발생한 예외와 일치하는 단 하나의 catch 블록만 실행된다.
만약 발생한 예외와 일치하는 Exception이 없을 경우 처리되지 않는다.

public void method1() {
        try {
            try {

            } catch (Exception e) {

            }
        } catch (Exception e) {
            try {

            } catch (Exception ex) { // 이름 중복

            }
        }

        try {

        } catch (Exception e) {

        }
    }
위의 예제는 try - catch 의 예제이다.
한 메서드에 여러 개의 try- catch 를 사용할 수 있고, 각 블록 내에서도 try - catch 를 사용할 수 있다.
다만 catch 블록 안에 참조 변수의 이름이 중복되지 않게만 조심하면 된다.

Exception in thread "main" java.lang.ArithmeticException: / by zero
	at g_exception.TryCatchTest.method2(TryCatchTest.java:40)
	at g_exception.Main.main(Main.java:7)

위의 메세지는 실제로 예외가 발생했을 때의 메세지이다. 예외가 발생했을 때 발생 원인과 예외가 발생한 위치를 알 수 있다.
0으로 나눈 ArithmeticException 예외와 TryCatchTest 클래스의 40번째 줄에서 오류가 발생했다는 것을 알 수 있다.

- try - catch 문의 흐름
try - catch 문에서는 예외가 발생했을 경우와 발생하지 않은 경우의 실행 흐름이 다르게 처리된다.
1. try 블록 내에서 예외가 발생한 경우 : 발생한 예외와 일치하는 catch 블록을 찾은 후 해당 catch 블록 내 문장을 수행하고 try-catch 문을 벗어난다.
	ㄴ 이때 try 블록 안에서 예외가 발생할 경우, 예외가 발생한 코드 이후의 문장은 수행되지 않는다.
	ㄴ 또한 예외에 해당하는 catch 문이 존재하지 않는 경우 예외는 처리되지 않는다.
2. try 블록 내에서 예외가 발생하지 않은 경우, 그대로 try - catch 문을 벗어나 다음 문장을 수행한다.

catch 블록은 ()괄호와 {}블록으로 나뉘어져 있다.
() 괄호는 처리하고자 하는 예외 클래스와 참조 변수를 선언해야 한다. 
예외가 발생하면 발생한 예외의 인스턴스가 만들어 진다. 예를 들면 ClassNotFountException 예외가 발생하면 해당 클래스에 대한 인스턴스가 만들어진다.
try 블록 안에 예외가 발생하면, 첫번째 catch 블록부터 차례대로 내려가면서 검사를 하게 된다.
	ㄴ 이때 catch 블럭의 괄호() 내에 선언된 참조 변수와 예외 클래스의 인스턴스를 instanceof 연산자를 활용해 검사를 하다가 검사 결과가 true 인 catch 블록을 만나게 되면 해당 블록 내의 문장들을 모두 수행하고 try-catch 문을 벗어나게 된다.
	ㄴ 물론 true 인 catch 블록이 없다면 예외는 처리되지 않는다.

# 모든 예외 클래스는 Exception 클래스의 자손이기 때문에 catch 블록 안에 Exception 클래스의 참조 변수를 선언하면 모든 예외 클래스를 처리할 수 있다. ( instanceof 연산자는 같은 클래스 뿐만이 아니라 조상 클래스도 true를 반환하기 때문이다. )

public void method3() {
        try {
            System.out.println(0);
            System.out.println(1);
            System.out.println(0/0);
            System.out.println(2);
        } catch (ArithmeticException e){
            System.out.println(3);
        } catch (Exception e){
            System.out.println(4);
        }
        System.out.println(5);
}
위의 예제는 try-catch 활용 예제이다. try 블록에서 ArithmeticException 이 발생했기 때문에 catch 블록을 차례대로 검사한다.
이때 첫번째 catch 에서 검사 결과가 true 가 나왔기 때문에 해당 블록을 실행하고 try-catch 문을 벗어나게 된다.
이때 두번째 catch 블록도 검사 결과는 통과하겠지만 첫번째 블록에서 처리되기 때문에 검사되지 않는다.

다만 마지막 catch 블록에 Exception 을 선언할 경우 ArithmeticException 가 발생하지 않은 경우에도 예외를 처리할 수 있다.

- printStackTrace() 와 getMessage()
예외가 발생했을 때 생성된 예외 클래스의 인스턴스에는 발생한 예외에 대한 정보를 가지고 있다.
catch 블럭의 괄호() 에 선언된 참조 변수를 통해서 해당 인스턴스에 접근할 수 있으며, 자주 사용하는 메서드들은 하단의 정보와 같다.
- printStackTrace() : 예외 발생 당시 호출 스택 ( call Stack ) 에 있는 메서드의 정보와 예외 메세지를 화면에 출력한다.
- getMessage() : 발생한 예외 클래스의 인스턴스가 담고 있는 메세지를 얻을 수 있다.

[ 멀티 Catch 블럭 ]
JDK1.7 부터는 여러 catch 블록을 '|' 기호를 이용해서 하나의 catch 블록에 여러 개의 예외 클래스를 처리할 수 있다.
중복되는 코드가 있으면 묶을 수 있고 묶을 수 있는 클래스의 개수는 제한이 없다.
# 멀티 catch 를 잘 활용하면 코드의 중복을 없엘 수 있다.

    public void method5() {
        try {
            System.out.println("hel");

            method6();
        } catch (ArithmeticException | IOException e){
            System.out.println(e.getClass().getName());
        }
    }
	
또한 '|' 기호로 묶인 클래스 간에 상속 관계에 있다면 컴파일 에러가 발생한다.
그 이유는 상속 관계라면 부모 클래스만 적어주면 되기 때문이다.

또한 멀티 catch 블록 내에서는 어떤 예외 클래스인지 알 수 없다.
그래서 멀티 catch 블록에 있는 클래스들의 공통 조상 클래스의 멤버 변수만 사용할 수 있다.
필요하다면 instanceof 연산자를 활용해서 어떤 클래스인지 확인해서 사용할 수 있지만 비효율적이다.

또한 멀티 catch 블록 내 선언된 참조 변수 e 는 상수이므로 값을 변경할 수 없다.
그 이유는 여러 catch 블록이 하나의 참조 변수를 공유하기 때문이다.

[ 예외 던지기 ]
키워드 throw 를 활용해서 고의로 예외를 발생 시킬 수 있다.
예외를 발생시키는 방법은 다음과 같다.
1. new 연산자를 활용해서 발생하고자 하는 예외 클래스의 객체를 만든다.
2. throw 키워드를 이용해서 예외를 발생시킨다.

    private void method6() throws ArithmeticException {
        ArithmeticException e = new ArithmeticException("arithmeticException 발생하였습니다.");

        throw e;
    }
만약 예외 클래스의 생성자에 String 문자열을 넣어줄 경우에, 해당 문자열은 예외 클래스의 인스턴스의 메세지에 저장이 되며 getMessage() 메서드를 통해 확인할 수 있다.
	

하단의 예제의 경우 method07은 오류가 뜨질 않는데, method08은 예외가 발생한다.
    private void method07() {
        throw new RuntimeException();
    }

    private void method08() {
        throw new Exception();
    }
그 이유는 Exception 클래스들과 자손들은 예외가 발생할 가능성이 있을 경우 예외 처리를 꼭 해주어야 한다.
만약 그렇지 않다면 컴파일조차 되지 않을 것이다.
# 위의 코드를 컴파일하면 예외 처리를 하지 않았다는 예외 메세지가 뜬다.

반대로 RuntimeException 예외를 던지는 코드도 있고 예외 처리를 하지 않았음에도 컴파일이 되고 실행이 된다. ( 물론 프로그램이 비 정상적으로 종료된다. )
하지만 Exception 클래스와는 달리 컴파일이 된다. 그 이유는 RuntimeException 클래스와 그 자손들은 프로그래머의 실수로 발생할 수 있는 예외에 대해선 예외 처리를 필수로 하지 않았다.

# 컴파일러가 예외 처리를 확인하지 않는 RuntimeException 클래스들을 "unchecked Exception" 이라하고,
# 컴파일러가 예외 처리를 확인하는 Exception 클래스들을 "checked Exception" 이라고 한다.

[ 메서드의 예외 선언 ]
예외를 처리하는 방법에는 try-catch 뿐만이 아니라 예외를 메서드에 선언하는 방법도 있다.

메서드에 예외를 선언하는 방법은 메서드의 선언부에 키워드 throws 를 선언하고, 메서드 내에서 발생할 수 있는 예외들을 적어주기만 하면 된다.
만약 예외가 여러개라면 쉼표로 구분할 수 있다.

public void method08() throws RuntimeException , ArithmeticException {

}

위와 같이 예외 처리를 선언하면, 해당 클래스의 자손 예외 클래스도 예외가 발생할 수 있다.
만약 throws Exception 으로 선언할 경우 모든 종류의 예외가 발생할 수 있다는 뜻이다.

이렇게 메서드에 예외를 선언하면 해당 메서드를 사용하기 위해서 어떤 예외들을 처리해야 하는지 쉽게 알 수 있다.
또한 메서드 내에서 발생할 수 있는 예외를 처리하도록 강요하기 때문에 견고한 프로그램을 만들 수 있다.

public final void wait() throws InterruptedException
위의 메서드는 Object 클래스에 선언된 메서드이다.
이 메서드의 선언 부를 보면 해당 메서드는 InterruptedException 예외가 발생할 수 있으니, 예외 처리를 해주어야 한다는 것이다.
# 단 InterruptedException 예외는 Exception 클래스의 자손이므로 예외를 처리하거나 throws 로 선언한다.

RuntimeException 의 자손 클래스는 예외 처리를 하지 않아도 되기 때문에 throws 로 선언하지 않아도 된다.
# throws 에 선언해도 큰 문제는 없지만, 보통 반드시 처리해야 하는 예외 클래스만 선언한다.

그리고 throws 로 선언을 할 경우 예외 처리를 하는 것이 아니라, 자신을 호출한 클래스에게 예외를 떠넘기는 것이다.
그렇기 때문에 예외가 발생했을 때 자신을 호출한 메서드는 예외를 처리하거나 ( try-catch ) 또 예외를 던져야 ( throws ) 한다.
# 만약 main 메서드까지 거슬러 올라가면서 예외가 처리되지 않았을 경우 프로그램은 종료된다.

그러면 언제 자체적으로 처리 ( try-catch ) 하고, 언제 예외를 선언하는 것이 좋을까?
만약 예외가 발생한 메서드 내부에서 처리해도 되는 경우는 메서드 내 try-catch를 활용하고, 메서드 호출 시 넘겨받아야 하는 값을 다시 받아야 하는 경우 예외를 선언해서 외부에서 다시 처리하게 한다.

또한 예외가 발생하면 오류 스택 메세지를 통해 알 수 있는 메세지가 있다.
Exception in thread "main" java.lang.Exception
	at g_exception.TryCatchTest.method10(TryCatchTest.java:113)
	at g_exception.TryCatchTest.method09(TryCatchTest.java:109)
	at g_exception.TryCatchTest.method08(TryCatchTest.java:105)
	at g_exception.Main.main(Main.java:7)
	
위의 메세지를 보면 예외가 발생했을 때 호출 스택의 내용을 알 수 있으며, 보면 main 메서드가 method08 를 호출하고, method08이 method09를 호출하고, 마지막으로 method10 을 호출한다.
이때 method10에서 Exception 예외가 발생하여 프로그램이 비 정상적으로 종료되었다.
# 물론 try-catch 없이 예외를 선언하기만 해서 비정상적으로 종료된 것이다.

    public void method11() {
        try {
            method09();
        } catch (Exception e) {
            System.out.println("예외를 잡았습니다.");
            e.printStackTrace();
        }
    }
	
물론 다음과 같이 예외를 선언하지만 하지 않고, try-catch를 통해 처리를 해준다면 프로그램이 비 정상적으로 종료되는 일은 없다.
메세지 :
예외를 잡았습니다.
java.lang.Exception
	at g_exception.TryCatchTest.method10(TryCatchTest.java:113)
	at g_exception.TryCatchTest.method09(TryCatchTest.java:109)
	at g_exception.TryCatchTest.method11(TryCatchTest.java:118)
	at g_exception.Main.main(Main.java:7)

위의 메세지는 예외에 대한 메세지는 발생하고 있지만, 프로그램이 비정상적으로 종료된 것이 아니라, 단순히 e.printStackTrace() 를 통해 예외 발생 시점의 호출 스택을 출력한 것 뿐이다.