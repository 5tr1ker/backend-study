[ 예외 처리 ]
프로그램 실행 중 어떠한 원인으로 오작동하거나 비 정상적으로 종료되는 경우, 이러한 결과를 초래할 수 있는 원인을 프로그램 오류, 또는 에러라고 한다.

컴파일 에러 : 컴파일 할 때 발생하는 에러
	ㄴ 컴파일러가 소스 파일 ( .java ) 을 검사하여 오타나 잘못된 구문, 자료형 체크 등의 기본적인 검사를 수행 후 
	문제가 없으면 클래스 파일 ( .class ) 을 생성한다.
런타임 에러 : 실행 도중 발생하는 에러
	ㄴ 컴파일 에러가 발생하지 않았더라도, 실행 도중에 오류가 발생할 수 있다.
논리적 에러 : 의도한 것과 다르게 동작하는 것

# 컴파일러는 소스 코드의 기본적인 에러는 찾을 수 있지만, 런타임 시점에 발생할 수 있는 잠재적인 오류는 찾지 못한다. 따라서 개발자는
# 프로그램 실행 도중 발생할 수 있는 모든 경우의 수를 고려해서 프로그래밍 해야한다.

자바에서는 런타임 시점에 발생할 수 있는 오류를 "에러(error)" 와 "예외(exception)" 두가지로 구분하였다.
- 에러(error) : 메모리 부족 (OutOfMemoryError) 와 스택오버플러우(StackOverFlowError) 와 같이 발생하면 복구할 수 없는 심각한 오류
- 예외(exception) : 발생하더라도 수습할 수 있는 비교적 덜 심각한 오류
에러(error) 는 프로그램이 종료되는 것을 막을 수 없지만, 예외 ( exception ) 은 프로그램이 종료되는 것을 코드로 막을 수 있다.

자바에서는 예외가 발생할 수 있는 오류 ( Exception 과 Error ) 를 클래스로 정의하였으며, 이러한 클래스들도 최고 조상은 Object 클래스이다.
Object < Throwable < Exception < RuntimeException
					< Error	< OutOfMemoryError

예외 클래스들은 두 그룹으로 묶을 수 있다.
1. Exception 클래스와 그 자손들 ( IOException , ClassNotFountException 등등.. )
2. RuntimeException 클래스와 그 자손들 ( ArithmeticException, NullPointException 등등.. )

RuntimeException 클래스와 그 자손은 주로 프로그래머의 실수에 의해서 발생할 수 있는 예외들로 자바의 프로그래밍과 관계가 깊다.
	ㄴ 예를 들면 존재하지 않는 파일을 읽거나 ( FileNotFoundException ) , 값이 null인 참조변수를 조회한다거나 ( NullPointException ) , 정수를 0 으로 나누든가 ( ArithmeticException )에 해당한다.
	
Exception 클래스와 그 자손들은 주로 외부의 영향에 의해서 발생할 수 있으며, 프로그램 사용자들의 동작에 의해 발생할 수 있다.
	ㄴ 예를 들면 존재 하지 않는 파일을 입력했거나 ( FileNotFoundException ) , 데이터를 잘못 입력했다던가 ( DataFormatException ) 에 해당한다.
	
# 정리
# Exception 클래스와 자손 클래스 : 사용자의 실수 등, 외적인 요인에 의해 발생하는 예외
# RuntimeException 클래스와 자손 클래스 : 프로그래머의 실수로 인해서 발생할 수 있는 예외

[ 예외처리 try - catch ]
프로그램 실행 중 발생하는 에러는 어쩔 수 없지만, 예외같은 경우는 프로그래머가 대비를 할 수 있다.

예외 처리란? 프로그램 실행 도중 발생할 수 있는 예외에 대비한 코드를 작성하는 것이다.
예외 처리의 목적은? 예외의 발생으로 프로그램의 비 정상적인 종료를 막고, 정상적인 상태를 유지하기 위해서이다.

발생한 예외를 처리하지 못하면, 프로그램은 비정상적으로 종료되며 처리되지 못한 예외 ( uncaught exception ) 는 JVM의 예외 처리기 ( UncaughtExceptionHandler ) 가 예외의 원인을 화면에 출력한다.

try {

} catch (Exception e) {

} catch (Exception2 e) {
}...
위의 예제는 예외 처리를 위한 try-catch의 예제이다.
하나의 try 블록 다음엔 여러 종류의 Exception을 처리하기 위한 catch 블록이 1개 이상 올 수 있으며, 이중 발생한 예외와 일치하는 단 하나의 catch 블록만 실행된다.
만약 발생한 예외와 일치하는 Exception이 없을 경우 처리되지 않는다.

public void method1() {
        try {
            try {

            } catch (Exception e) {

            }
        } catch (Exception e) {
            try {

            } catch (Exception ex) { // 이름 중복

            }
        }

        try {

        } catch (Exception e) {

        }
    }
위의 예제는 try - catch 의 예제이다.
한 메서드에 여러 개의 try- catch 를 사용할 수 있고, 각 블록 내에서도 try - catch 를 사용할 수 있다.
다만 catch 블록 안에 참조 변수의 이름이 중복되지 않게만 조심하면 된다.

Exception in thread "main" java.lang.ArithmeticException: / by zero
	at g_exception.TryCatchTest.method2(TryCatchTest.java:40)
	at g_exception.Main.main(Main.java:7)

위의 메세지는 실제로 예외가 발생했을 때의 메세지이다. 예외가 발생했을 때 발생 원인과 예외가 발생한 위치를 알 수 있다.
0으로 나눈 ArithmeticException 예외와 TryCatchTest 클래스의 40번째 줄에서 오류가 발생했다는 것을 알 수 있다.

- try - catch 문의 흐름
try - catch 문에서는 예외가 발생했을 경우와 발생하지 않은 경우의 실행 흐름이 다르게 처리된다.
1. try 블록 내에서 예외가 발생한 경우 : 발생한 예외와 일치하는 catch 블록을 찾은 후 해당 catch 블록 내 문장을 수행하고 try-catch 문을 벗어난다.
	ㄴ 이때 try 블록 안에서 예외가 발생할 경우, 예외가 발생한 코드 이후의 문장은 수행되지 않는다.
	ㄴ 또한 예외에 해당하는 catch 문이 존재하지 않는 경우 예외는 처리되지 않는다.
2. try 블록 내에서 예외가 발생하지 않은 경우, 그대로 try - catch 문을 벗어나 다음 문장을 수행한다.

catch 블록은 ()괄호와 {}블록으로 나뉘어져 있다.
() 괄호는 처리하고자 하는 예외 클래스와 참조 변수를 선언해야 한다. 
예외가 발생하면 발생한 예외의 인스턴스가 만들어 진다. 예를 들면 ClassNotFountException 예외가 발생하면 해당 클래스에 대한 인스턴스가 만들어진다.
try 블록 안에 예외가 발생하면, 첫번째 catch 블록부터 차례대로 내려가면서 검사를 하게 된다.
	ㄴ 이때 catch 블럭의 괄호() 내에 선언된 참조 변수와 예외 클래스의 인스턴스를 instanceof 연산자를 활용해 검사를 하다가 검사 결과가 true 인 catch 블록을 만나게 되면 해당 블록 내의 문장들을 모두 수행하고 try-catch 문을 벗어나게 된다.
	ㄴ 물론 true 인 catch 블록이 없다면 예외는 처리되지 않는다.

# 모든 예외 클래스는 Exception 클래스의 자손이기 때문에 catch 블록 안에 Exception 클래스의 참조 변수를 선언하면 모든 예외 클래스를 처리할 수 있다. ( instanceof 연산자는 같은 클래스 뿐만이 아니라 조상 클래스도 true를 반환하기 때문이다. )

public void method3() {
        try {
            System.out.println(0);
            System.out.println(1);
            System.out.println(0/0);
            System.out.println(2);
        } catch (ArithmeticException e){
            System.out.println(3);
        } catch (Exception e){
            System.out.println(4);
        }
        System.out.println(5);
}
위의 예제는 try-catch 활용 예제이다. try 블록에서 ArithmeticException 이 발생했기 때문에 catch 블록을 차례대로 검사한다.
이때 첫번째 catch 에서 검사 결과가 true 가 나왔기 때문에 해당 블록을 실행하고 try-catch 문을 벗어나게 된다.
이때 두번째 catch 블록도 검사 결과는 통과하겠지만 첫번째 블록에서 처리되기 때문에 검사되지 않는다.

다만 마지막 catch 블록에 Exception 을 선언할 경우 ArithmeticException 가 발생하지 않은 경우에도 예외를 처리할 수 있다.

- printStackTrace() 와 getMessage()
예외가 발생했을 때 생성된 예외 클래스의 인스턴스에는 발생한 예외에 대한 정보를 가지고 있다.
catch 블럭의 괄호() 에 선언된 참조 변수를 통해서 해당 인스턴스에 접근할 수 있으며, 자주 사용하는 메서드들은 하단의 정보와 같다.
- printStackTrace() : 예외 발생 당시 호출 스택 ( call Stack ) 에 있는 메서드의 정보와 예외 메세지를 화면에 출력한다.
- getMessage() : 발생한 예외 클래스의 인스턴스가 담고 있는 메세지를 얻을 수 있다.