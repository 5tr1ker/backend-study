[ 예외 처리 ]
프로그램 실행 중 어떠한 원인으로 오작동하거나 비 정상적으로 종료되는 경우, 이러한 결과를 초래할 수 있는 원인을 프로그램 오류, 또는 에러라고 한다.

컴파일 에러 : 컴파일 할 때 발생하는 에러
	ㄴ 컴파일러가 소스 파일 ( .java ) 을 검사하여 오타나 잘못된 구문, 자료형 체크 등의 기본적인 검사를 수행 후 
	문제가 없으면 클래스 파일 ( .class ) 을 생성한다.
런타임 에러 : 실행 도중 발생하는 에러
	ㄴ 컴파일 에러가 발생하지 않았더라도, 실행 도중에 오류가 발생할 수 있다.
논리적 에러 : 의도한 것과 다르게 동작하는 것

# 컴파일러는 소스 코드의 기본적인 에러는 찾을 수 있지만, 런타임 시점에 발생할 수 있는 잠재적인 오류는 찾지 못한다. 따라서 개발자는
# 프로그램 실행 도중 발생할 수 있는 모든 경우의 수를 고려해서 프로그래밍 해야한다.

자바에서는 런타임 시점에 발생할 수 있는 오류를 "에러(error)" 와 "예외(exception)" 두가지로 구분하였다.
- 에러(error) : 메모리 부족 (OutOfMemoryError) 와 스택오버플러우(StackOverFlowError) 와 같이 발생하면 복구할 수 없는 심각한 오류
- 예외(exception) : 발생하더라도 수습할 수 있는 비교적 덜 심각한 오류
에러(error) 는 프로그램이 종료되는 것을 막을 수 없지만, 예외 ( exception ) 은 프로그램이 종료되는 것을 코드로 막을 수 있다.

자바에서는 예외가 발생할 수 있는 오류 ( Exception 과 Error ) 를 클래스로 정의하였으며, 이러한 클래스들도 최고 조상은 Object 클래스이다.
Object < Throwable < Exception < RuntimeException
					< Error	< OutOfMemoryError

예외 클래스들은 두 그룹으로 묶을 수 있다.
1. Exception 클래스와 그 자손들 ( IOException , ClassNotFountException 등등.. )
2. RuntimeException 클래스와 그 자손들 ( ArithmeticException, NullPointException 등등.. )

RuntimeException 클래스와 그 자손은 주로 프로그래머의 실수에 의해서 발생할 수 있는 예외들로 자바의 프로그래밍과 관계가 깊다.
	ㄴ 예를 들면 존재하지 않는 파일을 읽거나 ( FileNotFoundException ) , 값이 null인 참조변수를 조회한다거나 ( NullPointException ) , 정수를 0 으로 나누든가 ( ArithmeticException )에 해당한다.
	
Exception 클래스와 그 자손들은 주로 외부의 영향에 의해서 발생할 수 있으며, 프로그램 사용자들의 동작에 의해 발생할 수 있다.
	ㄴ 예를 들면 존재 하지 않는 파일을 입력했거나 ( FileNotFoundException ) , 데이터를 잘못 입력했다던가 ( DataFormatException ) 에 해당한다.
	
# 정리
# Exception 클래스와 자손 클래스 : 사용자의 실수 등, 외적인 요인에 의해 발생하는 예외
# RuntimeException 클래스와 자손 클래스 : 프로그래머의 실수로 인해서 발생할 수 있는 예외

[ 예외처리 try - catch ]
프로그램 실행 중 발생하는 에러는 어쩔 수 없지만, 예외같은 경우는 프로그래머가 대비를 할 수 있다.

예외 처리란? 프로그램 실행 도중 발생할 수 있는 예외에 대비한 코드를 작성하는 것이다.
예외 처리의 목적은? 예외의 발생으로 프로그램의 비 정상적인 종료를 막고, 정상적인 상태를 유지하기 위해서이다.

발생한 예외를 처리하지 못하면, 프로그램은 비정상적으로 종료되며 처리되지 못한 예외 ( uncaught exception ) 는 JVM의 예외 처리기 ( UncaughtExceptionHandler ) 가 예외의 원인을 화면에 출력한다.

try {

} catch (Exception e) {

} catch (Exception2 e) {
}...
위의 예제는 예외 처리를 위한 try-catch의 예제이다.
하나의 try 블록 다음엔 여러 종류의 Exception을 처리하기 위한 catch 블록이 1개 이상 올 수 있으며, 이중 발생한 예외와 일치하는 단 하나의 catch 블록만 실행된다.
만약 발생한 예외와 일치하는 Exception이 없을 경우 처리되지 않는다.

public void method1() {
        try {
            try {

            } catch (Exception e) {

            }
        } catch (Exception e) {
            try {

            } catch (Exception ex) { // 이름 중복

            }
        }

        try {

        } catch (Exception e) {

        }
    }
위의 예제는 try - catch 의 예제이다.
한 메서드에 여러 개의 try- catch 를 사용할 수 있고, 각 블록 내에서도 try - catch 를 사용할 수 있다.
다만 catch 블록 안에 참조 변수의 이름이 중복되지 않게만 조심하면 된다.

Exception in thread "main" java.lang.ArithmeticException: / by zero
	at g_exception.TryCatchTest.method2(TryCatchTest.java:40)
	at g_exception.Main.main(Main.java:7)

위의 메세지는 실제로 예외가 발생했을 때의 메세지이다. 예외가 발생했을 때 발생 원인과 예외가 발생한 위치를 알 수 있다.
0으로 나눈 ArithmeticException 예외와 TryCatchTest 클래스의 40번째 줄에서 오류가 발생했다는 것을 알 수 있다.

- try - catch 문의 흐름
try - catch 문에서는 예외가 발생했을 경우와 발생하지 않은 경우의 실행 흐름이 다르게 처리된다.
1. try 블록 내에서 예외가 발생한 경우 : 발생한 예외와 일치하는 catch 블록을 찾은 후 해당 catch 블록 내 문장을 수행하고 try-catch 문을 벗어난다.
	ㄴ 이때 try 블록 안에서 예외가 발생할 경우, 예외가 발생한 코드 이후의 문장은 수행되지 않는다.
	ㄴ 또한 예외에 해당하는 catch 문이 존재하지 않는 경우 예외는 처리되지 않는다.
2. try 블록 내에서 예외가 발생하지 않은 경우, 그대로 try - catch 문을 벗어나 다음 문장을 수행한다.

catch 블록은 ()괄호와 {}블록으로 나뉘어져 있다.
() 괄호는 처리하고자 하는 예외 클래스와 참조 변수를 선언해야 한다. 
예외가 발생하면 발생한 예외의 인스턴스가 만들어 진다. 예를 들면 ClassNotFountException 예외가 발생하면 해당 클래스에 대한 인스턴스가 만들어진다.
try 블록 안에 예외가 발생하면, 첫번째 catch 블록부터 차례대로 내려가면서 검사를 하게 된다.
	ㄴ 이때 catch 블럭의 괄호() 내에 선언된 참조 변수와 예외 클래스의 인스턴스를 instanceof 연산자를 활용해 검사를 하다가 검사 결과가 true 인 catch 블록을 만나게 되면 해당 블록 내의 문장들을 모두 수행하고 try-catch 문을 벗어나게 된다.
	ㄴ 물론 true 인 catch 블록이 없다면 예외는 처리되지 않는다.

# 모든 예외 클래스는 Exception 클래스의 자손이기 때문에 catch 블록 안에 Exception 클래스의 참조 변수를 선언하면 모든 예외 클래스를 처리할 수 있다. ( instanceof 연산자는 같은 클래스 뿐만이 아니라 조상 클래스도 true를 반환하기 때문이다. )

public void method3() {
        try {
            System.out.println(0);
            System.out.println(1);
            System.out.println(0/0);
            System.out.println(2);
        } catch (ArithmeticException e){
            System.out.println(3);
        } catch (Exception e){
            System.out.println(4);
        }
        System.out.println(5);
}
위의 예제는 try-catch 활용 예제이다. try 블록에서 ArithmeticException 이 발생했기 때문에 catch 블록을 차례대로 검사한다.
이때 첫번째 catch 에서 검사 결과가 true 가 나왔기 때문에 해당 블록을 실행하고 try-catch 문을 벗어나게 된다.
이때 두번째 catch 블록도 검사 결과는 통과하겠지만 첫번째 블록에서 처리되기 때문에 검사되지 않는다.

다만 마지막 catch 블록에 Exception 을 선언할 경우 ArithmeticException 가 발생하지 않은 경우에도 예외를 처리할 수 있다.

- printStackTrace() 와 getMessage()
예외가 발생했을 때 생성된 예외 클래스의 인스턴스에는 발생한 예외에 대한 정보를 가지고 있다.
catch 블럭의 괄호() 에 선언된 참조 변수를 통해서 해당 인스턴스에 접근할 수 있으며, 자주 사용하는 메서드들은 하단의 정보와 같다.
- printStackTrace() : 예외 발생 당시 호출 스택 ( call Stack ) 에 있는 메서드의 정보와 예외 메세지를 화면에 출력한다.
- getMessage() : 발생한 예외 클래스의 인스턴스가 담고 있는 메세지를 얻을 수 있다.

[ 멀티 Catch 블럭 ]
JDK1.7 부터는 여러 catch 블록을 '|' 기호를 이용해서 하나의 catch 블록에 여러 개의 예외 클래스를 처리할 수 있다.
중복되는 코드가 있으면 묶을 수 있고 묶을 수 있는 클래스의 개수는 제한이 없다.
# 멀티 catch 를 잘 활용하면 코드의 중복을 없엘 수 있다.

    public void method5() {
        try {
            System.out.println("hel");

            method6();
        } catch (ArithmeticException | IOException e){
            System.out.println(e.getClass().getName());
        }
    }
	
또한 '|' 기호로 묶인 클래스 간에 상속 관계에 있다면 컴파일 에러가 발생한다.
그 이유는 상속 관계라면 부모 클래스만 적어주면 되기 때문이다.

또한 멀티 catch 블록 내에서는 어떤 예외 클래스인지 알 수 없다.
그래서 멀티 catch 블록에 있는 클래스들의 공통 조상 클래스의 멤버 변수만 사용할 수 있다.
필요하다면 instanceof 연산자를 활용해서 어떤 클래스인지 확인해서 사용할 수 있지만 비효율적이다.

또한 멀티 catch 블록 내 선언된 참조 변수 e 는 상수이므로 값을 변경할 수 없다.
그 이유는 여러 catch 블록이 하나의 참조 변수를 공유하기 때문이다.

[ 예외 던지기 ]
키워드 throw 를 활용해서 고의로 예외를 발생 시킬 수 있다.
예외를 발생시키는 방법은 다음과 같다.
1. new 연산자를 활용해서 발생하고자 하는 예외 클래스의 객체를 만든다.
2. throw 키워드를 이용해서 예외를 발생시킨다.

    private void method6() throws ArithmeticException {
        ArithmeticException e = new ArithmeticException("arithmeticException 발생하였습니다.");

        throw e;
    }
만약 예외 클래스의 생성자에 String 문자열을 넣어줄 경우에, 해당 문자열은 예외 클래스의 인스턴스의 메세지에 저장이 되며 getMessage() 메서드를 통해 확인할 수 있다.
	

하단의 예제의 경우 method07은 오류가 뜨질 않는데, method08은 예외가 발생한다.
    private void method07() {
        throw new RuntimeException();
    }

    private void method08() {
        throw new Exception();
    }
그 이유는 Exception 클래스들과 자손들은 예외가 발생할 가능성이 있을 경우 예외 처리를 꼭 해주어야 한다.
만약 그렇지 않다면 컴파일조차 되지 않을 것이다.
# 위의 코드를 컴파일하면 예외 처리를 하지 않았다는 예외 메세지가 뜬다.

반대로 RuntimeException 예외를 던지는 코드도 있고 예외 처리를 하지 않았음에도 컴파일이 되고 실행이 된다. ( 물론 프로그램이 비 정상적으로 종료된다. )
하지만 Exception 클래스와는 달리 컴파일이 된다. 그 이유는 RuntimeException 클래스와 그 자손들은 프로그래머의 실수로 발생할 수 있는 예외에 대해선 예외 처리를 필수로 하지 않았다.

# 컴파일러가 예외 처리를 확인하지 않는 RuntimeException 클래스들을 "unchecked Exception" 이라하고,
# 컴파일러가 예외 처리를 확인하는 Exception 클래스들을 "checked Exception" 이라고 한다.

[ 메서드의 예외 선언 ]
예외를 처리하는 방법에는 try-catch 뿐만이 아니라 예외를 메서드에 선언하는 방법도 있다.

메서드에 예외를 선언하는 방법은 메서드의 선언부에 키워드 throws 를 선언하고, 메서드 내에서 발생할 수 있는 예외들을 적어주기만 하면 된다.
만약 예외가 여러개라면 쉼표로 구분할 수 있다.

public void method08() throws RuntimeException , ArithmeticException {

}

위와 같이 예외 처리를 선언하면, 해당 클래스의 자손 예외 클래스도 예외가 발생할 수 있다.
만약 throws Exception 으로 선언할 경우 모든 종류의 예외가 발생할 수 있다는 뜻이다.

이렇게 메서드에 예외를 선언하면 해당 메서드를 사용하기 위해서 어떤 예외들을 처리해야 하는지 쉽게 알 수 있다.
또한 메서드 내에서 발생할 수 있는 예외를 처리하도록 강요하기 때문에 견고한 프로그램을 만들 수 있다.

public final void wait() throws InterruptedException
위의 메서드는 Object 클래스에 선언된 메서드이다.
이 메서드의 선언 부를 보면 해당 메서드는 InterruptedException 예외가 발생할 수 있으니, 예외 처리를 해주어야 한다는 것이다.
# 단 InterruptedException 예외는 Exception 클래스의 자손이므로 예외를 처리하거나 throws 로 선언한다.

RuntimeException 의 자손 클래스는 예외 처리를 하지 않아도 되기 때문에 throws 로 선언하지 않아도 된다.
# throws 에 선언해도 큰 문제는 없지만, 보통 반드시 처리해야 하는 예외 클래스만 선언한다.

그리고 throws 로 선언을 할 경우 예외 처리를 하는 것이 아니라, 자신을 호출한 클래스에게 예외를 떠넘기는 것이다.
그렇기 때문에 예외가 발생했을 때 자신을 호출한 메서드는 예외를 처리하거나 ( try-catch ) 또 예외를 던져야 ( throws ) 한다.
# 만약 main 메서드까지 거슬러 올라가면서 예외가 처리되지 않았을 경우 프로그램은 종료된다.

그러면 언제 자체적으로 처리 ( try-catch ) 하고, 언제 예외를 선언하는 것이 좋을까?
만약 예외가 발생한 메서드 내부에서 처리해도 되는 경우는 메서드 내 try-catch를 활용하고, 메서드 호출 시 넘겨받아야 하는 값을 다시 받아야 하는 경우 예외를 선언해서 외부에서 다시 처리하게 한다.

또한 예외가 발생하면 오류 스택 메세지를 통해 알 수 있는 메세지가 있다.
Exception in thread "main" java.lang.Exception
	at g_exception.TryCatchTest.method10(TryCatchTest.java:113)
	at g_exception.TryCatchTest.method09(TryCatchTest.java:109)
	at g_exception.TryCatchTest.method08(TryCatchTest.java:105)
	at g_exception.Main.main(Main.java:7)
	
위의 메세지를 보면 예외가 발생했을 때 호출 스택의 내용을 알 수 있으며, 보면 main 메서드가 method08 를 호출하고, method08이 method09를 호출하고, 마지막으로 method10 을 호출한다.
이때 method10에서 Exception 예외가 발생하여 프로그램이 비 정상적으로 종료되었다.
# 물론 try-catch 없이 예외를 선언하기만 해서 비정상적으로 종료된 것이다.

    public void method11() {
        try {
            method09();
        } catch (Exception e) {
            System.out.println("예외를 잡았습니다.");
            e.printStackTrace();
        }
    }
	
물론 다음과 같이 예외를 선언하지만 하지 않고, try-catch를 통해 처리를 해준다면 프로그램이 비 정상적으로 종료되는 일은 없다.
메세지 :
예외를 잡았습니다.
java.lang.Exception
	at g_exception.TryCatchTest.method10(TryCatchTest.java:113)
	at g_exception.TryCatchTest.method09(TryCatchTest.java:109)
	at g_exception.TryCatchTest.method11(TryCatchTest.java:118)
	at g_exception.Main.main(Main.java:7)

위의 메세지는 예외에 대한 메세지는 발생하고 있지만, 프로그램이 비정상적으로 종료된 것이 아니라, 단순히 e.printStackTrace() 를 통해 예외 발생 시점의 호출 스택을 출력한 것 뿐이다.

[ finally 블럭 ]
finally 블록은 try-catch 문가 함께 사용되며, 예외 발생 여부에 관계없이 항상 실행된다.
try-catch 블록문의 끝에 선택적으로 붙일 수 있으며 try -> catch -> finally 순으로 실행된다.
# 만약 예외가 발생하지 않는다면 try -> finally 순으로 실행된다.

finally 블록은 try문와 catch 문 안에 공통된 코드가 있을 경우 finally 코드로 뺄 수 있다.
# 즉 try 블록안에도 수행되고, catch 문 안에도 수행되는 경우에 예외에 관계없이 항상 수행되어야 한다는 뜻이다.

try {

} catch () {

} finally {

}

만약 try 블록이나 catch 블록에서 return 문이 수행되었다 하더라도 finally 문장을 먼저 수행한 다음에 메서드를 종료한다.
    public void method12(boolean flag) {
        try {
            System.out.println("1번쨰");
            if(flag) throw new Exception();
            return;
        } catch (Exception e) {
            System.out.println("3번째");
            return;
        } finally {
            System.out.println("2번째");

        }
    }
# 위의 문장은 return문을 만났지만 finally의 블록은 항상 실행된다.

[ 자동 자원 반환 try - with - resources ]
JDK1.7 부터는 try-with-resources 라는 try-catch 문의 변형이 새로 등장했으며, 이 구문은 주로 입출력 관련 클래스들을 다룰 때 유용하다.
보통 입출력 클래스들은 사용한 후에 꼭 닫아 주어야 한다.
try {
	dis = new DataInputStream(new FileInputStream("~~"))
} catch (Exception io) {
} finally {
	dis.close();
}

위의 코드는 예외의 관계 없이 입출력 클래스를 닫는 코드가 있지만, 문제는 dis.close() 에서도 예외가 발생할 수 있다.
문제는 finally 블록 안에서 예외 처리를 할 경우에 코드의 가독성이 떨어지는 문제가 있다.
또한 try 블록과 finally 블록에서 모두 예외가 발생하면 기존 try 블록의 예외는 무시되는 문제도 있다. ( 즉 try 예외는 사라지게 되고, finally 에 있는 예외 정보만 알게 될 것이다.. )


        try(FileInputStream fis = new FileInputStream("wow.txt");
            DataInputStream dis = new DataInputStream(fis)) {

            while(true) {
                score += dis.readInt();
            }

        } catch (EOFException e) {
            System.out.println("파일 조회 끝 : " + score);
        } catch (IOException e) {
            System.out.println("예외 발생");
        }
위의 예제는 try-with-resources 의 예제이다. try 블록안에 객체를 생성하는 문장을 넣으면, 해당 객체가 close() 를 호출하지 않아도, try 문을 벗어나면 자동으로 close() 가 호출된다.
그 다음 catch 블록이나 finally 블록이 실행된다.

다만 자동으로 객체의 자원을 해제하는 close()가 호출될 수 있으려면, 해당 클래스는 AutoCloseable 이라는 인터페이스를 구현한 것이어야 한다.

        try(TryWithResources twr = new TryWithResources())  {
            System.out.println("try-with-resource 실행");
            twr.method02(true);
        } catch (Exception e) {
            System.out.println("종료..");
            e.printStackTrace();
        }
		
		
public class TryWithResources implements AutoCloseable {

    public void method02(boolean flag) throws Exception {
        System.out.println("메서드가 호출되었습니다.");

        if(flag)
            throw new Exception("예외가 발생하였습니다.. ;ㅅ;");

    }

    @Override
    public void close() throws Exception {
        System.out.println("Close 가 호출되었습니다.");
        throw new Exception("이또한 예외가 발생했네요..");
    }
}

java.lang.Exception: 예외가 발생하였습니다.. ;ㅅ;
	at g_exception.TryWithResources.method02(TryWithResources.java:32)
	at g_exception.Main.main(Main.java:16)
	Suppressed: java.lang.Exception: 이또한 예외가 발생했네요..
		at g_exception.TryWithResources.close(TryWithResources.java:39)
		at g_exception.Main.main(Main.java:14)
		
위의 예제를 실행한 결과이다. 위의 메세지는 두 예외가 동시에 발생할 수 없기 떄문에 실제 발생한 예외 메서드를 method02 으로 두고, close에서 발생한 예외를 억제된 예외로 다뤄지고 있다.
만약 일반 try-catch 를 썼다면 method02 의 예외는 사라지고 close() 만 남게될 것이다.

[ 사용자 정의 예외 ]
자바에서 기본으로 제공하는 예외 클래스 외에 개발자가 필요에 따라 예외 클래스를 생성할 수 있다.
보통은 Exception 클래스를 상속 받아 클래스를 작성하지만, 다른 예외 클래스를 선택할 수 있다.

public class CustomException extends Exception {

    public CustomException(String mesg) {
        super(mesg);
    }
}
위의 예제 처럼 생성자의 매개변수로 String을 받아서 예외 메세지로 활용할 수 있다.
물론 필요에 따라 멤버 변수나 메서드를 추가할 수 있다.
물론 Exception 클래스는 Checked 예외 이기 때문에, unchecked 예외인 RuntimeException 으로 상속받아 구현하는 경우도 있다.

- Exception vs RuntimeException
기존 예외 클래스는 주로 Exception 클래스를 상속 받아서 예외 처리를 강제로 하게 되어왔다. 하지만 프로그래밍 환경이 바뀌면서 굳이 예외 처리를 꼭 하지 않아도 되게 되었다.
예를 들면 기존에는 가전기기나 데스크탑에 주로 사용되어서 견고한 프로그래밍이 필수가 되었다고 하면, 요즘엔 모바일이나 웹에 사용되면서 오히려 불필요한 예외 처리로 인해 코드의 복잡성을 더 높히게 되었다.
따라서 무조건 예외를 처리해야 하는 Exception 클래스보다, 선택적으로 예외를 처리하는 RuntimeException 이 점점 많아지고 있다.

[ 예외 되던지기 exception re-throwing ]
예외 되던지기는 예외를 처리한 메서드에서 다시 예외를 발생시켜서, 예외가 발생한 메서드와 해당 메서드를 호출한 메서드 양쪽에서 모두 예외 처리를 할 수 있게 한다.
이는 단 하나의 예외가 발생해도 두 메서드에서 모두 처리할 수 있게 한다.

우선 예외가 발생할 문장에 try 문을 통해 예외를 처리하고, catch 문에서 필요한 작업을 수행 후 throw 문을 통해서 다시 예외를 발생시키는 것이다.
그렇게 되면 이 메서드를 호출한 메서드에서는 try-catch 문을 통해 예외를 처리해야 한다.

이것은 하나의 예외에 대해 예외가 발생한 메서드와, 이를 호출 메서드 양쪽에서 처리해주어야 하는 작업이 있을 때 활용한다.
# 이때 예외가 발생한 메서드는 try-catch로 처리해도 예외를 발생시키기 때문에 throws 로 예외를 선언해야 한다.

또한 반환 값이 있을 경우에는 catch 블록에서 return 문이 있어야 한다.
혹은 catch 블록에서 다시 예외를 되던질 경우에는 return을 생략할 수 있다.

    public int method03() throws Exception {
        try {
            System.out.println("메서드1");
            return 0;
        } catch (Exception e) {
            return 1;
        }
    }
# catch 블록에서 return 문을 선언해야 하는 예제

    public int method04() throws Exception {
        try {
            System.out.println("메서드2");

            throw new Exception();
        } catch (Exception e) {
            System.out.println("메서드3");
            throw new Exception("");
        }
    }
# catch 블록에서 예외를 되던져 return 문이 생략되었다.

    public int method05() throws Exception {
        try {
            return 1;
        } catch (Exception e) {
            return 2;
        } finally {
            return 3;
        }
    }
또한 finally 블록에서도 return문을 사용할 수 있으며, try블록과 catch 블록의 return이 수행되고 나서 finally의 return문이 수행된다.
최종적으론 finally의 return문이 수행된다.
즉, 위의 예제는 3을 최종적으로 반환한다.

[ 연결된 예외 ]
한 예외는 다른 예외를 던질 수 있다. 이때 A예외가 B예외를 던질 경우, A는 B의 원인 예외 ( cause Eception ) 이라고 한다.
이렇게 예외를 그냥 처리하지 않고 원인 예외를 등록 후 다시 던지는 이유는 여러가지 예외를 하나로 묶어 다루기 위해서이다.
	ㄴ 즉, 예외가 발생했을 때 실제로 어떤 예외가 발생했고, 왜 발생했는지 알기 쉬워진다.
만약 조상 클래스를 활용해서 하나의 클래스로 처리한다면 예외 발생 원인을 쉽게 알기 힘들것이다.
	ㄴ 왜냐하면 추상적이므로, 자세하기 알기는 힘들 것이다.

try {
} catch ( SpaceException e){
	InstallException ie = new InstallException(); // 던질 예외 클래스를 생성한다.
	ie.initCause(e); // 원인 예외로 등록한다.
	throw ie;
}

또 다른 이유는 checked 예외를 unchecked 예외로 바꿀 수 있다. 
굳이 예외 처리를 필요로 하지 않는 예외를 unchecked로 바꿈으로 써, 의미없는 try-catch를 작성하지 않아도 된다.

아래의 예제는 initCause의 예제와 로그이다.
        try {
            throw new Exception("예외가 발생했습니다.");
        } catch (Exception e) {
            try {
                Exception ep = new Exception("서브서브");
                ep.initCause(e);
                throw ep;
            } catch (Exception e2) {
                RuntimeException re = new RuntimeException("굳이 catch 하지 않아도 된다.");
                re.initCause(e2);
                throw re;
            }
        }
		
Exception in thread "main" java.lang.RuntimeException: 굳이 catch 하지 않아도 된다.
	at g_exception.ExceptionReThrow.method07(ExceptionReThrow.java:74)
	at g_exception.Main.main(Main.java:25)
Caused by: java.lang.Exception: 서브서브
	at g_exception.ExceptionReThrow.method07(ExceptionReThrow.java:70)
	... 1 more
Caused by: java.lang.Exception: 예외가 발생했습니다.
	at g_exception.ExceptionReThrow.method07(ExceptionReThrow.java:67)
	... 1 more

