[ 스트림 ]
스트림은 데이터소스를 추상화하고, 데이터를 다루는데 자주 사용되는 메서드들을 정의해놓았다.
# 데이터소스를 추상화 했다는 것은, 데이터 소스가 무엇이든 간에 같은 방식으로 구현하면 된다는 것이다.
여기서 데이터 소스는 Collection ( List ) 와 배열이 될 수 있다. Collection 과 배열은 데이터 집합을 다룬다는 공통점이 있지만, 구현하는 방식이 다르다.

스트림을 활용하면 배열이나 컬렉션 뿐만 아니라 파일에 저장된 데이터도 모두 같은 방식으로 다룰 수 있다.
즉, 코드의 재활용성이 높아진다는 장점을 가지고 있다.

- 스트림의 특징
1. 스트림은 데이터 소스를 변경하지 않는다.
	ㄴ 만약 필요 시 새로운 배열을 생성해서 반환해야 한다.
2. 스트림은 일회용이다.
	ㄴ Iterator 처럼 한번 끝까지 돌았을 경우 닫혀서 다시 사용할 수 없다.
3. 스트림은 내부 반복으로 처리한다.
	ㄴ 이는 스트림에 정의된 메서드들은 for문을 메서드 내부에 숨기고 있다.
	ㄴ forEach 같은 경우 매개변수로 람다식을 받고, 내부 for문을 통해 모든 데이터들에 대해 매개변수로 넘어온 람다식을 적용한다.
4. 스트림의 연산
# 스트림에 정의된 데이터 소스를 다루는 작업을 연산이라고 한다.
스트림이 제공하는 다양한 연산을 활용해서 복잡한 작업들을 간단하게 처리할 수 있다.
이때 스트림은 중간 연산과 최종 연산으로 분류될 수 있다.
# 중간 연산 : 연산 결과가 스트림으로, 또 다른 중간 연산을 수행할 수 있다.
# 최종 연산 : 연산 결과가 스트림이 아닌 연산으로, 다른 연산을 수행할 수 없다.
# 이떄 중간 연산의 결과가 스트림이지만, 연산 전의 스트림과 같지 않다.
5. 지연된 연산
	ㄴ 스트림은 최종 연산이 수행되기 전까지 중간 연산을 수행하지 않는다.
	ㄴ 즉 중간 연산만 정의할 경우 수행되지 않는다.
6. Stream의 기본형 다루기
Stream<Integer> 로 값을 다룰 수 있지만 오토박싱&언박싱의 비 효율을 줄이기 위해 IntStream, LongStream, DoubleStream이
제공된다. IntStream은 int 값을 다루는데 효율적인 메서드를 제공한다.
7. 병렬 스트림
스트림을 활용하면 병렬 처리가 쉽다. 스트림에 parallel() 메서드를 호출하면 병렬 스트림으로 변경된다.
반대로 병렬 스트림을 다시 순차 처리하게 하려면 sequential()을 호출하면 된다.
# 스트림의 기본 값은 순차 처리이다.

[ 스트림 생성 ]
스트림은 배열, 컬렉션, 임의의 수 등 다양한 소스들로부터 스트림을 생성할 수 있다.

- 컬렉션
컬렉션의 최고 조상인 Collection 에는 stream()이 정의되어 있다. 그래서 이 컬렉션의 자손인 List와 Set을 구현한 모든 클래스는
해당 메서드를 통해 스트림을 생성할 수 있다.
하단의 stream() 메서드는 해당 컬렉션을 소스로 하는 스트림을 반환한다.
List<Integer> list = List.of(1,2,3,4,5);
Stream<Integer> stream = list.stream();
stream.forEach(System.out::println);

# forEach() 는 지정된 작업을, 스트림의 모든 요소에 대해 적용한다.

혹은 배열을 소스로 하는 스트림을 반환하는 메서드도 제공한다.
Stream<int[]> stream2 = Stream.of(new int[] {1,2,3,4,5});
IntStream stream3 = Arrays.stream(new int[] {5,6,7,8});
IntStream intStream = IntStream.of(new int[] {1,2,3,4,5});

- 특정 범위의 수
IntStream과 LongStream은 해당 범위의 연속된 숫자들을 IntStream이나 LongStream으로 반환하는 메서드가 있다.

IntStream IntStream.range(int begin, int end)
IntStream IntStream.rangeClosed(int begin, int end)
# range 는 end 범위를 포함하지 않고, rangeClosed 는 end 범위를 포함시킨다.

- 임의의 수
난수를 생성하는 java.util.Random 클래스에는 임의의 수로 이루어진 스트림을 반환한다.
IntStream ints();
LongStream longs();
DoubleStream doubles();

위의 메서드는 "무한 스트림" 으로 limit() 로 크기를 정해주지 않으면 무한 난수를 반환한다.
ints().limit(5);
혹은 limit(5); 처럼 매개변수로 값을 제공하면 5개의 난수를 반환한다.
# 위의 메서드들은 해당 자료형의 최소 값 ~ 최대 값을 랜덤 값으로 반환한다. ex ) int는 -21억 ~ 21억의 범위

ints(int begin, int end)
ints(int streamSize, int begin, int end)
위의 메서드를 통해 특정 범위의 난수를 발생시킬 수 있다.

- 람다식의 iterate(), generate()
iterate()와 generate()는 매개변수로 전달받은 람다식의 연산 결과를 다시 요소로 활용하는 "무한 스트림" 을 생성한다.

Stream<T> iterate(T seed, UnaryOperator<T> f)
iterate는 초기 값인 seed 을 시작으로, 람다식 f 에 의해 나온 값을 다시 seed 로 활용한다.
Stream.iterate(5, a -> a + 2).limit(5).forEach(System.out::println);

Stream<T> generate(Supplier<T> s)
generate도 람다식 s 의 결과를 다시 요소로 활용하는 "무한 스트림" 을 반환하지만, iterate 와는 달리 이전 요소를 활용하지 않는다.
또한 Supplier 이므로 매개변수가 없는 람다식을 제공해야 한다.

- 빈 스트림
요소가 하나도 없는 스트림은 아래의 코드를 통해 생성할 수 있다.
연산 결과가 하나도 없을 때 null 보다 비어있는 스트림이 나을 것이다.

Stream empty = Stream.empty();
long size = empty.count(); // size의 값은 0이 될것이다.

- 스트림 연결 concat()
Stream<Integer> stream_1 = Stream.iterate(0, a -> a + 2).limit(5);
Stream<Integer> stream_2 = Stream.generate(() -> 2);
Stream<Integer> stream_3 = Stream.concat(stream_1, stream_2);

2개의 스트림은 서로 연결될 수 있다. 이때 두 요소의 타입은 같아야 한다.

[ 스트림의 중간 연산 ]
스트림 자르기 - skip() , limit()
skip() 과 limit() 는 스트림에 있는 요소를 잘라낼 때 사용된다.

Stream<T> skip(long n)
Stream<T> limit(long maxSize)

skip(n)은 요소의 첫 N개를 건너뛰고, limit(n) 는 요소를 n개로 제한한다.

스트림 요소 걸러내기 - filter() , distinct()
distinct() 는 중복을 제거하는데 사용되며, filter() 는 주어진 조건에 맞지 않는 요소들을 제거한다.

Stream<T> filter(Predicate<? Super T> predicate);
Stream<T> distinct();

filter는 Predicate 인 조건식을 매개변수로 넘겨주면 되며, 해당 조건식이 true인 요소들만 남긴다.
필요한 경우 filter는 여러개 사용해도 된다.

stream_3 = stream_3.distinct().filter(a -> a % 2 == 0);
stream_3.forEach(System.out::println);

- 정렬 sorted()
스트림을 정렬할 땐 sorted를 활용하면 된다.
sorted()는 지정된 Comparator 로 정렬하는 것도 가능하며, 결과 값이 int 인 람다식도 사용 가능하다.
Comparator 를 지정하지 않으면, 기본 정렬 방식인 Comparable 을 기준으로 정렬하는데, Comparable 가 구현되어 있지 않으면
예외가 발생한다.

sort(Comparator.comparing(Student::getBan) // 만약 기본형인 경우 comparingInt 를 사용하면 좋다.
	.thenComparing(Student::getScore)
	.thenComparing(Student::getName)
위의 코드는 정렬에 기본적인 메서드인 comparing 을 사용하여 정렬한다.
추가 정렬 기준을 제공할 땐 thenComparing 를 사용한다.

- 변환 map()
스트림 요소 값을 변환하기 위해 사용한다.
map()은 저장된 요소 값 중에서 특정 필드만 추출하거나, 특정 형태 ( 소문자를 대문자 ) 로 바꾸어야 할 때 사용된다.

Stream<R> map(Function<? super T,? extends R> mapper)

예를 들어 File 클래스를 요소로 하는 스트림에서 File의 이름만 추출할 때 사용할 수 있다.
이때 Stream<File> 의 결과 값은 Stream<String> 이 된다.
# ex) file.map(File::getName)

- 조회 peek()
peek()는 forEach()와 달리 중간 연산자로 반환 값이 Stream 이다.
filter 와 map 의 중간 연산 결과를 확인할 때 사용된다.

- mapToInt() , mapToLong() , mapToDouble()
map의 연산 결과는 Stream<T> 으로, 만약 Stream<Integer> 으로 변환해야 한다면 IntStream 를 사용하는 것이 더 효율적이다.
이러한 기본형 스트림으로 변환해주는 메서드들이 mapToInt() , mapToLong() , mapToDouble() 이다.
# Stream<Integer> 의 경우 오토박싱&언박싱으로 인해서 성능이 저하될 수 있다.

위의 메서드들은 int sum() , OptionalInt min() , OptionalInt max() , OptionalDouble average() , IntSummaryStatistics summaryStatistics() 처럼, 정수형을 다루는데 편리한 메서드들을 제공한다.
그리고 이 메서드들은 최종 연산이기 때문에 이 메서드를 사용 후에 스트림은 닫힌다.
# sum()은 요소가 없을 때 0을 반환하지만, min 과 max, average 는 요소가 있어도 0 이 나올 수 있기 떄문에 이를 구분하기 위해 Optional 을 쓴다.
# 위의 메서드들은 IntStream 의 기준으로, DoubleStream 과 LongStream 도 메서드를 제공한다. ( 반환 타입은 다름 )

- flatMap() Stream<T[]> 을 Stream<T> 으로 변환
스트림의 요소가 Stream<T[]> 인 경우 Stream<T> 으로 변환하기 위해서 flatMap을 사용할 수 있다.
보통 Stream<String[]> 을 Stream<String> 으로 , Stream<Stream<String>> 을 Stream<String> 으로 변환하기 위해 사용한다.

Stream<String[]> flatMapStream = Stream.of(
	new String[] {"hello" , "nice" , "to" , "meet" , "you"},
	new String[] {"my" , "name" , "is" , "chicky~"}
);
Stream<String> newFlatMapStream = flatMapStream.flatMap(Arrays::stream);

# 위의 Arrays.stream 은 배열을 Stream 으로 바꾼다.

[ Optional<T> 와 OptionalInt ]
Optional<T> 은 제네릭 클래스로, T 타입의 객체를 감싸는 래퍼 클래스이다.
Optional 클래스 내부에 정의된 메서드를 활용하여 NullPointException에 안전한 코드를 작성할 수 있다.

- Optional 객체 생성
Optional.of(T data) : Optional 객체를 생성한다. 만약 매개변수 값이 null 일 경우 NullPointException를 발생시킨다.
Optional.ofNullable() : Optional 객체를 생성한다.
Optional.empty() : 기본값으로 초기화한 Optional 객체 생성

- Optional 값 가져오기
System.out.println(optional.get())	: Optional 객체 내부에 저장된 값을 가져온다. 값이 없다면 NoSuchElementException 이 발생한다.
System.out.println(optional2.orElse("empty String")) : Optional 객체 내부에 저장된 값을 가져온다. 값이 없을 경우 매개변수로 전달된 값을 제공한다.

System.out.println(optional2.orElseGet(() -> "default String"))	: 값이 없을 경우 람다식에 지정된 값을 가져온다.
System.out.println(optional2.orElseThrow(NullPointerException::new)) : 값이 없을 경우 지정된 예외를 발생시킨다.

# 하단에서 처럼 Optional 도 Stream 처럼 map이나 flatMap, filter 를 적용할 수 있다.
String result = optional.map(String::toUpperCase).orElse("default String");

Optional.isPresent() : 객체 내부의 값이 null 이면 false, 있으면 true 를 반환한다.
if(!emptyOptional.isPresent()) {
	system.out.println("is empty");
}

optional.ifPresent(System.out::println) : Optional 객체 내부의 값이 존재한다면 내부 값을 출력한다.

- OptionalInt , OptionalDouble , OptionalLong
IntStream 과 같은 기본형 스트림은 기본형을 값으로 하는 OptionalInt 을 반환한다.
이는 Stream에서 제공하는 메서드 중 반환 타입이 다르다는 것을 제외하면 비슷하다.

그리고 OptionalInt 에서 값을 가져오는 메서드도 조금씩 다르다.
Optional 클래스의 값을 가져오는 메서드는 get() 이지만 , OptionalInt 의 값을 가져오는 메서드는 getAsInt() 이다.
OptionalLong 의 값을 가져오는 메서드는 getAsLong , OptionalDouble 은 getAsDouble 이 된다.

OptionalInt optionalInt = OptionalInt.of(0);
System.out.println(optionalInt.getAsInt());

# 기본형 스트림은 기본 값이 0 이기 떄문에 값이 없는 것과 0 인 것에 대한 차이는 isPresent 변수로 구분한다.

[ 최종 연산 스트림 ]
최종 연산은 스트림 요소를 소모하며 결과를 만들어 내기 때문에 다른 스트림을 호출할 수 없다.
최종 연산의 결과로는 단일 값 혹은 배열일 수도 있다..

- forEach()
void forEach() 는 최종 연산으로 반환 값은 void 이다.
그렇기 때문에 보통 출력을 위해서 사용한다.

- allMatch(), anyMatch() , noneMatch() , findFirst() , findAny()
스트림의 요소 중 주어진 조건에 일치하는 요소가 있는지 확인한다.
allMatch 와 anyMatch , noneMatch 는 매개변수로 Predicate 메서드를 받으며 결과로는 boolean을 반환한다.
이 메서드들은 요소들이 모두 해당 조건에 만족하는지 , 아니면 해당 조건에 만족하는 요소가 하나라도 있는지, 하나도 없는지 나타낸다.

findFirst() 는 조건에 일치하는 요소 중 첫번 째 요소를 반환하며, 주로 filter()와 함께 사용된다.
병렬 스트림의 경우 findAny()를 사용한다.
이 메서드들은 연산 결과라 Optional<> 로 결과가 빈값이면 빈 Optional 을 반환한다.

- 통계 count() , sum() , average() , min() , max()
IntStream과 같은 기본형 스트림은 요소에 대한 통계 정보를 알 수 있는 메서드들을 제공한다.

일반 Stream인 경우 통계와 관련된 메서드는 count() , min() , max() 밖에 없다.
보통 통계 정보를 얻기 위해서 기본형 스트림으로 변환하거나 reduce() 나 collect() 를 사용한다.

- reduce() 리듀싱
리듀싱은 스트림에 있는 요소를 줄여가면서 연산을 수행하고 최종 결과를 반환한다.
처음 두 요소를 연산하고, 그 결과를 가지고 다음 요소를 가지고 연산을 수행한다.

Optional<t> reduce(BinaryOperator<T> accumulator)

T reduce(T identity, BinaryOperator<T> accumulator);
U reduce(U identity, BiFunction<U,T,V> accumulator, BinaryOperator<U> combiner);
그 외에도 초기값을 가지는 reduce() 가 있는데, 이는 초기 값을 기준으로 스트림의 첫번 째 요소와 연산을 수행한다.
만약 요소가 비어 있으면 초기 값을 반환한다.

# combiner 는 병렬 스트림에 의해 처리된 결과를 합칠 때 사용한다.

위의 통계 메서드 count() 나 sum() 등은 이러한 reduce() 를 통해서 구현된 것이다.

int[] maps = {1,2,3,4,5};
IntStream intStream = Arrays.stream(maps);
int result = intStream.reduce(0 , (a , b) -> a + b);
System.out.println(result);

- collect()
collect() 는 스트림의 요소를 특정 기준으로 수집하는 최종 연산이다.
collect() 가 어떤 기준으로 요소를 수집할 것인지 기준을 세우는 것이 collector이다.
collector 는 Collector 인터페이스를 구현한 것이며, Collectors 클래스는 미리 작성된 다양한 collector 들을 static 메서드로 제공한다.

- collect() : 스트림의 메서드
- Collector : 인터페이스로 컬렉터는 해당 인터페이스를 구현해야 한다.
- Collectors : static 메서드로 미리 정의된 컬렉터들을 제공한다.

collect() 는 매개변수로 Collector 객체를 요구한다.
Object collect(Collector collector);

- 스트림을 컬렉션과 배열로 반환 toList() , toSet() , toMap() , toCollection() , toArray()
스트림에 모든 요소를 컬렉션에 수집하려면 Collectors 클래스의 toList() 메서드를 활용하면 된다.
만약 특정 컬렉션에 저장하고 싶다면 toCollection 메서드에 해당 컬렉션의 생성자 참조를 매개변수에 제공하면 된다.

List<Integer> streamToList = streamer.collect(Collectors.toList());
ArrayList<Integer> streamToArrayList = streamer.collect(Collectors.toCollection(ArrayList::new));

Map 같은 경우 키와 값을 하나의 쌍으로 지정해야 하므로, 데이터 중 어떤 필드를 키와 값으로 지정할 것인지를 지정해야 한다.
Map<String, Integer> map = streamer.collect(Collectors.toMap(p -> p + "" , p -> p));

스트림의 요소를 배열로 변환하려면 toArray() 를 사용하면 된다.
이때 해당 타입의 생성자 참조를 매개변수로 지정해야 한다. 그렇지 않으면 반환 타입은 Object[] 가 된다.
Object[] resource = streamer.toArray();
Integer[] resource_2 = streamer.toArray(Integer[]::new);

- 통계 counting() summingInt() , averagingInt() , maxBy() , minBy()

다른 최종 연산들이 제공하는 통계 메서드를 collect() 에서도 제공한다.

int sum_test = streamer.collect(Collectors.summingInt(Integer::intValue));
System.out.println(sum_test);

단순히 통계 데이터만 필요할 때 다른 최종 연산자인 sum() 을 사용하지만, 해당 메서드들은 groupingBy() 와 함께 사용된다.
groupingBy() 을 사용하지 않는다면 굳이 귀찮게 collect() 를 써가면서 까지 사용할 필요는 없다.

- 리듀싱 - reducing()
collect 에서도 리듀싱이 가능하다. 단 IntStream 은 boxed() 를 통해 Stream<Integer> 로 변환해서 사용해야 매개변수 1개짜리 collect()를 사용할 수 있다.
# IntStream 에는 매개변수 3개짜리 collect() 밖에 없다.

int sum_test = streamer.collect(Collectors.reducing((a, b) -> a + b)).get();
int sum_test = streamer.collect(Collectors.reducing(0, (a, b) -> a + b));

- 문자열 결합 - joining()
문자열 스트림에 모든 요소를 결합하여 하나의 문자열로 반환한다.
이때 스트림의 요소가 CharSequance 의 자손인 경우에만 결합이 가능하므로 ( String , StringBuffer 등등.. ) map() 을 통해서 문자열로 반환해야 한다.
그렇지 않으면 toString()을 통해 나온 문자열을 기반으로 결합을 진행한다.

# 아래 예제처럼 구분자와 접미사, 접두사를 지정해줄 수 있다.
String result_2 = streamer.map(String::valueOf).collect(Collectors.joining("," ,"[" , "]"));
System.out.println(result_2);

[ 그룹화와 분할 - groupingBy , partitioningBy ]
그룹화인 groupingBy는 스트림의 요소를 특정 기준으로 그룹화하는 것을 의미하고, 분할ㅇ은 스트림의 요소를 2가지 ( 지정된 조건에 만족하는 그룹과 그렇지 않은 그룹 ) 으로 분할한다.
groupingBy 는 Function 으로 , partitioningBy는 Predicate 로 분류한다
# 사실 분류를 Function 으로 하냐 , Predicate 로 하냐의 차이만 있을 뿐이다.

스트림을 2개의 그룹으로 나누어야 한다면 partitioningBy 을 사용하는 것이 더 빠르며, 그렇지 않은 경우는 groupingBy 를 사용하는 것이 낫다.
그룹화와 분할의 결과는 Map에 담겨 반환한다.

- partitioningBy 에 의한 분류

# 짝수, 홀수로 분류
Map<Boolean, List<Integer>> result_grouping= streamer.collect(Collectors.partitioningBy(x -> x % 2 == 0));
System.out.println(result_grouping); // {false=[1, 3, 5, 41, 21, 51], true=[2, 4, 10, 62]}

# 해당 요소의 개수
Map<Boolean, Long> result_grouping= streamer.collect(Collectors.partitioningBy(x -> x % 2 == 0,
                Collectors.counting()
)); // {false=6, true=4}

# 해당 요소의 최대값
Map<Boolean, Integer> result_grouping= streamer.collect(Collectors.partitioningBy(x -> x % 2 == 0,
	Collectors.collectingAndThen(Collectors.maxBy(Integer::compareTo), Optional::get)
)); // {false=51, true=62}

# 이중 분할 ( 짝수 홀수 / 30 이상인지 아닌지 )
Map<Boolean, Map<Boolean, List<Integer>>> result_grouping= streamer.collect(Collectors.partitioningBy(x -> x % 2 == 0,
	Collectors.partitioningBy(x -> x > 30)
)); // {false={false=[1, 3, 5, 21], true=[41, 51]}, true={false=[2, 4, 10], true=[62]}}

- groupingBy 에 의한 분류

# 1 , 2 , 3 의 배수로 나누기
Map<Integer, List<Integer>> result_grouping = streamer.collect(
        Collectors.groupingBy((a) -> a % 3 , Collectors.toList())
);
System.out.println(result_grouping); // {0=[3, 21, 51], 1=[1, 4, 10], 2=[2, 5, 41, 62]}

# 몇의 배수인지 문자열로 나타내기.
Map<String, List<Integer>> result_grouping = streamer.collect(
                Collectors.groupingBy(s -> {
                    if(s % 3 == 0) return "3의 배수";
                    if(s % 3 == 1) return "1의 배수";
                    if(s % 3 == 2) return "2의 배수";
                    return "";
                } , Collectors.toList())
        );
        System.out.println(result_grouping); // {2의 배수=[2, 5, 41, 62], 3의 배수=[3, 21, 51], 1의 배수=[1, 4, 10]}


# 3의 배수로 분류 후 2의 배수로 분류하기
        Map<Integer, Map<Integer, List<Integer>>> result_grouping = streamer.collect(
                Collectors.groupingBy((a) -> a % 3 ,
                        Collectors.groupingBy((a) -> a % 2 , Collectors.toList()))
        );
        System.out.println(result_grouping); // {0={1=[3, 21, 51]}, 1={0=[4, 10], 1=[1]}, 2={0=[2, 62], 1=[5, 41]}}

[ Collector의 구현 ]