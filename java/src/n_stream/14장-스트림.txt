[ 스트림 ]
스트림은 데이터소스를 추상화하고, 데이터를 다루는데 자주 사용되는 메서드들을 정의해놓았다.
# 데이터소스를 추상화 했다는 것은, 데이터 소스가 무엇이든 간에 같은 방식으로 구현하면 된다는 것이다.
여기서 데이터 소스는 Collection ( List ) 와 배열이 될 수 있다. Collection 과 배열은 데이터 집합을 다룬다는 공통점이 있지만, 구현하는 방식이 다르다.

스트림을 활용하면 배열이나 컬렉션 뿐만 아니라 파일에 저장된 데이터도 모두 같은 방식으로 다룰 수 있다.
즉, 코드의 재활용성이 높아진다는 장점을 가지고 있다.

- 스트림의 특징
1. 스트림은 데이터 소스를 변경하지 않는다.
	ㄴ 만약 필요 시 새로운 배열을 생성해서 반환해야 한다.
2. 스트림은 일회용이다.
	ㄴ Iterator 처럼 한번 끝까지 돌았을 경우 닫혀서 다시 사용할 수 없다.
3. 스트림은 내부 반복으로 처리한다.
	ㄴ 이는 스트림에 정의된 메서드들은 for문을 메서드 내부에 숨기고 있다.
	ㄴ forEach 같은 경우 매개변수로 람다식을 받고, 내부 for문을 통해 모든 데이터들에 대해 매개변수로 넘어온 람다식을 적용한다.
4. 스트림의 연산
# 스트림에 정의된 데이터 소스를 다루는 작업을 연산이라고 한다.
스트림이 제공하는 다양한 연산을 활용해서 복잡한 작업들을 간단하게 처리할 수 있다.
이때 스트림은 중간 연산과 최종 연산으로 분류될 수 있다.
# 중간 연산 : 연산 결과가 스트림으로, 또 다른 중간 연산을 수행할 수 있다.
# 최종 연산 : 연산 결과가 스트림이 아닌 연산으로, 다른 연산을 수행할 수 없다.
# 이떄 중간 연산의 결과가 스트림이지만, 연산 전의 스트림과 같지 않다.
5. 지연된 연산
	ㄴ 스트림은 최종 연산이 수행되기 전까지 중간 연산을 수행하지 않는다.
	ㄴ 즉 중간 연산만 정의할 경우 수행되지 않는다.
6. Stream의 기본형 다루기
Stream<Integer> 로 값을 다룰 수 있지만 오토박싱&언박싱의 비 효율을 줄이기 위해 IntStream, LongStream, DoubleStream이
제공된다. IntStream은 int 값을 다루는데 효율적인 메서드를 제공한다.
7. 병렬 스트림
스트림을 활용하면 병렬 처리가 쉽다. 스트림에 parallel() 메서드를 호출하면 병렬 스트림으로 변경된다.
반대로 병렬 스트림을 다시 순차 처리하게 하려면 sequential()을 호출하면 된다.
# 스트림의 기본 값은 순차 처리이다.

[ 스트림 생성 ]
스트림은 배열, 컬렉션, 임의의 수 등 다양한 소스들로부터 스트림을 생성할 수 있다.

- 컬렉션
컬렉션의 최고 조상인 Collection 에는 stream()이 정의되어 있다. 그래서 이 컬렉션의 자손인 List와 Set을 구현한 모든 클래스는
해당 메서드를 통해 스트림을 생성할 수 있다.
하단의 stream() 메서드는 해당 컬렉션을 소스로 하는 스트림을 반환한다.
List<Integer> list = List.of(1,2,3,4,5);
Stream<Integer> stream = list.stream();
stream.forEach(System.out::println);

# forEach() 는 지정된 작업을, 스트림의 모든 요소에 대해 적용한다.

혹은 배열을 소스로 하는 스트림을 반환하는 메서드도 제공한다.
Stream<int[]> stream2 = Stream.of(new int[] {1,2,3,4,5});
IntStream stream3 = Arrays.stream(new int[] {5,6,7,8});
IntStream intStream = IntStream.of(new int[] {1,2,3,4,5});

- 특정 범위의 수
IntStream과 LongStream은 해당 범위의 연속된 숫자들을 IntStream이나 LongStream으로 반환하는 메서드가 있다.

IntStream IntStream.range(int begin, int end)
IntStream IntStream.rangeClosed(int begin, int end)
# range 는 end 범위를 포함하지 않고, rangeClosed 는 end 범위를 포함시킨다.

- 임의의 수
난수를 생성하는 java.util.Random 클래스에는 임의의 수로 이루어진 스트림을 반환한다.
IntStream ints();
LongStream longs();
DoubleStream doubles();

위의 메서드는 "무한 스트림" 으로 limit() 로 크기를 정해주지 않으면 무한 난수를 반환한다.
ints().limit(5);
혹은 limit(5); 처럼 매개변수로 값을 제공하면 5개의 난수를 반환한다.
# 위의 메서드들은 해당 자료형의 최소 값 ~ 최대 값을 랜덤 값으로 반환한다. ex ) int는 -21억 ~ 21억의 범위

ints(int begin, int end)
ints(int streamSize, int begin, int end)
위의 메서드를 통해 특정 범위의 난수를 발생시킬 수 있다.

- 람다식의 iterate(), generate()
iterate()와 generate()는 매개변수로 전달받은 람다식의 연산 결과를 다시 요소로 활용하는 "무한 스트림" 을 생성한다.

Stream<T> iterate(T seed, UnaryOperator<T> f)
iterate는 초기 값인 seed 을 시작으로, 람다식 f 에 의해 나온 값을 다시 seed 로 활용한다.
Stream.iterate(5, a -> a + 2).limit(5).forEach(System.out::println);

Stream<T> generate(Supplier<T> s)
generate도 람다식 s 의 결과를 다시 요소로 활용하는 "무한 스트림" 을 반환하지만, iterate 와는 달리 이전 요소를 활용하지 않는다.
또한 Supplier 이므로 매개변수가 없는 람다식을 제공해야 한다.

- 빈 스트림
요소가 하나도 없는 스트림은 아래의 코드를 통해 생성할 수 있다.
연산 결과가 하나도 없을 때 null 보다 비어있는 스트림이 나을 것이다.

Stream empty = Stream.empty();
long size = empty.count(); // size의 값은 0이 될것이다.

- 스트림 연결 concat()
Stream<Integer> stream_1 = Stream.iterate(0, a -> a + 2).limit(5);
Stream<Integer> stream_2 = Stream.generate(() -> 2);
Stream<Integer> stream_3 = Stream.concat(stream_1, stream_2);

2개의 스트림은 서로 연결될 수 있다. 이때 두 요소의 타입은 같아야 한다.

[ 스트림의 중간 연산 ]
스트림 자르기 - skip() , limit()
skip() 과 limit() 는 스트림에 있는 요소를 잘라낼 때 사용된다.

Stream<T> skip(long n)
Stream<T> limit(long maxSize)

skip(n)은 요소의 첫 N개를 건너뛰고, limit(n) 는 요소를 n개로 제한한다.

스트림 요소 걸러내기 - filter() , distinct()
distinct() 는 중복을 제거하는데 사용되며, filter() 는 주어진 조건에 맞지 않는 요소들을 제거한다.

Stream<T> filter(Predicate<? Super T> predicate);
Stream<T> distinct();

filter는 Predicate 인 조건식을 매개변수로 넘겨주면 되며, 해당 조건식이 true인 요소들만 남긴다.
필요한 경우 filter는 여러개 사용해도 된다.

stream_3 = stream_3.distinct().filter(a -> a % 2 == 0);
stream_3.forEach(System.out::println);

- 정렬 sorted()
스트림을 정렬할 땐 sorted를 활용하면 된다.
sorted()는 지정된 Comparator 로 정렬하는 것도 가능하며, 결과 값이 int 인 람다식도 사용 가능하다.
Comparator 를 지정하지 않으면, 기본 정렬 방식인 Comparable 을 기준으로 정렬하는데, Comparable 가 구현되어 있지 않으면
예외가 발생한다.

sort(Comparator.comparing(Student::getBan) // 만약 기본형인 경우 comparingInt 를 사용하면 좋다.
	.thenComparing(Student::getScore)
	.thenComparing(Student::getName)
위의 코드는 정렬에 기본적인 메서드인 comparing 을 사용하여 정렬한다.
추가 정렬 기준을 제공할 땐 thenComparing 를 사용한다.

- 변환 map()
스트림 요소 값을 변환하기 위해 사용한다.
map()은 저장된 요소 값 중에서 특정 필드만 추출하거나, 특정 형태 ( 소문자를 대문자 ) 로 바꾸어야 할 때 사용된다.

Stream<R> map(Function<? super T,? extends R> mapper)

예를 들어 File 클래스를 요소로 하는 스트림에서 File의 이름만 추출할 때 사용할 수 있다.
이때 Stream<File> 의 결과 값은 Stream<String> 이 된다.
# ex) file.map(File::getName)

- 조회 peek()
peek()는 forEach()와 달리 중간 연산자로 반환 값이 Stream 이다.
filter 와 map 의 중간 연산 결과를 확인할 때 사용된다.

- mapToInt() , mapToLong() , mapToDouble()
map의 연산 결과는 Stream<T> 으로, 만약 Stream<Integer> 으로 변환해야 한다면 IntStream 를 사용하는 것이 더 효율적이다.
이러한 기본형 스트림으로 변환해주는 메서드들이 mapToInt() , mapToLong() , mapToDouble() 이다.
# Stream<Integer> 의 경우 오토박싱&언박싱으로 인해서 성능이 저하될 수 있다.

위의 메서드들은 int sum() , OptionalInt min() , OptionalInt max() , OptionalDouble average() , IntSummaryStatistics summaryStatistics() 처럼, 정수형을 다루는데 편리한 메서드들을 제공한다.
그리고 이 메서드들은 최종 연산이기 때문에 이 메서드를 사용 후에 스트림은 닫힌다.
# sum()은 요소가 없을 때 0을 반환하지만, min 과 max, average 는 요소가 있어도 0 이 나올 수 있기 떄문에 이를 구분하기 위해 Optional 을 쓴다.
# 위의 메서드들은 IntStream 의 기준으로, DoubleStream 과 LongStream 도 메서드를 제공한다. ( 반환 타입은 다름 )

- flatMap() Stream<T[]> 을 Stream<T> 으로 변환
스트림의 요소가 Stream<T[]> 인 경우 Stream<T> 으로 변환하기 위해서 flatMap을 사용할 수 있다.
보통 Stream<String[]> 을 Stream<String> 으로 , Stream<Stream<String>> 을 Stream<String> 으로 변환하기 위해 사용한다.

Stream<String[]> flatMapStream = Stream.of(
	new String[] {"hello" , "nice" , "to" , "meet" , "you"},
	new String[] {"my" , "name" , "is" , "chicky~"}
);
Stream<String> newFlatMapStream = flatMapStream.flatMap(Arrays::stream);

# 위의 Arrays.stream 은 배열을 Stream 으로 바꾼다.