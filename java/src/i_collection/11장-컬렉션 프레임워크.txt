[ 컬렉션 프레임워크 ]
컬렉션 프레임워크는 데이터 그룹을 저장하는 클래스들을 표준화한 설계라고 한다.
여기서 컬렉션은 데이터 그룹, 프레임워크는 표준화된 프로그래밍을 뜻한다.

# 여기서 표준화는 기준을 설정하고 이에 따른다는 뜻이다.
# JDK1.2 전에는 컬렉션 프레임워크가 없어서 컬렉션 클래스들을 각자 방식에 따라 따로 구현해야 했었다.

컬렉션 프레임워크는 데이터 그룹을 3개로 나뉘었다. ( List, Set, Map )
그 중 List와 Set은 공통된 부분이 많아 이러한 부분을 Collection 인터페이스에 분리 후 이를 상속받게 했다.
List의 특징 : 순서가 있으며, 중복을 허용하는 데이터 집합
	ㄴ ex) ArrayList, LinkedList, Vector, Stack
Set의 특징 : 순서가 없으며, 중복을 허용하지 않는 데이터 집합
	ㄴ ex) HashSet, TreeSet
Map의 특징 : 순서가 없으며 Key와 Value의 쌍으로 이루어진 집합, Key는 중복을 허용하지 않으며 Value는 중복을 허용한다.
	ㄴ ex) HashMap, TreeMap, Hashtable, Properties

컬렉션 프레임워크에 모든 클래스드는 List와 Set, Map 중에 하나를 구현하고 있으며, 구현된 인터페이스의 이름을 가지고 있다.
	ㄴ 예를 들면 HashSet은 Set을 구현했고, HashMap은 Map을 구현했고, ArrayList는 List를 구현했다.
그러나 Vector와 Stack, Hashtable과 Properties 는 컬렉션 프레임워크가 나오기 전에 호환을 위해 남겨둔 클래스이므로,
되도록이면 ArrayList나 HashMap 으로 사용하는 것이 좋다.
# Vector와 Stack, Hashtable과 Properties 는 컬렉션 프레임워크가 나오기 전에 나온 클래스 이므로, 컬렉션 프레임워크의 명명 규칙에 적용되지 않았다.

- Collection인터페이스
Collection 인터페이스는 컬렉션 클래스 내에 데이터 그룹을 읽고, 추가하고, 삭제하는 등 데이터 그룹을 다루는데 가장 기본적인 메서드들을 제공한다.
반환 타입이 boolean인 경우, 메서드의 작업이 성공하거나 변경되거나, 사실이면 true를 반환하게 된다.
	ㄴ boolean add(E o) // 데이터의 추가가 성공하면 true
	ㄴ boolean isEmpty() // 데이터가 비어있으면 true
	ㄴ boolean retainAll(E o) // 데이터가 변경되었으면 true
또한 반환 타입이 E 인 것은 지네릭스로 특정 타입을 의미한다.

- List인터페이스
List 인터페이스는 중복을 허용하고, 순서가 유지되는 컬렉션들을 구현할 때 사용된다.
List 인터페이스의 상속 계층도는 다음과 같다.

		List
Vector	ArrayList	LinkedList
Stack

- Set인터페이스
Set 인터페이스는 중복을 허용하지 않고, 순서가 없는 컬렉션 클래스를 구현하는 데 사용된다.
Set 인터페이스의 상속 계층도는 다음과 같다.

		Set
HashSet	SortedSet
		TreeSet

- Map인터페이스
Map 인터페이스는 키와 값을 하나의 쌍으로 묶어서 저장하는 컬렉션 클래스를 구현하는 데 사용된다.
Key는 중복을 허용하지 않지만, Value는 중복을 허용한다. 만약 중복된 Key를 저장할 경우, 기존의 Value는 사라지고 새로 저장하는 Value가 저장된다.
Map 인터페이스의 상속 계층도는 다음과 같다.

			Map
Hashtable	HashMap			SortedMap
			LinkedHashMap	TreeMap

- Map.Entry 인터페이스
Map.Entry 인터페이스는 Map 인터페이스의 내부 인터페이스로, Map 인터페이스를 구현하는 클래스는 Map.Entry 인터페이스도 함께 구현해야 한다.
Map.Entry 인터페이스는 Map에 저장된 key-value 값을 다루기 위한 인터페이스다.

[ ArrayList ]
ArrayList는 컬렉션 프레임워크 중 가장 많이 사용되는 컬렉션 클래스이다.
ArrayList는 List 인터페이스를 구현하기 때문에 정보의 순서가 유지되고, 중복을 허용한다.

ArrayList는 내부적으로 Object 배열을 가지고 있다.
그리고 데이터가 추가될 때 마다 해당 배열의 0번째 부터 순차적으로 데이터를 적재한다.
만약 배열의 크기가 모자를 경우, 더 큰 배열을 새로 생성한 다음 값을 복사해서 새로운 배열을 얻는다.
# 따라서 ArrayList 객체를 생성할 때, 저장될 요소의 갯수를 고려하여 넉넉한 크기로 객체를 만들어야 한다. 물론 크기가 부족하면 배열의 길이를 늘리겠지만 처리 시간이 더 소요된다.

ArrayList ar = new ArrayList();
위의 코드는 ArrayList를 생성하는 코드이다.
생성자에 정수값을 적지 않으면, 크기가 10인 배열을 생성한다.
만약 생성자에 정수 값 ( new ArrayList(100); ) 을 넣는다면 해당 정수 값에 해당하는 크기의 배열을 만든다.


ArrayList를 사용할 때 주의할 점은 ArrayList의 remove() 메서드는 중간의 자료가 삭제될 때 빈 공간을 채우기 위해, 해당 index 뒤에 있는 자료들은 하나씩 왼쪽으로 이동한다.
        ArrayList<Integer> ar = new ArrayList<>();
        ar.add(1);
        ar.add(2);
        ar.add(2);
        ar.add(3);
        for(int i = 0; i < ar.size(); i++){
            if(ar.get(i) % 2 == 0) {
                ar.remove(i);
            }
        }
        System.out.println(ar);
위의 예제는 요소가 짝수이면 제거하는 코드인데, 예상대로라면 마지막 출력이 [1,3] 이 나와야 하지만, [1,2,3]이 나온다.
그 이유는 1번째 요소인 2가 제거되면서, 2번째 위치에 있는 요소가 1번째 위치로 당겨져서 검사를 하지 않게 된다.

- ArrayList vs Vector
ArrayList는 Vector를 개선한 것으로, 구현원리와 기능적인 측면에서는 동일하다고 볼 수 있다.
다만 Vector는 JDK1.2 이전, 컬렉션 프레임워크가 탄생하기 전에 이미 존재했던 컬렉션 클래스이고, 호환을 위해 남겨두었기 때문에 되도록이면 ArrayList를 사용하는 것이 좋다.

Vector 의 메서드인 setSize() 와 trimToSize() , ensureCapacity() 와 같은 메서드는 조건에 따라 새로운 배열을 만든다.
# setSize(int) // 배열 내 데이터의 갯수를 조정한다. 
# trimToSize() // 배열의 빈 공간을 제거한다. ( 즉, 배열 내 요소가 3개일 때 배열의 크기를 3으로 조정한다. )
# ensureCapacity(int) // 객체 배열의 크기를 조정한다.
# 여기서 배열의 크기 ( size ) 와 객체 배열의 크기 ( capacity ) 는 차이가 있다. 배열의 크기는 현재 객체 배열에 저장된 요소의 갯수이며, 객체 배열의 크기 ( capacity ) 는 객체가 들어갈 수 있는 공간의 갯수이다. ) 

Vector 같은 경우 Object 배열 내부의 크기가 부족할 경우, 기존 크기의 2배인 새로운 배열을 만든다.
이처럼 Vector와 ArrayList와 같이 배열을 이용한 자료구조는 데이터의 조회와 저장은 효율이 좋지만, 배열의 용량이 부족하여 새로운 배열이 만들어질 때에는 효율이 떨어진다는 단점을 가지고 있다.
# 그 이유는 새로운 배열을 생성한 후, 기존 배열로부터 데이터를 가지고 와야 하기 때문이다.
또 다른 단점은 객체 배열 중간에 데이터를 추가하거나 삭제할 때 데이터의 이동이 필요하기 때문에 성능이 떨어진다.

정리
ArrayList와 Vector는 데이터의 조회 ( 접근 시간 ) 는 성능이 빠르지만, 비 순차적인 데이터의 저장 및 삭제의 경우 성능이 떨어진다.
그리고 배열의 크기를 변경할 수 없어서, 배열의 크기를 변경할 경우 새로운 배열을 만들어야 하는데, 그렇다고 미리 큰 배열을 만들면 메모리 낭비가 될 수 있다.
# 만약 데이터를 늘 순차적으로 저장하고, 저장된 데이터의 뒤에서 부터 삭제할 경우 빠르겠지만 이러한 경우는 별로 없다.

[ LinkedList ]
위와 같은 단점을 극복하고자 LinkedList가 고안되었다.
연속적으로 배치된 배열과는 달리 LinkedList는 불연속적이며, 각각의 데이터들을 서로 연결하고 있다.
각각의 노드에 대해서는 데이터 값과 다음 노드의 참조 ( 주소값 ) 을 가지고 있다.
Class Node {
	Object value;
	Node next;
}
Node1 -> Node2 -> Node3 ...

링크드 리스트를 추가하거나, 삭제할 때 데이터의 이동이 아니라 링크만 바꿔주면 되기 때문에 성능이 빠르다.
# 삭제의 경우 삭제 노드의 이전 노드를 삭제 노드의 다음 노드만 연결해주면 된다.
# 추가의 경우 추가되는 위치의 노드를 새 노드에 연결하고, 새 노드의 next 를 다음 노드에 연결해주면 된다.

- 이중 연결리스트 double linkedlist
기존 LinkedList는 단 방향으로 이동하기 떄문에, 이전 데이터로 돌아갈 수 없다는 특징을 가지고 있다.
그러한 단점을 극복하고자, 이전으로 가는 링크를 하나 더 추가한 것이다.
즉, 링크드 리스트에 이전 요소로 가기 위한 링크가 하나 더 있는 것이다.
Class Node {
	Object value;
	Node next;
	Node prev;
}

- 원형 이중 연결리스트 double circular linkedlist
이중 연결리스트의 시작과 끝을 서로 연결한 것을 말한다.
마지막 요소의 다음 요소는 첫번째 요소가 되고, 첫번째 요소의 이전 요소는 마지막 요소가 되는 것을 말한다.

- LinkedList 구현체
자바의 LinkedList는 이중 연결 리스트로 구현되어 있다.
그 이유는 기존 연결 리스트의 낮은 접근성의 문제를 개선하고자, 이중 연결 리스트로 구현한 것이다.
또한 LinkedList는 List 인터페이스를 구현했기 때문에 ArrayList와 제공하는 메서드는 비슷하다. ( 내부 구현 방식은 다소 차이가 있다. )
그리고 JDK1.5 부터는 Queue 인터페이스, JDK1.6 부터는 Deque 인터페이스가 추가되어 구현되어있다.

- LinkedList 와 ArrayList 

순차적으로 추가 또는 삭제하는 경우 ArrayList가 LinkedList보다 빠르다.
	ㄴ 단 ArrayList의 초기용량이 충분할 때 차이가 크지만, 초기 용량이 부족하여 새로운 배열을 만들 때에는 LinkedList가 ArrayList보다 빠를 수 있다.
	
중간 데이터를 추가 또는 삭제하는 경우 LinkedList가 ArrayList보다 빠르다.
	ㄴ LinkedList의 경우 노드의 링크만 바꿔주면 되지만, ArrayList의 경우 데이터의 위치를 재 정렬해야 하기 때문에 처리 속도가 느리다.
	
데이터의 조회는 ArrayList가 LinkedList보다 빠르다.
	ㄴ 배열의 경우 각 요소가 연속적으로 저장되어 있기 때문에 주소의 계산식 ( 배열 주소 + index * 자료형size ) 으로 빠르게 데이터를 조회할 수 있지만,
	LinkedList의 경우 각 요소가 불연속적으로 저장되어있고, 요소간에 연결이 되어있기 떄문에 그 연결을 따라가야 데이터를 찾을 수 있다.