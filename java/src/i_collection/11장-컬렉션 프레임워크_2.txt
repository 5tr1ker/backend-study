[ Arrays ]
Arrays 클래스는 배열을 다루는데 필요한 메서드들이 정의되어 있다.
같은 기능을 가진 메서드가 배열의 타입을 달리하여 여러개 오버로딩이 되어있기 때문에 다양한 타입의 배열을 다룰 수 있다.

- 배열의 목사 copyOf() , copyOfRange()
        int arr[] = {1,2,5,71,51};

        System.out.println(Arrays.toString(Arrays.copyOf(arr, arr.length)));
        System.out.println(Arrays.toString(Arrays.copyOfRange(arr, 0, 2)));
		
copyOf는 배열 전체를 복사하고, copyOfRange()는 특정 범위의 배열을 복사해서 반환한다.

- 배열 채우기 fill() , setAll()
fill()은 배열의 모든 요소를 지정된 값으로 가득 채우는 것이고, setAll은 배열을 채우는데 사용할 함수형 인터페이스를 매개 변수로 받는다.

		int arr2[] = new int[10];
        Arrays.fill(arr2, -1);

        System.out.println(Arrays.toString(arr2));

        Arrays.setAll(arr2, () -> (int) (Math.random() * 5) + 1);
        System.out.println(Arrays.toString(arr2));
		
- 배열의 정렬과 탐색 sort() , binarySearch()
Arrays.sort()는 배열을 정렬하며, binarySearch()는 배열에서 지정된 값이 저장된 위치를 반환한다.

단, binarySearch 는 같은 값이 여러개일 경우, 같은 값 중에서 임의의 위치가 반환된다. 그리고 해당 메서드는 배열이 정렬되어 있는 상태이어야 한다.
그 이유는 binarySearch 메서드는 이진 탐색을 사용하기 때문에 정렬되어 있지 않은 배열은 잘못된 값을 얻을 수 있다.

- 배열의 비교와 출력 equals() , toString()

toString() 은 배열 내의 요소를 출력한다. 다만 2차원 배열의 경우 deepToString을 이용해야 2차원 배열의 내부 값을 볼 수 있다.
        int arr3[][] = { {1,2,3} , {4,5,6} , {7,8,9} };
        System.out.println(Arrays.deepToString(arr3));
		
equals 는 두 배열의 구성이 같은지 확인한다. 이 메서드 같은 경우에도 2차원 배열의 경우 deepEquals 을 사용해야 정상적인 결과를 얻을 수 있다.

		int arr3[][] = { {1,2,3} , {4,5,6} , {7,8,9} };
        int arr4[][] = { {1,2,3} , {4,5,6} , {7,8,9} };
        System.out.println(Arrays.deepEquals(arr3, arr4));
		
- 배열을 List로 변환
asList()를 통해 배열을 List에 담을 수 있다. 또한 asList는 매개변수가 가변 인자이기 때문에 저장할 값들을 나열할 수 있다.

        List<Integer> list = Arrays.asList(1,2,3,4,5);
        List<Integer> list_2 = Arrays.asList(new  Integer[]{1,2,3,4,5});
		
		ArrayList<Integer> arrayList = new ArrayList<>(list);
        arrayList.add(50);
        System.out.println(arrayList);
		
주의할 점은 asList 통해서 생성된 List는 불변이기 때문에 데이터를 추가, 또는 삭제할 수 없다.
따라서 배열의 크기를 바꾸고 싶다면 위와 같이 ArrayList의 생성자로 제공해주면 된다.

[ Comparator와 Comparable ]
Comparable와 Comparable은 컬렉션을 정렬하는데 필요한 메서드를 제공한다.
이는 Arrays.sort() 의 정렬에 사용된다.
# Integer, Character 타입의 배열은 이미 Comparable 이 구현되어 있기 때문에 Arrays.sort()를 사용하는데 추가 구현이 없었다.

Comparable을 구현하고 있는 클래스는 같은 타입의 인스턴스끼리 서로 비교할 수 있는 클래스들이다.
	ㄴ 예를 들면 Wrapper 클래스, 혹은 String 이나 Date 등이 있다.
	ㄴ Wrapper 클래스 중 Integer 클래스는 compare() 메서드를 비교하는 값이 크면 -1, 같으면 0 , 작으면 1 을 반환하게 구현되어 있다.
	ㄴ String 문자열 같은 경우 문자열의 사전 순으로 오름차순 정렬한다. ( 공백, 숫자, 대문자, 소문자 순으로 유니코드의 순서가 작은 값에서부터 큰 값으로 정렬한다. )
그리고 기본으로 오름 차순으로 정렬될 수 있게 구현 되어있다.

public interface Comparable {
	public int compareTo(Object o);
}

public interface Comparator {
	int compare(Object o1, Object o2);
	boolean equals(Object obj);
}

compare()와 compareTo() 모두 두 객체를 비교해서 정수 값을 반환해야 한다.
이는 두 객체가 같으면 0, 비교하는 값보다 작으면 음수 , 크면 양수를 반환하도록 구현해야 한다.

Comparable을 구현한 클래스는 기본적으로 오름차순으로 되어 있지만, 내림차순으로 정렬하거나 다른 기준으로 정렬하고 싶으면 Comparator 인터페이스를 구현하면 된다.
# Comparable 인터페이스는 기본 정렬 기준을 구현할 때 사용되며, Comparator 는 다른 정렬 기준을 구현할 때 사용된다.

public class ComparatorStudy {

    public static void main(String[] args) {
        Integer[] arr = {3,6,87,9,2,7,1,6,453,5,26,31};

        Arrays.sort(arr);
        System.out.println(Arrays.toString(arr));

        Arrays.sort(arr, new Descending());
        System.out.println(Arrays.toString(arr));

    }

}
class Descending implements Comparator<Integer> {

    @Override
    public int compare(Integer o1, Integer o2) {
        return o2.compareTo(o1);
    }
}
결과
[1, 2, 3, 5, 6, 6, 7, 9, 26, 31, 87, 453]
[453, 87, 31, 26, 9, 7, 6, 6, 5, 3, 2, 1]

Arrays.sort() 는 배열을 정렬할 때 Comparator를 구현하지 않을 경우 Comparable에 구현된 내용에 따라 정렬된다.

[ HashSet ]
HashSet은 Set 인터페이스를 구현한 컬렉션 클래스이며, 중복된 요소를 저장하지 않는다.
또한 HashSet은 저장순서를 유지하지 않기 때문에, 저장 순서를 유지하고 싶다면 LinkedHashSet을 사용해야 한다.

HashSet에 요소를 저장하는 add 나 addAll 은 중복된 객체가 있어서 저장이되지 않았을 때, false 를 반환한다.

# HashSet은 내부적으로 HashMap을 이용해서 만들어졌으며, 해싱을 활용해서 구현했기 때문에 붙여진 이름이다.