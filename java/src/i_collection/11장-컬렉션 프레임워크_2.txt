[ Arrays ]
Arrays 클래스는 배열을 다루는데 필요한 메서드들이 정의되어 있다.
같은 기능을 가진 메서드가 배열의 타입을 달리하여 여러개 오버로딩이 되어있기 때문에 다양한 타입의 배열을 다룰 수 있다.

- 배열의 목사 copyOf() , copyOfRange()
        int arr[] = {1,2,5,71,51};

        System.out.println(Arrays.toString(Arrays.copyOf(arr, arr.length)));
        System.out.println(Arrays.toString(Arrays.copyOfRange(arr, 0, 2)));
		
copyOf는 배열 전체를 복사하고, copyOfRange()는 특정 범위의 배열을 복사해서 반환한다.

- 배열 채우기 fill() , setAll()
fill()은 배열의 모든 요소를 지정된 값으로 가득 채우는 것이고, setAll은 배열을 채우는데 사용할 함수형 인터페이스를 매개 변수로 받는다.

		int arr2[] = new int[10];
        Arrays.fill(arr2, -1);

        System.out.println(Arrays.toString(arr2));

        Arrays.setAll(arr2, () -> (int) (Math.random() * 5) + 1);
        System.out.println(Arrays.toString(arr2));
		
- 배열의 정렬과 탐색 sort() , binarySearch()
Arrays.sort()는 배열을 정렬하며, binarySearch()는 배열에서 지정된 값이 저장된 위치를 반환한다.

단, binarySearch 는 같은 값이 여러개일 경우, 같은 값 중에서 임의의 위치가 반환된다. 그리고 해당 메서드는 배열이 정렬되어 있는 상태이어야 한다.
그 이유는 binarySearch 메서드는 이진 탐색을 사용하기 때문에 정렬되어 있지 않은 배열은 잘못된 값을 얻을 수 있다.

- 배열의 비교와 출력 equals() , toString()

toString() 은 배열 내의 요소를 출력한다. 다만 2차원 배열의 경우 deepToString을 이용해야 2차원 배열의 내부 값을 볼 수 있다.
        int arr3[][] = { {1,2,3} , {4,5,6} , {7,8,9} };
        System.out.println(Arrays.deepToString(arr3));
		
equals 는 두 배열의 구성이 같은지 확인한다. 이 메서드 같은 경우에도 2차원 배열의 경우 deepEquals 을 사용해야 정상적인 결과를 얻을 수 있다.

		int arr3[][] = { {1,2,3} , {4,5,6} , {7,8,9} };
        int arr4[][] = { {1,2,3} , {4,5,6} , {7,8,9} };
        System.out.println(Arrays.deepEquals(arr3, arr4));
		
- 배열을 List로 변환
asList()를 통해 배열을 List에 담을 수 있다. 또한 asList는 매개변수가 가변 인자이기 때문에 저장할 값들을 나열할 수 있다.

        List<Integer> list = Arrays.asList(1,2,3,4,5);
        List<Integer> list_2 = Arrays.asList(new  Integer[]{1,2,3,4,5});
		
		ArrayList<Integer> arrayList = new ArrayList<>(list);
        arrayList.add(50);
        System.out.println(arrayList);
		
주의할 점은 asList 통해서 생성된 List는 불변이기 때문에 데이터를 추가, 또는 삭제할 수 없다.
따라서 배열의 크기를 바꾸고 싶다면 위와 같이 ArrayList의 생성자로 제공해주면 된다.

[ Comparator와 Comparable ]
Comparable와 Comparable은 컬렉션을 정렬하는데 필요한 메서드를 제공한다.
이는 Arrays.sort() 의 정렬에 사용된다.
# Integer, Character 타입의 배열은 이미 Comparable 이 구현되어 있기 때문에 Arrays.sort()를 사용하는데 추가 구현이 없었다.

Comparable을 구현하고 있는 클래스는 같은 타입의 인스턴스끼리 서로 비교할 수 있는 클래스들이다.
	ㄴ 예를 들면 Wrapper 클래스, 혹은 String 이나 Date 등이 있다.
	ㄴ Wrapper 클래스 중 Integer 클래스는 compare() 메서드를 비교하는 값이 크면 -1, 같으면 0 , 작으면 1 을 반환하게 구현되어 있다.
	ㄴ String 문자열 같은 경우 문자열의 사전 순으로 오름차순 정렬한다. ( 공백, 숫자, 대문자, 소문자 순으로 유니코드의 순서가 작은 값에서부터 큰 값으로 정렬한다. )
그리고 기본으로 오름 차순으로 정렬될 수 있게 구현 되어있다.

public interface Comparable {
	public int compareTo(Object o);
}

public interface Comparator {
	int compare(Object o1, Object o2);
	boolean equals(Object obj);
}

compare()와 compareTo() 모두 두 객체를 비교해서 정수 값을 반환해야 한다.
이는 두 객체가 같으면 0, 비교하는 값보다 작으면 음수 , 크면 양수를 반환하도록 구현해야 한다.

Comparable을 구현한 클래스는 기본적으로 오름차순으로 되어 있지만, 내림차순으로 정렬하거나 다른 기준으로 정렬하고 싶으면 Comparator 인터페이스를 구현하면 된다.
# Comparable 인터페이스는 기본 정렬 기준을 구현할 때 사용되며, Comparator 는 다른 정렬 기준을 구현할 때 사용된다.

public class ComparatorStudy {

    public static void main(String[] args) {
        Integer[] arr = {3,6,87,9,2,7,1,6,453,5,26,31};

        Arrays.sort(arr);
        System.out.println(Arrays.toString(arr));

        Arrays.sort(arr, new Descending());
        System.out.println(Arrays.toString(arr));

    }

}
class Descending implements Comparator<Integer> {

    @Override
    public int compare(Integer o1, Integer o2) {
        return o2.compareTo(o1);
    }
}
결과
[1, 2, 3, 5, 6, 6, 7, 9, 26, 31, 87, 453]
[453, 87, 31, 26, 9, 7, 6, 6, 5, 3, 2, 1]

Arrays.sort() 는 배열을 정렬할 때 Comparator를 구현하지 않을 경우 Comparable에 구현된 내용에 따라 정렬된다.

[ HashSet ]
HashSet은 Set 인터페이스를 구현한 컬렉션 클래스이며, 중복된 요소를 저장하지 않는다.
또한 HashSet은 저장순서를 유지하지 않기 때문에, 저장 순서를 유지하고 싶다면 LinkedHashSet을 사용해야 한다.

HashSet에 요소를 저장하는 add 나 addAll 은 중복된 객체가 있어서 저장이되지 않았을 때, false 를 반환한다.

# HashSet은 내부적으로 HashMap을 이용해서 만들어졌으며, 해싱을 활용해서 구현했기 때문에 붙여진 이름이다.

HashSet 같은 경우는 자체적으로 저장하는 방식에 따라 순서가 결정되기 때문에 같은 값을 저장할 경우 저장 순서가 같을 수 있다.
        for(int z = 0; z < 10; z++) {
            HashSet<Integer> set = new HashSet<>();
			// LinkedHashSet<Integer> set = new LinkedHashSet<>();
            for(int i = 0; i < 10; i++) {
                set.add((int) (Math.random() * 5) + 1);
            }

            System.out.println(set);
        }
- 실행 결과
[1, 2, 3, 4, 5]
[2, 3, 4, 5]
[2, 3, 4]
[1, 2, 3, 4, 5]
[1, 2, 3, 5]
[1, 2, 3, 4, 5]
[1, 2, 3, 4, 5]
[1, 2, 3, 4, 5]
[1, 3, 4, 5]
[2, 3, 4, 5]

위의 예제와 같이 HashSet 내부의 저장 방식이 있기 때문에, Random 으로 값을 뽑는다 하더라도 같은 값을 얻을 수 있다.
# 랜덤한 값으로 섞고 싶다면 LinkedHashSet을 이용하여 랜덤 값이 순서대로 저장되게 하면 된다.

- 클래스의 HashSet
HashSet의 add 메서드는 새로운 요소를 추가하기 전에 기존 요소와 같은 것인지 구별하기 위해 equals() 와 hashCode() 호출한다.
그렇기 때문에 인스턴스가 같은지 판단하기 위해선 2개의 메서드를 오버라이딩 해야한다.

class Person {
    int age;
    String name;

    public Person(int age, String name) {
        this.age = age;
        this.name = name;
    }

    @Override
    public int hashCode() {
        return Objects.hash(age, name);
    }

    @Override
    public boolean equals(Object o2) {
        Person o1 = (Person) o2;
        if(o1.age == this.age && o1.name.equals(this.name)) {
            return true;
        }
        return false;
    }

    public String toString() {
        return "Name: " + this.name + ", Age: " + this.age + "\n";
    }
}

hashCode() 같은 경우 JDK1.8 부터 추가된 Objects 클래스의 hash() 를 이용해서 작성하면된다.
해당 메서드의 인자 값으로 인스턴스 변수를 제공하면 된다.

# 원래 기존에는 (age + name).hashCode() 처럼 String 클래스의 hashCode() 를 사용했었지만, 지금은 Objects 클래스의 hash() 를 쓰는 것이 좋다.

오버라이딩을 통해 정의된 hashCode는 다음의 3가지 조건을 만족해야 한다.
1. 동일한 객체에 대해 hashCode()의 반환 값은 항상 같아야 한다.
2. equals() 메서드의 결과가 true 인 두 객체의 hashCode() 반환 값은 같아야 한다.
3. equals() 메서드의 결과가 false일 지라도 hashcode()의 값은 같아도 된다. 단, 해싱을 사용하는 컬렉션의 성능 향상을 위해 다른 hashCode 값을 반환 하도록 해야 한다.
	ㄴ 해싱을 사용하는 컬렉션은 HashMap 과 HashTable이 있다.
	ㄴ 서로다른 객체에 대해 중복되는 hashCode 가 많아질수록 해싱을 사용하는 컬렉션의 성능이 떨어진다.
	
클래스를 정의할 때 equals() 메서드를 오버라이딩 한다면, hashCode() 도 오버라이딩 하는 것이 원칙이지만
생략해도 큰 문제가 되진 않는다. ( 간단히 만드는 경우엔 생략하는 경우가 있다 )

[ TreeSet ]
TreeSet은 이진 탐색 트리라는 자료구조로 데이터를 저장하는 컬렉션 클래스이다.
이진 탐색 트리는 검색, 정렬, 범위 검색에서 높은 성능을 보이며, TreeSet은 레드-블랙 트리로 구현되어 있다.
# 레드 블랙 트리는 이진 탐색 트리의 성능을 향상시킨 자료구조이다.
그리고 TreeSet은 Set인터페이스를 구현했기 때문에 중복을 허용하지 않고, 저장순서도 보장하지 않는다.
	ㄴ TreeSet도 정렬된 위치에 저장한다. 즉, HashSet처럼 내부 규칙에 따라 데이터가 보관된다.

TreeSet에 객체를 저장할 때, 객체의 크기를 비교하기 위해 Comparable 이나 Comparator 를 제공해야 한다.

- 이진 탐색 트리 
이진 탐색 트리는 하나의 부모 노드는 최대 2개의 자식 노드를 가질 수 있는 이진 트리이다.
이진 탐색 트리는 부모 노드의 값보다 작은 노드는 왼쪽, 큰 값은 오른쪽에 배치되며, 항상 정렬된 상태를 유지한다.
	ㄴ 그렇기 때문에 데이터의 조회에서 NLogN 의 속도를 자랑한다.
또한 이진 탐색 트리는 중위 순회를 할 경우 정렬된 값을 얻을 수 있다.
단, 트리는 데이터를 순차적으로 저장하는 것이 아니라 저장할 위치를 찾아서 저장해야하고, 삭제할 경우 트리를 재구성해야 하기 때문에 링크드 리스트보다 성능이 떨어진다.
그리고 중복된 값을 저장하지 못한다.

- TreeSet 구현
TreeSet에 데이터를 저장할 때, TreeSet 내부에는 항상 정렬된 상태를 유지하기 때문에 데이터를 조회할 때 정렬할 필요가 없다.

        TreeSet<Integer> treeSet = new TreeSet<>();
        for(int i = 0; i < 10; i++) {
            treeSet.add((int) (Math.random() * 100) + 1);
        }

        System.out.println(treeSet);
        System.out.println(treeSet.subSet(0 , 20)); // 범위 검색
        System.out.println(treeSet.headSet(50)); // 50 보다 작은거
        System.out.println(treeSet.tailSet(50)); // 50 보다 큰거
출력결과
[2, 8, 12, 16, 37, 45, 52, 53, 55, 99]
[2, 8, 12, 16]
[2, 8, 12, 16, 37, 45]
[52, 53, 55, 99]

위의 예제에선 add() 메서드를 통해 TreeSet에 데이터를 저장할 수 있다.
또한 subSet() 를 통해 범위 검색을 할 수 있으며, headSet과 tailSet을 통해 특정 값 기준으로 큰 객체와 작은 객체를 가지고 올 수 있따.

[ HashMap과 Hashtable ]
HashMap과 Hashtable의 관계는 ArrayList와 Vector와 같다. 그렇기 때문에 Hashtable을 사용하는 것 보다, HashMap을 사용하는 것이 좋다.
HashMap은 Map 인터페이스를 구현했기 떄문에 키와 값을 하나로 묶어서 데이터를 저장한다. 그리고 해싱을 사용하기 때문에 데이터 탐색이 빠르다.

HashMap은 내부의 Entry 배열을 가지고 있다. Entry는 HashMap의 내부 클래스이며, 키와 값을 하나로 가지고 있는 클래스이다.
	ㄴ 키와 값을 각각의 배열로 관리하기엔 데이터 무결성에 문제가 생길 수 있다.

* Key : 컬렉션 내에 키는 유일해야 한다.
* Value : 키와 달리 데이터의 중복을 허용한다.
HashMap 내에 키는 컬렉션 내에서 유일해야하며, 값은 중복되어도 괜찮다.
또한 HashMap에 저장된 데이터를 하나의 키로 검색할 때, 단 하나의 값을 나와야 한다.
만약 put() 메서드를 통해 저장되는 키가 HashMap에 이미 존재한다면, 해당 값으로 덮어 씌워진다.

hashMap.put("id" , "passw0rd");
hashMap.put("id" , "password");
즉, 위와 같은 코드를 실행하면 passw0rd 가 아니라 password 값이 저장된다.

