배열 : 같은 타입의 변수를 한 묶음으로 다루는 것을 말한다.

만약 int 타입의 변수를 100개 만들 경우, 변수를 100개를 만드는 것 보다 크기가 100인 배열을 생성하는 것이 좋다.
배열은 같은 타입의 변수를 여러개 다를 수 있다. 이때 서로 다른 타입은 다를 수 없다.

int a[] = new int[5];
위의 코드는 배열을 생성하는 코드이다.  (
int 타입의 값을 저장할 수 있는 공간이 5개 생성이 되며 각각의 공간에는 값이 저장될 수 있다. ( a[0] ~ a[4] )
이때 배열의 인덱스 접근은 1이 아닌 0부터 시작한다. ( a[0] )

-배열의 선언
배열을 선언하는 방법은 변수나 타입 뒤에 [] 를 붙여주면 된다.
ex ) int arr[];
ex ) int []arr;

이때 배열을 선언만 했을 경우엔 아직 배열을 사용할 수는 없다.
	ㄴ 그 이유는 선언은 생성된 배열을 다루기 위한 *참조 변수*를 생성한 것 뿐, 배열을 생성해야 실제로 사용할 수 있다.
	ㄴ 배열의 생성은 실제 값이 저장되는 공간이 생긴다는 것이다.

-배열의 생성

값이 저장될 수 있는 공간을 만들기 위해선 new 연산자와 타입, 배열의 크기를 지정해주면 된다.
ex ) new 타입[길이]
ex ) int arr[] = new int[5];

다음과 같이 선언과 생성을 나눌 수 있다.
int arr[];			// int형 배열을 다루는 참조변수 생성
arr = new int[5];	// 실제 값이 저장되는, 저장공간 생성

보통 선언과 생성은 따로 나누진 않고, 한줄에 같이 쓴다.

배열의 생성 과정을 순차적으로 정리하면 다음과 같다.
1. int 타입 배열의 참조 변수를 생성한다.
2. new 연산자에 의해 int 타입의 변수 5개가 저장될 수 있는 공간이 생성된다.
3. 배열 내부의 값은 int의 초기 값인 0이 저장된다.
4. 참조 변수에 int 배열의 주소가 저장된다.

*이때 생성된 공간은 연속적이다. 예를 들어 int 타입의 변수 5개의 저장공간을 할당할 때, 각각의 저장 공간은 붙어있다.*

생성된 배열은 배열이름[인덱스] 를 통해서 배열의 요소에 접근할 수 있다.
	ㄴ 인덱스는 배열의 요소마다 붙여진 일련번호로 0부터 시작한다.
	ㄴ 인덱스는 배열의 요소를 구분하기 위해 존재하며 길이는 [ 0 ~ 배열길이 - 1 ] 이다.

* 즉 배열의 요소는 배열 내 각각의 저장공간이고, 인덱스는 각각의 요소마다 붙여진 일련 번호이다. *
* 인덱스는 각 배열의 요소를 식별하는데 사용된다 *

- 배열의 값 접근
a[0] = 30; // 배열의 요소에 값을 저장
int value = a[2]; // 특정한 배열의 요소에 값을 가져오기

배열의 인덱스는 상수가 아닌 변수나 상수를 이용할 수 있다.
for(int i = 0; ; ) {
	arr[i] = i;
}

이때 배열의 범위를 벗어 날 경우 ArrayIndexOutOfBoundsException 이 발생한다.
예를 들어 배열의 범위가 new int[5] 일 경우 int[-1] 이나 int[5] 을 할 경우 발생한다.


- 배열의 길이

배열의 길이를 적을 때 정수 값을 적어야 하며 최대 길이는 int의 최대 값인 21억이다.
반대로 최소 값은 0 이다.

자바에서는 JVM이 모든 배열의 길이를 관리하고 있으며, 배열이름.length 로 해당 배열의 길이를 읽어올 수 있다.
배열은 생성된 이후로 길이를 변경할 수 없다. 그렇기 때문에 배열의 길이를 불러오는 배열이름.length 는 상수 값이다.

배열의 길이를 직접 적어주는 것 보다 "배열이름.length" 를 이용하는 것이 오류율도 적어지고, 가독성도 좋아진다.
for(int i = 0; i < 배열이름.length; i++
	arr[i]

위와 같이 for문의 조건식에 활용할 경우, 배열의 길이가 변경될 경우에도 수정이 필요 없어 진다.

- 배열의 길이 변경
만약 배열의 길이가 모자라여, 길이를 늘린다면 다음과 같이 하면 된다.
1. 길이가 더 큰 배열을 생성한다.
2. 기존 배열을 새로운 배열에 값을 복사한다.

다만 이러한 작업은 비용이 많이 들기 때문에, 처음부터 배열을 넉넉하게 잡으면 좋다.
그렇다고 너무 크게 잡으면 메모리가 낭비되기 떄문에, 기존의 2배 정도로 잡으면 된다.

하단에 실제 코드를 보면서 배열의 길이를 늘리는 방법을 알아보자

1. for문을 이용해 배열의 길이를 변경하기
int arr[] = {1,2,3,4,5};				// 1. 변경 전 배열
int temp[] = new int[arr.length * 2];	// 2. 변경 후 배열
for(int i = 0; i < arr.length; i++)		// 3. for 문을 이용해 arr 배열 내부에 데이터를 temp 에 저장
	temp[i] = arr[i];
arr=temp;								// 4. 마지막 temp의 배열 주소를 arr와 공유
System.out.println(Arrays.toString(arr));// [1, 2, 3, 4, 5, 0, 0, 0, 0, 0] 출력
** 이때 기존에 arr 가 참조하던 배열은 더이상 접근할 수 없게 되며 Garbage Collector 에 의해 제거될 것이다.

2. System.arraycopy() 를 이용한 배열 복사
arraycopy() 메서드는 for문으로 하나씩 복사한 것 보다 성능이 더 좋다.
그 이유는 arraycopy는 범위에 있는 데이터를 한번에 복사하기 때문이다. ( 배열은 메모리에 연속적으로 저장된다는 특징을 활용하기 때문이다. )
System.arraycopy(arr, 0, temp, 2 , arr.length);
	ㄴ 해석 하자면 arr 의 배열을 0번 째 부터 arr.length 까지 temp 배열의 2번째 부터 붙여넣기 하라
	ㄴ 만약 붙여넣기 되는 배열의 크기가 원본보다 작을 경우 ArrayIndexOutOfBoundsException 예외가 발생한다.

# 활용 코드 예제
int arr[] = {1,2,3,4,5};
int temp[] = new int[arr.length * 2];
System.arraycopy(arr, 0, temp, 2 , arr.length);
System.out.println("TEMP : " + Arrays.toString(temp));
System.out.println("ARR : " + Arrays.toString(arr));

** 정리 하자면, for문을 사용하는 것 보다 System.arraycopy 메서드를 활용하는 것이 훨씬 좋다.

- 배열의 초기화

배열의 경우 기본 자료형일 경우 해당 타입의 기본 값으로 초기화가 되지만 ( 예를 들어 int 형은 0 ) 내가 원하는 값으로 초기화 할 땐 하단의 코드처럼 짜면 된다.
int arr[] = new int[5] {845,56,98,46,5}; // 오류
int arr[] = new int[] {412,616,724741,614}; // 가능
int arr[] = {312,51,216,126,214}; // 가능

변수의 타입에 따른 기본형은 다음과 같다.
1. boolean = false
2. char = '\u0000' // 제어 문자 'NULL'    
3. byte, short, int = 0
4. long = 0
5. float = 0.0
6. double = 0.0
7. 참조형 변수 = null

{} 괄호 안에 쉼표를 구분하여 값을 넣으면, 해당 값의 갯수에 맞춰 배열의 크기가 결정된다.
int arr[] = {} // 길이가 0 인 배열
int arr[] = new int[] {} // 길이가 0 인 배열
*배열의 참조 변수의 경우 기본 값은 null 이지만, 길이가 0 인 배열을 가리키게 초기화 하는 경우도 있다.*

int arr[];
arr = new int[] {12,3,124,12,4}; // 가능
arr = {1,23,4,5}; // 오류

이때 선언과 생성을 달리 할 경우 new int[] 를 생략할 경우 오류가 발생한다.

- 배열의 출력
배열의 출력은 다음과 같은 방법으로 출력할 수 있다.

1. 기본 출력
for(int i = 0; i < arr.length; i++)
	System.out.println(arr[i]);
	
2. 향상된 for문
for(int output : arr)
	System.out.println(output)
	
3. Arrays 메서드 활용
Arrays.toString(arr);

System.out.println("주소 : " + arr); // 주소 : [I@23fc625e
만일 위와 같이 배열을 그대로 출력한다면, 배열에 대한 주소가 출력될 것이다.
그 이유는 배열을 가리키는 참조 변수이기 때문에 배열에 대한 주소가 출력된다.
	ㄴ 참조 변수는 배열의 주소를 저장하고 있다.

출력 시 "타입@주소" 의 형태로 출력이 된다. "[I" 는 1차원 int 타입이라는 뜻이고, @ 뒤에 16진수는 내부 주소를 의미한다.

## 예외적으로 System.out.println은 char 배열을 그대로 출력하면 내부 값이 그대로 나온다. 그 이유는 내부적으로 구현되어 있기 때문이다.
## char ch[] = {'A' , 'B' , 'C' , 'D'};
## System.out.println(ch); // ABCD 를 출력 한다.

[ String 배열 ]
String 타입의 배열을 생성하기 위해선 다음과 같이 선언 및 생성한다.
> String []str = new String[3];
int 형 배열을 선언하는 것과 같이 배열을 다루기 위한 참조 변수를 선언하고, 실제 값이 저장될 공간을 생성한다.

이때 String 타입은 기본 형과는 달리 기본 값이 null 이다. 그 이유는 String은 참조형 변수이기 때문이다.
# 즉 String 은 실제 값을 갖고 있는 것이 아닌, 문자열이 저장된 위치를 가리키고 있다.
# 더 자세히 말하면 String 은 객체의 주소가 담겨져 있다.
# 이렇게 기본형 배열이 아닌 참조형 배열 ( 객체 배열 ) 은 각 배열의 값은 객체의 주소를 가지고 있으며 기본 값은 null 이다.
# 객체 배열은 요소들을 각각의 참조변수 ( 참조형 변수 ) 라고 생각해도 되며, 4byte의 크기이다. ( 기본 값은 null 혹은 객체의 주소 값 ) 

- String 배열의 초기화

String 배열을 초기화 하는 방법은 다음이 있다.
String[] name = new String[10]; // 각각의 요소에 직접 대입
name[0] = "Park";
name[1] = "Sang";
name[2] = "Jin";
        
String[] age = new String[] {"a" , "b" , "C"}; // 괄호를 이용하여 초기화
String[] c = {"1" , "2" , "#"}; // new String[] 도 생략할 수 있다.

- char 배열과 String 클래스

문자열은 "문자를 연이어 늘어놓은 것" 을 의미하여, 이는 char[] 와 String 클래스는 논리적으로 같다.
java 에서 문자열을 char[] 를 사용하지 않고 String 클래스를 사용하는 이유는 다음과 같다.
	ㄴ char 배열에서 더 많은 기능을 추가한 것 이다. ( 즉,  데이터와 기능을 가지고 있는 String 클래스 )
	ㄴ char[] 과 달리 String 클래스는 데이터를 바꿀 수 없다.
즉, String 클래스는 객체지향언어로 char[] 데이터와 관련 기능을 하나의 클래스로 묶은 것이다.

String str = "input";
str = "modify";
위의 코드는 문자열이 변경된 것 같지만, 새로운 문자열이 생성된 것 이다.

char[] arr = str.toCharArray();	// String 을 char[] 로 변환
String newStr = new String(arr); // char[] 를 String 로 변환
# char 배열과 문자열은 다음과 같이 서로 바꿀 수 있다.


- 사용자 입력
사용자 입력은 크게 2가지가 있다.
1. Scanner 클래스 .nextLine() 활용
2. 커맨드 라인 활용

커맨드 라인같은 경우 class 파일을 실행할 때 [ java Main "this is input" abc 123 ] 와 같은 명령어로 실행될 때, 클래스 뒤에 있는 인자들이
main 클래스의 매개 변수인 String []args 에 들어가게 된다. ex ) public static void main(String[] args)
각 문자열은 띄어쓰기를 구분으로 저장되며 만약 문장을 입력할 시 쌍따옴표("") 로 묶어주면 된다.
만약 인자가 없다면 크기가 0 인 배열이 들어가게 된다. ( null이 아님 ) 
이때 인자로 정수를 입력했다 하더라도, 매개변수의 타입인 String 으로 들어간다.

- 다차원 배열

배열을 사용할 때 1차원 배열 ( String []arr ) 뿐만 아니라 2차원 배열 ( String [][]arr ) 도 사용 가능하다.
선언하는 방법은 일반 배열과 동일하며 차원의 수 만큼 배열을 붙여주면 된다.
ex ) int arr[][] = new int[1][1];

차원에는 제한이 없지만 보통 1차원과 2차원이 주로 쓰인다.

2차원 배열은 보통 테이블 형태의 데이터를 담는데 사용되며, 4행 3열 테이블을 만든다 하면 다음과 같이 생성한다.
ex ) int arr[][] = new int[4][3];
각 행과 열의 영역에 접근하려면 다음과 같이 하면 된다. arr[행index][열index]

2차원 배열도 생성과 동시에 초기화를 할 수 있다. ( {} 중괄호를 활용 )
int[][] arr = new int[4][3]; // 일반적인 초기화이며 arr[0][0] = 3 처럼 초기화 해야 한다.
int[][] arr_1 = new int[][] {{1} , {2} , {3}};	// {} 중괄호를 이용해 초기화
int[][] arr_2 = {{1,2,3} , {4,5,6} , {7,8,9}};	// new int[][] 조차 생략 가능

또한 for문으로 2차원 배열의 모든 요소를 접근하는 방법은 다음과 같다.
행과 열에 각각의 크기를 지정해주면 좋지만, 상수값을 활용한다면 더 편리하다.

for (int i = 0; i < arr_2.length; i++) { // 행의 갯수는 arr_2.length 를 통해 알 수 있다.
	for (int j = 0; j < arr_2[i].length; j++) { // 열의 갯수는 arr_2[i].length 를 통해 알 수 있다.
		System.out.printf("%d" , arr_2[i][j]);
	}
	System.out.println();
}

향상된 for문으로도 각 요소에 접근할 수 있다.
for(int []input : arr) {
	for(int value : input) {
		System.out.println(value);
	}
}
위와 같이 향상된 for문을 사용할 경우 간단하게 값을 읽어올 수 있지만, 값을 수정할 수 없다.
	ㄴ 그 이유는 어떤 행과 열의 위치인지 알 수 없기 때문이다.
	ㄴ 쉽게 말해 일반 for문은 i 와 j 변수로 행과 열의 index를 지정해주지만, 향상된 for문은 index를 사용하지 않는다.

- 가변 배열 
Java는 다 차원 배열에 대해 마지막 차수를 유동적인 크기로 지정할 수 있다.
int arr[][] = new int[5][2];
	ㄴ 위와 같이 배열을 생성하면 일반적인 배열이 생성된다. ( 직사각형 형태 )

int arr[][] = new int[5][];
arr[0] = new int[4];
arr[1] = new int[2];
arr[2] = new int[7];
arr[3] = new int[6];
arr[4] = new int[9];
	ㄴ 하지만 위와 같이 마지막 차수를 각기 다른 길이로 할 수 있다.

출력 결과는 다음과 같다.
0000
00
0000000
000000
000000000

물론 중괄호를 이용해서 생성 및 초기화를 할 수 있다.
int arr[][] = {
                {1,2,3},
                {4,5},
                {6,7,8,9},
                {0},
                {}
};

