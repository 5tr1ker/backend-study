배열 : 같은 타입의 변수를 한 묶음으로 다루는 것을 말한다.

만약 int 타입의 변수를 100개 만들 경우, 변수를 100개를 만드는 것 보다 크기가 100인 배열을 생성하는 것이 좋다.
배열은 같은 타입의 변수를 여러개 다를 수 있다. 이때 서로 다른 타입은 다를 수 없다.

int a[] = new int[5];
위의 코드는 배열을 생성하는 코드이다.  (
int 타입의 값을 저장할 수 있는 공간이 5개 생성이 되며 각각의 공간에는 값이 저장될 수 있다. ( a[0] ~ a[4] )
이때 배열의 인덱스 접근은 1이 아닌 0부터 시작한다. ( a[0] )

-배열의 선언
배열을 선언하는 방법은 변수나 타입 뒤에 [] 를 붙여주면 된다.
ex ) int arr[];
ex ) int []arr;

이때 배열을 선언만 했을 경우엔 아직 배열을 사용할 수는 없다.
	ㄴ 그 이유는 선언은 생성된 배열을 다루기 위한 *참조 변수*를 생성한 것 뿐, 배열을 생성해야 실제로 사용할 수 있다.
	ㄴ 배열의 생성은 실제 값이 저장되는 공간이 생긴다는 것이다.

-배열의 생성

값이 저장될 수 있는 공간을 만들기 위해선 new 연산자와 타입, 배열의 크기를 지정해주면 된다.
ex ) new 타입[길이]
ex ) int arr[] = new int[5];

다음과 같이 선언과 생성을 나눌 수 있다.
int arr[];			// int형 배열을 다루는 참조변수 생성
arr = new int[5];	// 실제 값이 저장되는, 저장공간 생성

보통 선언과 생성은 따로 나누진 않고, 한줄에 같이 쓴다.

배열의 생성 과정을 순차적으로 정리하면 다음과 같다.
1. int 타입 배열의 참조 변수를 생성한다.
2. new 연산자에 의해 int 타입의 변수 5개가 저장될 수 있는 공간이 생성된다.
3. 배열 내부의 값은 int의 초기 값인 0이 저장된다.
4. 참조 변수에 int 배열의 주소가 저장된다.

*이때 생성된 공간은 연속적이다. 예를 들어 int 타입의 변수 5개의 저장공간을 할당할 때, 각각의 저장 공간은 붙어있다.*

생성된 배열은 배열이름[인덱스] 를 통해서 배열의 요소에 접근할 수 있다.
	ㄴ 인덱스는 배열의 요소마다 붙여진 일련번호로 0부터 시작한다.
	ㄴ 인덱스는 배열의 요소를 구분하기 위해 존재하며 길이는 [ 0 ~ 배열길이 - 1 ] 이다.

* 즉 배열의 요소는 배열 내 각각의 저장공간이고, 인덱스는 각각의 요소마다 붙여진 일련 번호이다. *
* 인덱스는 각 배열의 요소를 식별하는데 사용된다 *

- 배열의 값 접근
a[0] = 30; // 배열의 요소에 값을 저장
int value = a[2]; // 특정한 배열의 요소에 값을 가져오기

배열의 인덱스는 상수가 아닌 변수나 상수를 이용할 수 있다.
for(int i = 0; ; ) {
	arr[i] = i;
}

이때 배열의 범위를 벗어 날 경우 ArrayIndexOutOfBoundsException 이 발생한다.
예를 들어 배열의 범위가 new int[5] 일 경우 int[-1] 이나 int[5] 을 할 경우 발생한다.


- 배열의 길이

배열의 길이를 적을 때 정수 값을 적어야 하며 최대 길이는 int의 최대 값인 21억이다.
반대로 최소 값은 0 이다.

자바에서는 JVM이 모든 배열의 길이를 관리하고 있으며, 배열이름.length 로 해당 배열의 길이를 읽어올 수 있다.
배열은 생성된 이후로 길이를 변경할 수 없다. 그렇기 때문에 배열의 길이를 불러오는 배열이름.length 는 상수 값이다.

배열의 길이를 직접 적어주는 것 보다 "배열이름.length" 를 이용하는 것이 오류율도 적어지고, 가독성도 좋아진다.
for(int i = 0; i < 배열이름.length; i++
	arr[i]

위와 같이 for문의 조건식에 활용할 경우, 배열의 길이가 변경될 경우에도 수정이 필요 없어 진다.

- 배열의 길이 변경
만약 배열의 길이가 모자라여, 길이를 늘린다면 다음과 같이 하면 된다.
1. 길이가 더 큰 배열을 생성한다.
2. 기존 배열을 새로운 배열에 값을 복사한다.

다만 이러한 작업은 비용이 많이 들기 때문에, 처음부터 배열을 넉넉하게 잡으면 좋다.
그렇다고 너무 크게 잡으면 메모리가 낭비되기 떄문에, 기존의 2배 정도로 잡으면 된다.

하단에 실제 코드를 보면서 배열의 길이를 늘리는 방법을 알아보자

1. for문을 이용해 배열의 길이를 변경하기
int arr[] = {1,2,3,4,5};				// 1. 변경 전 배열
int temp[] = new int[arr.length * 2];	// 2. 변경 후 배열
for(int i = 0; i < arr.length; i++)		// 3. for 문을 이용해 arr 배열 내부에 데이터를 temp 에 저장
	temp[i] = arr[i];
arr=temp;								// 4. 마지막 temp의 배열 주소를 arr와 공유
System.out.println(Arrays.toString(arr));// [1, 2, 3, 4, 5, 0, 0, 0, 0, 0] 출력
** 이때 기존에 arr 가 참조하던 배열은 더이상 접근할 수 없게 되며 Garbage Collector 에 의해 제거될 것이다.

2. System.arraycopy() 를 이용한 배열 복사
arraycopy() 메서드는 for문으로 하나씩 복사한 것 보다 성능이 더 좋다.
그 이유는 arraycopy는 범위에 있는 데이터를 한번에 복사하기 때문이다. ( 배열은 메모리에 연속적으로 저장된다는 특징을 활용하기 때문이다. )
System.arraycopy(arr, 0, temp, 2 , arr.length);
	ㄴ 해석 하자면 arr 의 배열을 0번 째 부터 arr.length 까지 temp 배열의 2번째 부터 붙여넣기 하라
	ㄴ 만약 붙여넣기 되는 배열의 크기가 원본보다 작을 경우 ArrayIndexOutOfBoundsException 예외가 발생한다.

# 활용 코드 예제
int arr[] = {1,2,3,4,5};
int temp[] = new int[arr.length * 2];
System.arraycopy(arr, 0, temp, 2 , arr.length);
System.out.println("TEMP : " + Arrays.toString(temp));
System.out.println("ARR : " + Arrays.toString(arr));

** 정리 하자면, for문을 사용하는 것 보다 System.arraycopy 메서드를 활용하는 것이 훨씬 좋다.

- 배열의 초기화

배열의 경우 기본 자료형일 경우 해당 타입의 기본 값으로 초기화가 되지만 ( 예를 들어 int 형은 0 ) 내가 원하는 값으로 초기화 할 땐 하단의 코드처럼 짜면 된다.
int arr[] = new int[5] {845,56,98,46,5}; // 오류
int arr[] = new int[] {412,616,724741,614}; // 가능
int arr[] = {312,51,216,126,214}; // 가능

변수의 타입에 따른 기본형은 다음과 같다.
1. boolean = false
2. char = '\u0000' // 제어 문자 'NULL'    
3. byte, short, int = 0
4. long = 0
5. float = 0.0
6. double = 0.0
7. 참조형 변수 = null

{} 괄호 안에 쉼표를 구분하여 값을 넣으면, 해당 값의 갯수에 맞춰 배열의 크기가 결정된다.
int arr[] = {} // 길이가 0 인 배열
int arr[] = new int[] {} // 길이가 0 인 배열
*배열의 참조 변수의 경우 기본 값은 null 이지만, 길이가 0 인 배열을 가리키게 초기화 하는 경우도 있다.*

int arr[];
arr = new int[] {12,3,124,12,4}; // 가능
arr = {1,23,4,5}; // 오류

이때 선언과 생성을 달리 할 경우 new int[] 를 생략할 경우 오류가 발생한다.

- 배열의 출력
배열의 출력은 다음과 같은 방법으로 출력할 수 있다.

1. 기본 출력
for(int i = 0; i < arr.length; i++)
	System.out.println(arr[i]);
	
2. 향상된 for문
for(int output : arr)
	System.out.println(output)
	
3. Arrays 메서드 활용
Arrays.toString(arr);

System.out.println("주소 : " + arr); // 주소 : [I@23fc625e
만일 위와 같이 배열을 그대로 출력한다면, 배열에 대한 주소가 출력될 것이다.
그 이유는 배열을 가리키는 참조 변수이기 때문에 배열에 대한 주소가 출력된다.
	ㄴ 참조 변수는 배열의 주소를 저장하고 있다.

출력 시 "타입@주소" 의 형태로 출력이 된다. "[I" 는 1차원 int 타입이라는 뜻이고, @ 뒤에 16진수는 내부 주소를 의미한다.

## 예외적으로 System.out.println은 char 배열을 그대로 출력하면 내부 값이 그대로 나온다. 그 이유는 내부적으로 구현되어 있기 때문이다.
## char ch[] = {'A' , 'B' , 'C' , 'D'};
## System.out.println(ch); // ABCD 를 출력 한다.

[ String 배열 ]
String 타입의 배열을 생성하기 위해선 다음과 같이 선언 및 생성한다.
> String []str = new String[3];
int 형 배열을 선언하는 것과 같이 배열을 다루기 위한 참조 변수를 선언하고, 실제 값이 저장될 공간을 생성한다.

이때 String 타입은 기본 형과는 달리 기본 값이 null 이다. 그 이유는 String은 참조형 변수이기 때문이다.
# 즉 String 은 실제 값을 갖고 있는 것이 아닌, 문자열이 저장된 위치를 가리키고 있다.
# 더 자세히 말하면 String 은 객체의 주소가 담겨져 있다.
# 이렇게 기본형 배열이 아닌 참조형 배열 ( 객체 배열 ) 은 각 배열의 값은 객체의 주소를 가지고 있으며 기본 값은 null 이다.
# 객체 배열은 요소들을 각각의 참조변수 ( 참조형 변수 ) 라고 생각해도 되며, 4byte의 크기이다. ( 기본 값은 null 혹은 객체의 주소 값 ) 

- String 배열의 초기화

String 배열을 초기화 하는 방법은 다음이 있다.
String[] name = new String[10]; // 각각의 요소에 직접 대입
name[0] = "Park";
name[1] = "Sang";
name[2] = "Jin";
        
String[] age = new String[] {"a" , "b" , "C"}; // 괄호를 이용하여 초기화
String[] c = {"1" , "2" , "#"}; // new String[] 도 생략할 수 있다.