[ 어노테이션 ]
어노테이션은 주석, 주해, 메모라는 뜻을 가지고 있으며 소스코드와 문서를 함께 다루기 위해 사용된다.
어노테이션은 주석안에 소스코드에 대한 정보들을 저장하고, 미리 정의된 태그들을 이용해서 문서를 작성한 다음, javadoc.exe 프로그램을 만들어서 문서로 만든다.
# javadoc.exe는 소스코드의 주석으로부터 HTML 문서를 만드는 프로그램이다.

어노테이션은 주석처럼 프로그래밍 언어에 영향을 미치지 않으며, 해당 코드를 사용하는 다른 프로그램에게 유용한 정보를 제공한다.

@Test
public void method() {
}

위의 코드는 테스트 프로그램에게 테스트를 해야할 메서드임을 알려준다.
여기서 테스트 프로그램에게 호출해야 할 메서드를 일일이 정의하지 않고, 각각의 메서드 선언부 위에 @Test 를 붙여주기만 하면 된다.
단, 어노테이션은 모든 프로그램에게 유용한 것은 아니라 해당 프로그램이 미리 정의된 형식이여야 한다. 즉 @Test는 테스트 프로그램에게 유용한 것이며 다른 프로그램에겐 필요없는 것이다.

JDK에서 제공하는 표준 어노테이션은 컴파일러를 위한 것이다. 컴파일러에게 유용한 정보를 제공한다.
또한 메타 어노테이션은 다른 어노테이션을 정의하는데 사용된다.

- 표준 에너테이션

1. @Override
메서드 앞에서만 붙일 수 있는 어노테이션으로 조상 클래스의 메서드를 오버라이딩하는 것을 알린다.
해당 어노테이션은 필수는 아니지만, 메서드 앞에 선언될 경우 조상 클래스의 메서드 명과 동일한 것이 있는지 확인하고 없으면 오류를 발생시킨다.
# 오버라이딩할 조상 클래스의 메서드 명을 실수로 다르게 할 경우 이를 알아차리긴 힘들다. 새로운 메서드를 선언하는 것으로 간주하며, 메서드를 호출해도 조상의 메서드가 호출되기 때문이다.
public class SubClass extends SuperClass {
    @Override
    public void print() {
    }

}

2. @Deprecated
이는 새로운 JDK 버전이 나옴으로써, 기존의 기능을 대체하거나 사용되지 않을 때 사용된다.
기존 코드를 제거해도 되지만, 사용되고 있는 코드가 있으므로 함부로 제거할 수 없다, 따라서 해당 어노테이션을 필드나 메서드에 선언함으로써 사용하지 말 것을 권한다.
    @Deprecated
    public Date(int year, int month, int date) {
        this(year, month, date, 0, 0, 0);
    }
	
@Deprecated 가 붙은 대상을 사용할 순 있지만, 보통 개선된 버전을 사용하도록 유도한다.
# @Deprecated가 붙은 대상을 작성하여 컴파일 할 경우 컴파일 경고가 나긴 하지만 코드는 돌아간다.


3. @FunctionalInterface
함수형 인터페이스를 선언할 때 해당 어노테이션을 선언하면, 컴파일러가 함수형 인터페이스를 올바르게 선언했는지 확인하고 잘못 선언했을 경우 오류를 발생시킨다.
필수는 아니지만 @Override 처럼 잘못 정의할 수 있는 실수를 사전에 방지할 수 있다.

4. @SuppressWarnings
@SuppressWarnings 는 컴파일 시점에 컴파일러가 알려주는 경고 메세지를 억제할 때 사용한다.
보통 경고는 발생하면 무시하고 넘어가도 되지만, 문제를 해결한 경고의 경우 @SuppressWarnings 를 사용해서 컴파일 시점에 보이지 않게 함으로써, 다른 오류를 놓치지 않게 한다.

@SuppressWarnings 으로 억제할 수 있는 경고는 deprecation , unchecked , rawtypes , varargs 등.. 이 있다.
	ㄴ 주로 사용하는 것은 위의 4가지 이며, JDK 버전이 올라가면서 새로운 경고 메세지가 발생할 수 있다.
@SuppressWarnings() 어노테이션 괄호안에 억제하려고 하는 경고를 문자열로 제공하면 된다.
ex ) 
    @SuppressWarnings("deprecation")
    public static void main(String[] args) {
        Date date = new Date(2000 , Calendar.APRIL, 2);
    }
위의 예제는 deprecation 됨으로써 발생하는 오류를 출력되지 않게 억제한다.
만약 2개 이상의 경고를 억제하려면 아래의 예제와 같이 {} 괄호를 이용해서 여러 문자열을 기입하면 된다.
@SuppressWarnings({"deprecation" , "rawtypes" , "unchecked"})
public static void main(String[] args) {
	Date date = new Date(2000 , Calendar.APRIL, 2);
	ArrayList arrayList = new ArrayList();
	arrayList.add(date);
}

- 경고 메세지 종류 확인
만일 JDK 버전이 올라가면서 새로운 경고 메세지가 추가되는데, 추가된 경고 메세지를 확인하려면 컴파일할 때 -Xlint 옵션을 넣으면 경고 메세지의 종류를 알 수 있다.
PS 경로\backend-study\java> javac -Xlint .\src\l_annotation\AnnotationStudy.java
.\src\l_annotation\AnnotationStudy.java:17: warning: [rawtypes] found raw type: List
    public static void a(List a) {
                         ^
  missing type arguments for generic class List<E>
  where E is a type-variable:
    E extends Object declared in interface List
1 warning

위의 내용은 컴파일할 때 -Xlint 옵션을 통해 경고 메세지를 나오게 했다. 경고 메세지 내부에 [] 괄호 안에 있는 내용이 경고메세지 종류이다. ( [rawtypes] )
이를 억제하게 하려면 @SuppressWarnings("rawtypes") 으로 지정하면 된다.

# -Xlint:unchecked 로 지정하면 unchecked 와 관련된 경고 메세지만 나오게 된다.

5. @SafeVarargs
메서드에 선언된 가변인자의 타입이 non-reifiable 타입일 경우, 해당 메서드를 선언한 곳에서 unchecked 경고가 발생한다.
해당 코드의 문제가 없다면 @SafeVarargs 를 사용하여 억제한다.

# 해당 어노테이션은 오버라이드 될 수 있는 메서드에서는 사용될 수 없다.
# non-reifiable 은 컴파일 이후에 제거되는 타입으로 제네릭은 여기에 해당된다. reifiable 은 컴파일 이후에 제거되지 않는 타입으로 기본 자료형 ( int , double ) , 객체 ( String , Objects ) 등이 될 수 있다.

ex )
@SafeVarargs
public static <T>void safeTest(T... a) {
	for(int i = 0; i < a.length; i++) {
		System.out.println(a[i]);
	}
}

가변인자가 non-reifiable 일 때 해당 오류가 발생하는 이유는 타입 안정성이 떨어지기 때문이다. 즉 T 는 컴파일 시점에 Object로 바뀌기 때문에 어떠한 타입의 객체가 들어올 수 있기 때문이다.

# @SafeVarargs 는 @SuppressWarnings("unchecked") 를 대신 사용하여도 경고를 무시할 수 있다.

[ 메타 에너테이션 ]
메타 어노테이션은 어노테이션을 위한 어노테이션으로, 어노테이션을 정의할 때 적용되는 대상 ( target ) 이나 유지 기간 ( retention ) 등을 정의하는 데 사용된다.

1. @Target
해당 어노테이션이 적용될 수 있는 대상을 지정한다.
여러개로 지정한다면 {} 괄호를 이용하여 배열로 나열하면 된다.
ex ) @Target({TYPE, FIELD, METHOD, PARAMETER, CONSTRUCTOR, LOCAL_VARIABLE})
ANNOTATION_TYPE - 어노테이션
CONSTRUCTOR - 생성자
FIELD - 필드 ( 멤버변수, enum 상수 ) ( 기본형에 사용된다 )
LOCAL_VARIABLE - 지역변수
METHOD - 메서드
PACKAGE - 패키지
PARAMETER - 매개변수
TYPE - 타입 ( 클래스, 인터페이스, enum )
TYPE_PARAMETER - 타입매개변수
TYPE_USE - 타입이 사용되는 모든 곳 ( 참조형에 사용된다. )
# 위의 값들은 java.lang.annotation.ElementType 이라는 열거형에 정의되어 있다.

    @Target(TYPE)
    public @interface MyTypeAnnotation {}

    @Target(FIELD)
    public @interface MyFieldAnnotation {}

    @Target(TYPE_USE)
    public @interface MyTypeUseAnnotation {}

    @MyTypeAnnotation
    class MyClass {

        @MyTypeUseAnnotation
        MyClass clazz;
        
        @MyFieldAnnotation
        int a;
    }

TYPE은 타입을 선언할 때 사용할 수 있고, TYPE_USE 는 해당 타입의 변수가 선언될 때 사용할 수 있다는 것이다.

2. @Retention
애너테이션이 유지되는 기간을 지정하는데 사용된다. 유지 정책은 아래와 같다.
SOURCE - 소스 파일에만 존재, 클래스파일에는 존재하지 않음.
CLASS - 클래스 파일에 존재 실행시에 사용불가 ( 기본값 )
RUNTIME 클래스 파일에 존재, 실행시에 사용가능

@Override와 @SuppressWarnings 처럼 컴파일러가 사용하는 어노테이션은 SOURCE 이다.
RUNTIME은 실행 시 '리플렉션'을 통해 클래스 파일에서 어노테이션의 정보를 읽어 처리할 수 있다.
CLASS는 클래스 파일에 어노테이션 정보가 있지만, 클래스 파일이 JVM에 로딩될 때 해당 어노테이션을 사용할 수 없다. ( 즉, 실행시에 사용할 수 없어서 잘 사용하지 않는다. ) 

3. @Documented
해당 어노테이션의 정보가 javadoc 를 통해 생성된 문서에 포함되게 한다.

4. @Inherited
해당 어노테이션이 자손 클래스에도 적용되게 한다.

즉 @Inherited 가 붙은 어노테이션을 조상 클래스에 붙이면, 자손 클래스도 해당 어노테이션을 상속받는다.

5. @Repeatable
하나의 대상에 여러개의 어노테이션을 붙일 수 있게 한다. 단, 여러번 선언된 어노테이션들을 하나로 다루기 위해 @Repeatable 인자 값으로 어노테이션을 처리할 어노테이션을 추가로 지정해주어야 한다.

    @Repeatable(Todos.class)
    public @interface Todo {
        String value();
    }

    public @interface Todos {
        Todo[] value();
    }

    @Todo("todo1")
    @Todo("todo2")
    public static void main(String[] args) {



    }
	
6. @Native
네이티브 메서드에 의해 참조되는 상수 필드에 붙이는 어노테이션이다.

네이티브 메서드는 JVM이 설치된 OS의 메서드를 말한다.
public final native Class<?> getClass(); // 이는 Object에 정의되어 있는 네이티브 메서드이다.

네이티브 메서드는 보통 C언어로 작성하지만, Java 로 작성하는 경우도 있다. 만약 Java로 작성하는 경우 위의 코드처럼 구현부는 없고 선언부만 있다. ( 추상 클래스 처럼 )
Object 클래스에서는 네이티브 메서드는 자바로 정의되어 있기 때문에 호출하는 방법은 일반 메서드와는 같지만, 실제로 실행되는 것은 OS의 메서드이다.
단, 위와 같이 선언만 하면 되는 것이 아니라 JNI(Java Native Interface) 를 이용하여 네이티브 메서드와 OS의 메서드를 연결해주는 작업을 해야 한다.

# 정리하면, 네이티브 메서드는 JVM이 설치된 OS의 메서드를 말하며, OS 메서드와 자바 메서드를 Java Native Interface로 연결하여 자바의 메서드를 활용해서 OS의 메서드를 호출하는 것이다.
# 즉, OS의 메서드를 JAVA에서 호출할 수 있게 Java Native Interface로 연결한다.