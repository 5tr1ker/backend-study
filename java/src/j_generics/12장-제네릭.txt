[ 제네릭 ]
제네릭은 다양한 타입의 객체가 사용될 수 있는 메서드나 클래스를 컴파일 시점에 타입 체크를 해주는 기능이다.
컴파일 시점에 타입을 체크하기 때문에, 객체의 타입 안정성을 높이고 형변환의 번거로움이 줄어든다.

# 타입 안정성은 의도한 타입과는 다른 타입이 저장되는 것을 막고, 객체를 꺼내올 때 다른 타입이 반환되는 문제를 막는다.
# 제네릭은 다양한 타입의 객체가 저장됨으로써 꺼내온 객체의 타입을 체크하고 형 변환하는 번거로움을 줄여준다.

간단히 말하면 다룰 객체 ( 저장될 객체 ) 의 타입을 미리 명시해준다.

제네릭 타입은 클래스와 메서드에 선언할 수 있다.

- 제네릭 클래스
public class GenericClazz <T> {

    public T resource;

    public T getResource() {
        return resource;
    }

    public void setResource(T resource) {
        this.resource = resource;
    }

}
우선 위와 같이 클래스 이름 옆에 <T> 와 타입들을 T 로 붙인다. ( 자료형이 들어갈 수 있는 위치 )
이때 T를 타입 변수라고 한다. 예제에선 타입 변수를 T로 지정했는데 T가 아닌 다른 문자를 사용해도 된다.
# 다만 ArrayList<E> 는 Element의 첫 글자, Map<K,V> 은 Key, Value 에서 따온 것 처럼 의미 있는 글자를 사용하는 것이 좋다.

만약 타입 변수가 여러개인 경우 구분자를 통해서 작성하면 된다. ex ) Map<K,V>
여기서 사용된 각각의 타입 변수는 기호만 다를 뿐 임의의 참조형 타입인 것은 같다.

이제 위의 제네릭 클래스에서 객체를 생성할 때, 타입 변수 대신 실제로 사용할 자료형을 넣어주면 된다.
GenericClazz<String> genericClazz = new GenericClazz<>();
genericClazz.setResource("test"); # 물론 String 타입의 제네릭이기 떄문에 Int 형을 넣으면 오류가 발생한다.
System.out.println(genericClazz.getResource());

만약 위의 코드와 같이 타입 변수를 String 으로 지정하면 제네릭 클래스는 아래의 예제와 똑같이 된다.
public class GenericClazz {

    public String resource;

    public String getResource() {
        return resource;
    }

    public void setResource(String resource) {
        this.resource = resource;
    }
}
이 처럼 다양한 타입이 사용될 수 있는 클래스에서 특정 타입만 다룰 수 있게 제한할 수 있다.
# 물론 String 만 다룰 것이라면 위의 코드처럼 작성해도 된다.

- 제네릭 용어

public class GenericClazz <T> {}..
GenericClazz <T> : 제네릭 클래스. T의 GenericClazz 또는 T GenericClazz
T : 타입 변수 또는 타입 매개변수. ( T는 타입 문자 / T GenericClazz 의 타입 변수 )
GenericClazz : 원시 타입

GenericClazz<T> 에 타입 매개변수에 타입을 지정하는 것을 "제네릭 타입 호출" 이라고 하고, 지정된 타입 ex) String 을 매개변수화된 타입 이라고 한다.
GenericClazz<String> = 제네릭 타입 호출
	ㄴ 호출된 String = 매개변수화된 타입
	
컴파일 후에 GenericClazz<String> 는 이들의 원시 타입인 GenericClazz 로 바뀐다. 즉 제네릭 타입이 제거된다.

제네릭의 타입 변수는 static 과 함께 사용될 수 없다. 그 이유는 타입 변수는 인스턴스변수로 취급되며, static 멤버는 모든 객체를 동일하게 처리해야 하기 떄문이다.
	ㄴ 타입 변수는 여러 타입을 가질 수 있기 때문에 동일하다고 할 수 없다.
그리고 타입 변수의 배열의 참조 변수를 선언하는 것은 가능하나, 배열을 생성하는 것은 안된다. 그 이유는 new 연산자와 instanceof 연산자는 컴파일 시점에 타입 변수가 정확히 어떤 타입인지 알 수 없기 떄문이다.
	ㄴ 만약 타입 변수 배열을 생성해야 한다면 Object 배열을 생성해서 복사한 다음, T[] 로 형변환하는 방법이 있다.

GenericClazz<String> genericClazz = new GenericClazz<Integer>();
그리고 매개변수화된 타입이 일치해야 한다. 두 타입이 상속관계에 있다고 해도 참조 변수와 생성자의 매개변수화된 타입이 다르면 컴파일 오류가 발생한다.
#단 제네릭 클래스가 상속관계에 있는 경우, 매개변수화된 타입이 일치하면 밑의 코드와 같이 사용할 수 있다.
SuperGenericClazz<String> genericClazz = new GenericClazz<String>();

물론 매개변수화된 타입과 다른 타입의 객체는 넣을 수 없지만, 그 자손 타입은 넣을 수 있따.


그리고 JDK1.7 부터는 추정이 가능한 경우 타입을 생략할 수 있다. 제네릭 클래스의 참조 변수의 타입만으로 생성자의 타입도 유추할 수 있으므로, 생성자 부분에 타입을 생략할 수 있다.
SuperGenericClazz<String> superGenericClazz = new GenericClazz<>();
 
- 타입 변수의 제한
GenericClazz<T> 를 통해서 특정된 하나의 타입만 사용할 수 있지만, 여전히 모든 종류의 클래스가 매개변수화될 수 있다.
이때 특정 종류의 클래스만 매개변수화될 수 있게 하려면 extends 를 사용한다.

public class GenericClazz <T extends CustomResource & AutoCloseable> extends SuperGenericClazz<T>{

    public T resource;

    public T getResource() {
        return resource;
    }

    public void setResource(T resource) {
        this.resource = resource;
    }

}
위의 예제는 매개변수화 될 수 있는 타입에 제한을 두었다. CustomResource 을 상속받은 클래스이며, AutoCloseable 인터페이스를 구현한 클래스이여야 한다는 것이다.
여기서 인터페이스를 구현해야 한다면 implements 가 아니라 extends 로 정의해주어야 한다. 그리고 2개 이상의 클래스 혹은 인터페이스를 구현 및 확장해야 한다면 & 를 구분자로 여러개 입력해주면 된다.

이제 GenericClazz 를 사용하기 위해서 CustomResource 를 상속받아야하고 AutoCloseable 인터페이스를 구현해야 한다.
# 물론 제네릭도 다형성의 영향을 받기 떄문에 CustomResource 의 자손들도 타입 변수가 될 수 있으며, CustomResource 가 매개변수화된 타입이라 하더라도 setResource() 메서드에 자손 클래스가 올 수 있다.