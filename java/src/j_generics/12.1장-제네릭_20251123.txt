[ 제네릭 ]
제네릭은 다양한 타입의 객체가 사용될 수 있는 메서드나 클래스를 컴파일 시점에 타입 체크를 해주는 기능이다.
컴파일 시점에 타입을 체크하기 때문에, 객체의 타입 안정성을 높이고 형변환의 번거로움이 줄어든다.

# 타입 안정성은 의도한 타입과는 다른 타입이 저장되는 것을 막고, 객체를 꺼내올 때 다른 타입이 반환되는 문제를 막는다.
# 제네릭은 다양한 타입의 객체가 저장됨으로써 꺼내온 객체의 타입을 체크하고 형 변환하는 번거로움을 줄여준다.

간단히 말하면 다룰 객체 ( 저장될 객체 ) 의 타입을 미리 명시해준다.

제네릭 타입은 클래스와 메서드에 선언할 수 있다.

- 제네릭 클래스
public class GenericClazz <T> {

    public T resource;

    public T getResource() {
        return resource;
    }

    public void setResource(T resource) {
        this.resource = resource;
    }

}
우선 위와 같이 클래스 이름 옆에 <T> 와 타입들을 T 로 붙인다. ( 자료형이 들어갈 수 있는 위치 )
이때 T를 타입 변수라고 한다. 예제에선 타입 변수를 T로 지정했는데 T가 아닌 다른 문자를 사용해도 된다.
# 다만 ArrayList<E> 는 Element의 첫 글자, Map<K,V> 은 Key, Value 에서 따온 것 처럼 의미 있는 글자를 사용하는 것이 좋다.

만약 타입 변수가 여러개인 경우 구분자를 통해서 작성하면 된다. ex ) Map<K,V>
여기서 사용된 각각의 타입 변수는 기호만 다를 뿐 임의의 참조형 타입인 것은 같다.

이제 위의 제네릭 클래스에서 객체를 생성할 때, 타입 변수 대신 실제로 사용할 자료형을 넣어주면 된다.
GenericClazz<String> genericClazz = new GenericClazz<>();
genericClazz.setResource("test"); # 물론 String 타입의 제네릭이기 떄문에 Int 형을 넣으면 오류가 발생한다.
System.out.println(genericClazz.getResource());

만약 위의 코드와 같이 타입 변수를 String 으로 지정하면 제네릭 클래스는 아래의 예제와 똑같이 된다.
public class GenericClazz {

    public String resource;

    public String getResource() {
        return resource;
    }

    public void setResource(String resource) {
        this.resource = resource;
    }
}
이 처럼 다양한 타입이 사용될 수 있는 클래스에서 특정 타입만 다룰 수 있게 제한할 수 있다.
# 물론 String 만 다룰 것이라면 위의 코드처럼 작성해도 된다.

- 제네릭 용어

public class GenericClazz <T> {}..
GenericClazz <T> : 제네릭 클래스. T의 GenericClazz 또는 T GenericClazz
T : 타입 변수 또는 타입 매개변수. ( T는 타입 문자 / T GenericClazz 의 타입 변수 )
GenericClazz : 원시 타입

GenericClazz<T> 에 타입 매개변수에 타입을 지정하는 것을 "제네릭 타입 호출" 이라고 하고, 지정된 타입 ex) String 을 매개변수화된 타입 이라고 한다.
GenericClazz<String> = 제네릭 타입 호출
	ㄴ 호출된 String = 매개변수화된 타입
	
컴파일 후에 GenericClazz<String> 는 이들의 원시 타입인 GenericClazz 로 바뀐다. 즉 제네릭 타입이 제거된다.

제네릭의 타입 변수는 static 과 함께 사용될 수 없다. 그 이유는 타입 변수는 인스턴스변수로 취급되며, static 멤버는 모든 객체를 동일하게 처리해야 하기 떄문이다.
	ㄴ 타입 변수는 여러 타입을 가질 수 있기 때문에 동일하다고 할 수 없다.
그리고 타입 변수의 배열의 참조 변수를 선언하는 것은 가능하나, 배열을 생성하는 것은 안된다. 그 이유는 new 연산자와 instanceof 연산자는 컴파일 시점에 타입 변수가 정확히 어떤 타입인지 알 수 없기 떄문이다.
	ㄴ 만약 타입 변수 배열을 생성해야 한다면 Object 배열을 생성해서 복사한 다음, T[] 로 형변환하는 방법이 있다.

GenericClazz<String> genericClazz = new GenericClazz<Integer>();
그리고 매개변수화된 타입이 일치해야 한다. 두 타입이 상속관계에 있다고 해도 참조 변수와 생성자의 매개변수화된 타입이 다르면 컴파일 오류가 발생한다.
#단 제네릭 클래스가 상속관계에 있는 경우, 매개변수화된 타입이 일치하면 밑의 코드와 같이 사용할 수 있다.
SuperGenericClazz<String> genericClazz = new GenericClazz<String>();

물론 매개변수화된 타입과 다른 타입의 객체는 넣을 수 없지만, 그 자손 타입은 넣을 수 있따.


그리고 JDK1.7 부터는 추정이 가능한 경우 타입을 생략할 수 있다. 제네릭 클래스의 참조 변수의 타입만으로 생성자의 타입도 유추할 수 있으므로, 생성자 부분에 타입을 생략할 수 있다.
SuperGenericClazz<String> superGenericClazz = new GenericClazz<>();
 
- 타입 변수의 제한
GenericClazz<T> 를 통해서 특정된 하나의 타입만 사용할 수 있지만, 여전히 모든 종류의 클래스가 매개변수화될 수 있다.
이때 특정 종류의 클래스만 매개변수화될 수 있게 하려면 extends 를 사용한다.

public class GenericClazz <T extends CustomResource & AutoCloseable> extends SuperGenericClazz<T>{

    public T resource;

    public T getResource() {
        return resource;
    }

    public void setResource(T resource) {
        this.resource = resource;
    }

}
위의 예제는 매개변수화 될 수 있는 타입에 제한을 두었다. CustomResource 을 상속받은 클래스이며, AutoCloseable 인터페이스를 구현한 클래스이여야 한다는 것이다.
여기서 인터페이스를 구현해야 한다면 implements 가 아니라 extends 로 정의해주어야 한다. 그리고 2개 이상의 클래스 혹은 인터페이스를 구현 및 확장해야 한다면 & 를 구분자로 여러개 입력해주면 된다.

이제 GenericClazz 를 사용하기 위해서 CustomResource 를 상속받아야하고 AutoCloseable 인터페이스를 구현해야 한다.
# 물론 제네릭도 다형성의 영향을 받기 떄문에 CustomResource 의 자손들도 타입 변수가 될 수 있으며, CustomResource 가 매개변수화된 타입이라 하더라도 setResource() 메서드에 자손 클래스가 올 수 있다.

- 와일드 카드

static 메서드에서 타입 매개변수 T를 매개변수로 사용할 수 없다. 사용하기 위해선 제네릭을 사용하지 않거나, 타입을 지정해주어야 한다.
하지만, 그러면 특정 타입만 받을 수 있기 때문에 매개변수화된 타입을 달리해서 여러개의 메서드를 만들 수도 없다. ( 오버로딩을 할 수 없다. )
그 이유는 매개변수화된 타입만 다른 여러 메서드를 만들 경우 중복된 메서드로 간주되기 떄문이다.
# 제네릭은 컴파일러가 컴파일 시점에 제네릭 타입을 제거하기 때문이다.

이때 다양한 타입을 받기 위해선 와일드 카드인 '?' 를 사용하면 어떠한 타입이 올 수 있다.
이때 ? 는 Object와 같기 때문에 exgtends 와 super를 이용해서 각각 상한과 하한을 제한할 수 있다.
- <? extends T> 와일드 카드의 상한 제한, T와 그 자손들만 가능
- <? super T> 와일드 카드의 하한 제한, T와 그 조상들만 가능
- <?> 제한 없음. Object와 동일

    public static void printInfo(GenericClazz<? extends CustomResource> resource) {

    }
즉, 와일드 카드는 모든 제네릭 타입을 받을 수 있게 사용되며, static 메서드에서도 사용할 수 있다.
# 이때 와일드 카드는 &를 사용할 수 없다.
만약 위와 같이 <? extends CustomResource> 를 지정하게 되면, CustomResource 타입이거나 그 자손들이 올 수 있다. ( super 일 경우 CustomResource 이거나, 그 조상들만 올 수 있다. )

만약 하단과 같이 Object 를 하게 되면, 모든 타입의 GenericClazz 를 받게 된다. 이때 GenericClazz 의 매개변수화된 타입이 CustomResource 자손이라는 보장이 없다.
그렇기 떄문에 매개변수로 넘어온 resource 변수는 다른 타입의 변수가 올 수 있어 오류가 발생할 수 있다.
(GenericClazz<? extends Object> resource) 

[ 제네릭 메서드 ]
제네릭 메서드는 메서드의 선언부테 제네릭 타입이 선언된 메서드를 말한다.
제네릭 타입은 메서드의 반환 타입 바로 앞에 온다.
public static <T> void sort(List<T> list, Comparator<? super T> c)

public class GenericMethodStudy<T> {

    public static <T>void callMethod(T index) {
		System.out.println("Calling method " + index);
    }

}
제네릭 클래스에 정의된 타입 매개변수와 제네릭 메서드에 정의된 타입 매개변수는 별개로 구분된다. 만약 같은 타입 문자라 하더라도 별개로 취급된다.
그리고 위의 코드와 같이 static 메서드에서는 제네릭을 사용할 수 없지만, 메서드에 제네릭 타입을 선언하고 사용하는 것은 가능하다.
# 즉, static 메서드는 제네릭 클래스의 타입 변수를 사용할 수 없는 것이다.
# 제네릭 메서드는 제너릭 클래스가 아닌 곳에서 사용할 수 있다.
 
GenericMethodStudy.<String>callMethod("input Test");
그리고 제네릭 메서드를 호출할 때 메서드 이름 앞에 매개변수화된 타입을 지정해주어야 한다.

다만 컴파일러가 타입을 유추할 수 있기 때문에 아래와 같이 타입의 이름을 제거하고 메서드의 이름만 사용할 수 있다.
GenericMethodStudy.callMethod("input Test");
callMethod("input Test");

[ 제네릭의 형변환 ]
ArrayList list = new ArrayList();
ArrayList<String> result = (ArrayList<String>) list;

제네릭 타입과 원시 타입 ( 논제네릭 타입 ) 간에 형 변환은 경고가 발생하긴 하지만 가능하다.
ArrayList<String> list_2 = new ArrayList<>();
ArrayList<Integer> list_3 = (ArrayList<Integer>) list_2;

단 위와 같이 매개변수화된 타입이 다른 경우에는 오류가 발생한다.

ArrayList<?> list_3 = new ArrayList<String>();
ArrayList<String> list_4 = (ArrayList<String>) list_3;
또한 <?> 는 <T> 로도 형 변환이 가능하다.

ArrayList<? extends Object> list_5 = (ArrayList<? extends Object>) list_3;
그리고 <?> 과 <?> 로도 형 변환이 가능하다.

[ 제네릭 타입 제거 ]
컴파일러는 제네릭 타입을 이용하여 소스 파일을 체크하고, 필요한 곳에 형변환을 넣어주며 제네릭 타입을 제거한다.
실제로 컴파일이 된 파일을 보면 제네릭은 볼 수 없다. 이렇게 하는 이유는 제네릭이 생기기 전 소스 코드와의 호환성을 위해서이다.

우선 제네릭 타입의 경계를 제거 한다.
<T extends Fruit> 라면 T를 Fruit 로 바꾼다, <T> 인 경우엔 Object로 바꾼다.

이후 타입이 일치하지 않은 경우엔 형 변환을 추가한다. 예를 들면 List의 getList는 Object를 반환하기 때문에 이에 맞도록 형 변환을 해야 한다. 