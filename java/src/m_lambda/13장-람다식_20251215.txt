[ 람다식 ]
람다식은 메서드를 간략하고 명확한 하나의 식으로 표현할 수 있게 해준다.
람다식은 JDK 1.8 부터 나온 개념으로 함수형 언어를 활용할 수 있게 되었다.
따라서 람다식으로 인해 자바는 객체지향언어 뿐만이 아니라 함수형 언어로 활용될 수 있게 되었다.

메서드를 람다식으로 표현하면 반환값과 메서드명이 사라지기 때문에 익명 함수라고도 한다.
- 람다식의 장점
1. 간단한 메서드를 간략하고 명확한 식으로  표현할 수 있다.
2. 메서드를 변수처럼 다룰 수 있다.

# 람다식은 함수? or 메서드?
# 메서드는 함수와 의미는 같지만, 객체의 행위나 동작을 의미하며, 클래스 내에 속해야 한다는 특징을 가지고 있다.
# 다만 람다식은 클래스 내에 속하지 않기 때문에 함수에 가깝다.

- 람다식의 선언
람다식은 익명 함수 답게 반환 타입과 메서드 명이 없으며 매개변수 타입선언부와 몸통을 -> 로 연결하면 된다.
람다식은 반환 타입이나 매개변수 타입을 추론할 수 있기 때문에 자료형을 생략할 수 있다.
# 메서드의 return 이 있을 경우 이를 식으로 대체할 수 있다. 이때 식의 연산 결과가 반환 값이 된다.
# 물론 문장이 아닌 식 이기 때문에 ; 를 생략할 수 있다.

만약 매개변수 타입이 하나인 경우 괄호 () 를 생략할 수 있고, {} 괄호안에 문장이 하나만 있는 경우 {} 를 생략할 수 있다.
(a) -> a * a  -->   a -> a * a
(a , b) -> { System.out.println(a + b); } --> (a , b) -> System.out.println(a + b)
# 이때 매개변수 타입이 있으면 ()를 생략할 수 없고, return 문이 있는 경우 {} 를 생략할 수 없다.

@FunctionalInterface
interface Math {
	int Calc(int first);
}

Math result = a -> a * a;
System.out.println(result.Calc(5));

[ 함수형 인터페이스 ]
함수형 인터페이스는 추상 메서드가 단 1개 뿐인 인터페이스로, 람다 표현식의 타입이 되는 인터페이스이다.
즉, 람다식을 다루기 위한 인터페이스를 함수형 인터페이스라고 부르게 되었다.

# 함수형 인터페이스는 추상 메서드가 단 1개여야 하지만, default 메서드와 static 메서드는 갯수 제한이 없다.
# 또한 @FunctionalInterface 를 붙이면 컴파일러가 함수형 인터페이스를 올바르게 정의 했는지 확인해준다.

모든 메서드는 클래스에 포함되는 것처럼 람다식은 익명 클래스의 객체이다. 
결국 람다식도 익명 객체의 메서드이기 때문에 람다식을 호출하기 위해선 참조 변수가 필요하다.
때문에, 람다식의 참조 변수 역할을 하는 것이 함수형 인터페이스다.
함수형 인터페이스 안에 있는 추상 메서드의 선언부와 람다식의 메서드 선언부와 동일 해야 한다.
# 익명 클래스의 객체를 생성할 때, 람다식으로 간단하게 표현할 수 있다.
# 아래의 예제 처럼 복잡한 로직을 아래 람다식으로 간단하게 처리할 수 있다.
interface Math {
	int calc(int input);
}

Math m1 = new Math() {
@Override
	public int calc(int input) {
    	return 0;
	}
};

Math m2 = (a) -> a * a;

즉, 함수형 인터페이스는 추상 메서드가 1개 뿐인 인터페이스이고, 해당 추상 메서드를 람다식으로 간결하고 명확하게 표현한다. 
이처럼 인터페이스를 구현한 익명 객체를 람다식으로 대체할 수 있는 이유는 람다식도 익명 객체이기 때문이다.
# 물론 익명 객체의 선언부와 람다시의 선언부와 반환값은 일치해야 한다.


- 반환 타입이 함수형 인터페이스일 때
또한 메서드의 매개변수가 함수형 인터페이스일 경우, 해당 메서드를 호출할 때 람다식이 담긴 참조변수를 전달하거나, 람다식을 직접 제공할 수 있다.
public static void printLambda(Math m) {
	System.out.println("결과 값 : " + m.Calc(50));
}
printLambda((a) -> a * a + 2);


그리고 반환 타입이 함수형 인터페이스일 경우 람다식을 반환할 수 있다.
public static Math returnLambda(int index) {
	return (input) -> index - input;
}
Math myLambda = returnLambda(50);
System.out.println(myLambda.Calc(5));

이처럼 람다식을 참조변수로 다룰 수 있기 때문에 메서드를 통해서 함수를 주고 받을 수 있다.

[ java.util.function 패키지 ]
java.util.function 패키지는 자주 사용되는 메서드의 형식을 함수형 인터페이스로 정의해 놓았다.
자주 사용되는 메서드를 정의해 놓았기 때문에, 코드의 중복을 줄이고 유지보수 성을 높일 수 있다.

자주 사용하는 함수형 인터페이스는 다음과 같다.
java.lang.Runnable	void run()	매개변수와 반환 값이 없다.
Supplier<T>			T get()		매개변수는 없고, 반환 값이 있다.
Consumer<T>			void accept(T t)	매개변수는 있고, 반환 값이 없다.
Function<T,R>		R apply(T t) 매개변수와 반환 값이 있다.
Predicate<T>		boolean test(T t) 조건식을 표현하는데 사용

Predicate 는 Function의 변형으로 반환 타입이 boolean 이며, 조건식을 람다식으로 표현하기 위해 사용된다.

- 매개 변수가 2개인 함수형 인터페이스
매개 변수가 2개인 함수형 인터페이스는 이름 앞에 Bi 가 붙는다.
BiConsumer<T,U>		void accept(T t, U u);
BiPredicate<T,U>	boolean test(T t, U u);
BiFunction<T,U,R>	R apply(T t, U u);

그 이상 3개 이상의 매개 변수를 갖는 함수형 인터페이스가 필요하면 직접 선언해야 한다.

- UnaryOperator와 BinaryOperator
Function의 또 다른 변형으로 이들은 매개변수의 타입과 반환 타입이 모두 일치한다는 점을 제외하고는 Function 과 같다.
UnaryOperator<T>	T apply(T t)
BinaryOperator<T> 	T apply(T t, T t);


이들을 사용하는 방법은 다음과 같다.
Consumer<Integer> consumer = a -> System.out.println(a);
consumer.accept(50);

Supplier<String> supplier = () -> "index";
System.out.println(supplier.get());

Predicate<Integer> predicate = i -> i % 2 == 0;
System.out.println(predicate.test(5));

- 기본형을 사용하는 함수형 인터페이스
제네릭 타입 뿐만이 아니라 기본형을 사용하는 함수형 인터페이스도 제공한다.

DoubleToIntFunction	int applyAsInt(double d)	입력은 Double 타입, 출력은 Int 타입 ( 다른 타입으로도 가능 하다. )
ToIntFunction<T>	int applyAsInt(T value)	입력은 제네릭, 출력은 int 타입
intFunction<R>		R apply(T t, U u) 입력은 int 타입, 출력은 제네릭
ObjIntConsumer<T>	void accept(T t, U u) 입력은 제네릭이고 출력은 없다.

DoubleToIntFunction doubleToIntFunction = a -> (int) (a * 100);
System.out.println(doubleToIntFunction.applyAsInt(5.32));

# 밑에 IntUnaryOperator 는 int를 입력 받아서 int를 출력한다.
# Integer Function<Integer> 이나, IntFunction<Integer> 보다 오토박싱&언박싱 횟수가 적어 성능이 더 좋다.
IntUnaryOperator integerIntUnaryOperator = a -> a * a;
System.out.println(integerIntUnaryOperator.applyAsInt(5));

# 만약 매개 변수와 반환 타입이 같다면 Function 대신 UnaryOperator 를 사용하자.

[ Function의 합성과 Predicate의 결합 ]

1. Function의 합성
java.util.Function 패키지의 함수형 인터페이스에는 추상메서드 외에도 default 메서드와 static 메서드가 제공된다.
Function 패키지에 있는 andThen , compose , identity 는 식 간의 결합을 위해 사용된다.

a.andThen(b) : a 식 다음에 b 식을 실행
a.compose(b) : b식 다음에 a 식을 실행
a.identity() : a 식을 그대로 반환 ( 항등 함수 ) 
# a 와 b 에는 람다식이 들어가면 된다.

2. Predicate의 결합
and() , or() , negate() 로 연결해서 여러 개의 조건식을 하나로 결합할 수 있다.

a.and(b) : a 와 b가 true 이여야 한다.
a.or(b) : a와 b 중에 하나만 true 이면 된다.
a.negate() : 조건식이 부정이 된다.
Predicate.isEquals() : 두 대상이 같은지 비교하는 Predicate를 만든다. 먼저 isEquals(a) 로 비교대상을 하나 지정 후 .test(b) 를 통해 두 대상이 같은지 확인한다.

[ 메서드 참조 ]
람다식이 메서드를 하나만 호출하는 경우 '메서드 참조'라는 방법으로 람다식을 더 간략하게 쓸 수 있다.

Function<String, Integer> fcTest = Integer::parseInt;
System.out.println(fcTest.apply("50"));
# 위의 식의 경우 컴파일러는 parseInt 메서드 혹은 fcTest 변수의 타입을 보고 타입을 유추한다.

이때 같은 이름의 메서드가 존재할 수 있으므로 클래스::메서드 형식으로 메서드 참조를 구현해야 한다.
즉, 하나의 메서드만 호출하는 람다식은 '클래스::메서드' 또는 '참조변수::메서드' 으로 바꿀 수 있다.

참조변수::메서드의 경우, 이미 생성된 객체의 메서드를 호출할 경우에 사용될 수 있다.

# 비슷하게 생성자를 호출할 때에도 클래스명::new 를통해 생성자를 호출할 수 있다.
	ㄴ 생성자를 호출할 때 생성자의 매개변수에 맞는 함수형 인터페이스를 선택해야 한다. 예를 들어 매개변수가 int인 MyClass 클래스의 생성자는 Function<Integer, MyClass> 가 된다.
# 혹은 배열을 샐성할 때 int[]::new 를 통해서도 생성할 수 있다.