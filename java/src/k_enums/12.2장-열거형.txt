[ 열거형 ]
열거형은 JDK1.5 부터 등장하였으며 C언어의 열거형과는 달리 값 뿐만이 아니라 타입까지 관리할 수 있다.
자바의 열거형은 typesafe 한 enum 이라고 할 수 있다. 그 이유는 C언어는 타입이 달라도 값이 같으면 조건식의 결과가 true인데, Java의 경우 값이 같아도 값이 다르면 false를 반환한다.
# 상수 값이 바뀌면, 해당 상수를 사용하는 모든 소스를 다시 컴파일해야하지만, 열거형 상수를 사용하면 기존 소스를 컴파일하지 않아도 된다.

- 열거형의 사용
열거형을 정의하는 방법은 중괄호({}) 안에 상수의 이름을 나열하기만 하면 된다.
enum Hyundai {

    AVANTE , SONATA , GRANDEUR , KONA , TUCSON , SANTAFE , PALLISADE

}
System.out.println(Hyundai.AVANTE);
또한 열거형에 정의된 상수를 사용하는 방법은 "열거형이름.상수명" 으로 사용한다.

열거형 상수간에는 "==" 를 사용할 수 있어 빠른 성능을 제공하고 있다. 다만 비교연산자 같은 경우 < , > 를 사용할 수 없고 compareTo() 를 사용해야 한다.
if(Hyundai.SONATA != Hyundai.AVANTE) {
	System.out.println("두 차종은 다른 차종..");
}
System.out.println(Hyundai.GRANDEUR.compareTo(Hyundai.SONATA));

또한 열거형은 switch 문에서 활용될 수 있다. 다만 case 문에서는 열거형의 이름은 생략하고 상수명만 적어야 한다.
switch (Hyundai.GRANDEUR) {
    case AVANTE:
        System.out.println("아반뗴");
        break;
    case SONATA:
        System.out.println("쏘나타");
        break;
    case GRANDEUR:
        System.out.println("그랜저");
        break;
    default:
        System.out.println("??");
}

Hyundai[] hyundais = Hyundai.values();
System.out.println(Arrays.toString(hyundais));

또한 values() 메서드를 활용하면 열거형에 정의된 모든 상수를 배열로 반환한다.

또한 valueOf 메서드는 열거형 상수의 이름으로 열거형 참조를 얻을 수 있다.
System.out.println(Hyundai.valueOf("AVANTE"));

위의 values()와 valueOf() 는 모든 열거형이 가지고 있는 것으로 컴파일러가 자동으로 만들어준다.

- 모든 열거형의 조상 java.lang.Enum

모든 열거형의 최고 조상은 Enum 클래스에는 유용한 클래스들을 많이 제공하고 있다.
int ordinal() - 열거형 상수가 정의된 순서를 반환한다. ( 0 부터 )
T valueOf(Class<T> enumType, String name) - 지정된 이름에 일치하는 열거형 상수를 반환한다.
String name() - 열거형 상수의 이름을 문자열로 반환한다.
	ㄴ System.out.println(Hyundai.AVANTE.name());
	
- 열거형 인스턴스 멤버 추가
열거형 상수에 인스턴스 멤버를 추가하기 위해선 상수의 이름 옆에 원하는 값을 괄호와 함께 적어준다.
그리고 지정된 값을 저장하기 위한 인스턴스 변수와 생성자를 추가해주어야 한다.
# 이때 열거형 상수를 모두 정의한 다음, 멤버 변수와 생성자를 정의해야 한다.

enum Hyundai {

    AVANTE(1600) , SONATA(2000) , GRANDEUR(3500);

    private final int cc;
    Hyundai(int cc) {
        this.cc = cc;
    }

    public int getCc() {
        return cc;
    }

}

열거형의 생성자를 추가했다고 해서 객체를 생성할 수 있는 것은 아니다. 생성자는 제어자가 묵시적으로 private 로 된다.
필요하다면 2개 이상의 값을 지정할 수 있다. 다만 인스턴스 변수와 생성자를 추가해주어야 한다.
# 열거형 내부에는 비즈니스 로직이 포함된 메서드와 static 멤버를 선언할 수 있다.

- 열거형 추상 메서드
열거형 내부에 추상 메서드를 선언할 수 있다. 추상 메서드를 선언할 경우 모든 열거형 상수는 추상 메서드를 구현해야 한다.
enum Hyundai {

    AVANTE(1600) {
        @Override
        public double calculate0_100() {
            return 9.3;
        }
    }, SONATA(2000) {
        @Override
        public double calculate0_100() {
            return 8.8;
        }
    } , GRANDEUR(3500) {
        @Override
        public double calculate0_100() {
            return 7.9;
        }
    };

    private final int cc;
    public abstract double calculate0_100();
    Hyundai(int cc) {
        this.cc = cc;
    }

    public int getCc() {
        return cc;
    }

}

추상 메서드의 경우, 각 열거형 상수들이 각각 다른 비즈니스 로직을 가질 때 구현하며, 그러지 않을 경우 일반 메서드를 구현하는 것이 좋다.

