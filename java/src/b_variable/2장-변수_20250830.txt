[ 2025-08-22 ~ 2025-08-30 ]

변수 : 하나의 값을 메모리에 저장할 수 있는 공간이며, 값은 바뀔 수 있다.

변수의 초기화 : 변수를 사용하기 전, 특정 값으로 초기화 하는 것이다.
	ㄴ 지역변수는 사용하기 전 초기화를 반드시 해야하지만, 클래스 변수와 인스턴스 변수는 초기화를 생략할 수 있다.
	
변수 이름 규칙 ; 예약어를 사용할 수 없다. 클래스는 대문자로 시작하고 그 외에는 소문자로 시작한다. 
여러 단어가 사용될 경우 단어의 첫 글자는 대문자로하고 상수는 모두 대문자로 한다. 단 상수에도 여러 문자로 되어 있다면 _ 로 구분한다.
	ㄴ 자바 이름에는 유니코드를 작성할 수 있지만, 클래스 이름은 ASCII코드로 작성하는 것이 좋다. ( 유니코드를 사용 못하는 OS가 있다. )

자료형은 크게 기본형, 참조형으로 나뉜다.
	- 기본형 ( primitive Type ) : 실제 값을 저장하며 boolean, char , byte, short , int ,long , float , double 이 저장된다.
	- 참조형 ( reference Type ) : 값이 들어있는 주소를 저장하며 객체의 주소를 저장한다. 
보통 참조변수의 변수 타입은 클래스 이름으로 지정한다. ( 그리고 기본형이 아닌 모든 변수 타입은 참조형이다. )
참조형 변수 ( 참조 변수 ) 는 변수 값으로 null 또는 객체의 주소 값을 갖는다. ( JVM이 32bit을 경우 4byte크기, 64bit일 경우 8byte )

기본형 중 정수형은 int 를 많이 사용한다. ( CPU가 가장 효율적으로 처리할 수 있는 타입 )
값의 크기 ( byte단위 ) : boolean - 1 , char - 2 , byte - 1 , short - 2 , int - 4 , long - 8 , float - 4 , double - 8
값의 범위는 -2의 n-1승 ~ 2의 n-1승 -1 이때 n 은 bit 크기


상수 : 하나의 값을 저장할 수 있는 공간이지만 다른 값으로 변경할 수 없다.
final int a = 30;
또한 상수는 선언과 동시에 초기화를 해야한다. 다만 JDK 1.6 부터는 선언 후 초기화는 사용 전에 해도 된다. 다만
선언과 동시에 초기화 하는 것이 좋다.

리터럴 ( Literal ) : 상수 값의 그 자체 ( 1 , 30 , 'A' )
	ㄴ 사실 1, 30, 'A' 와 같은 값들은 모두 상수인데, 
	프로그래밍에서 상수는 한번 값을 저장하면 변경할 수 없는 공간으로 정의되었기 때문에 상터럴이라는 이름으로 불린다.
	
즉 변수 : 하나의 값이 저장되는 공간
상수 : 값이 한번 저장되면 변경할 수 없는 공간
리터럴 : 상수 값의 그 자체

? 리터럴도 상수 값인데, 굳이 상수와 구분해서 사용하는 이유
	- 리터럴 ( 100 ) 값에 의미 있는 이름을 부여하여 코드의 가독성을 높일 수 있다.
	ex ) final int WIDTH = 100; WIDTH * HEIGHT / 2 // 만약 리터럴 값만 넣었다면 무슨 값인지 이해하기 어려울 수 있다.
	또한 리터럴 값을 여러 곳에서 사용해야 한다면, 수정 시 여러번 수정해야 할 수 있지만, 상수 값에 저장한다면 한 곳만 수정하면 된다.
	즉, 상수는 리터럴 값에 의미 있는 이름을 부여 코드를 읽기 쉽게 해주고, 수정을 쉽게 해준다.
	
리터럴에 접미사인 L,l 를 붙이면 변수 타입이 long 으로 설정되고, f,d 를 붙이면 각각 float , double이 된다.
만약 접미사를 생략하면 정수 값은 int, 실수 값은 double 타입으로 인지한다.
	ㄴ 그래서 float a = 3.14; 를 할경우 컴파일 오류가 발생한다.
리터럴 접미사는 대소문자 구분을 안하지만 대문자를 사용하는 것이 좋다.

리터럴에 소수점, e, E ( 10의 제곱 ) , 접미사 f, F, d, D를 포함하면 실수형 리터럴로 간주한다.
10. -> 10.0
.10 -> 0.10
10f -> 10.0f
3.14e3f -> 3140.0f
1e1 -> 10.0
1e-3 -> 0.001

리터럴에 접두사인 0 , 0x , 0b 를 붙여서 8진수, 16진수, 2진수를 변수에 저장할 수 있다.
ex ) int octNum = 010; , int binNum = 0b10 , int hexNum = 0xff
JDK 17버전에 2진수 표현을 할 수 있게 되었으며, 또한 정수형 리터럴에 '_' 구분자를 넣을 수 있어, 읽기 쉽게 되었다.
ex ) int bigint = 123_456_789;

리터럴 타입과 변수 타입은 같아야 하지만, 변수 타입의 크기 보다 작은 리터럴 변수는 넣을 수 있다.
ex ) 
int a = 'A'; char 2바이트는 int 4바이트 보다 작다.
long b = 10; int 4바이트는 long 8바이트 보다 작다.
double d = 1.0f; float 4바이트는 double 8바이트 보다 작다.
단, 리터럴 값이 변수의 값 범위를 벗어나거나, 크기가 크면 안된다.
int a = 123123123123; <- int 범위인 2의 31승 - 1 을 넘어선다.
float b = 1.0d <- double 8바이트는 4바이트 보다 크다.

byte와 short는 리터럴이 없기 때문에 int를 그대로 사용하지만, 값의 범위에 포함되어 있어야한다.
byte - 1바이트로 2의 7승 - 1 범위여야 한다.

문자와 문자열
문자에도 리터럴이 있다. 
'A' : 문자 리터럴
"abc" : 문자열 리터럴

문자 : char ch = 'A'; 문자 하나를 작은 따옴표로 묶은 것 // 'java' 는 안됨
문자열 : String str = "str"; 2개 이상의 문자를 큰 따옴표로 묶은 것

String 에서 큰 따옴표 안에 아무것도 넣지 않는 것을 허용하며 ("") 이것을 빈 문자열 이라고 한다.
char는 작은 따옴표안에 문자가 반드시 포함되어야한다. ''

String은 클래스이기 때문에 new 연산자로 호출할 수 있다. 하지만 특별히 문자형 리터럴을 사용할 수 있다.
String str = new String("str");
String은 + 를 이용해 문자열을 합칠 수 있다.
	ㄴ 만약 피연산자 중 어느 하나가 String일 경우 String으로 형 변환을 한다.
	ㄴ 기본형, 참조형 예외는 없다.
ex ) 숫자 + 문자열 or 문자열 + 숫자 => 문자열 + 문자열
ex )
7 + " " = "7 "
" " + 7 = " 7"
7 + 7 + "14" -> "1414"
"14" + 7 + 7 -> "1477"
true + "" = "true"
null + " " = "null "

이처럼 덧셈 연산자는 완쪽에서 오른쪽으로 진행되게 때문에 결합 순서에 따라 결과가 바뀐다.


[ 출력 printf ]
printf는 '지시자' 라는 기능을 가지고 있어, 하나의 변수를 다른 형식으로 출력할 수 있다.
	ㄴ 예를 들면 정수 값을 16진수나 8진수로 바꿀 수 있고,
	ㄴ 실수 값을 특정 소수점 자릿수 까지만 출력할 수 있다.
	
printf("%d \n" , 14); 다음과 같이 14의 값이 지시자 %d에 들어가게 된다.
	ㄴ 줄바꿈문자는 \n와 %n 이 있는데, 운영체제 따라 줄바꿈 문자가 다르기 때문에 %n 을 하는게 더 안전하다.
prinft의 지시자
	%b - boolean 형식으로 출력
	%d - 10진수 정수형으로 출력
	%o - 8진수 정수형으로 출력 %#o 로 할시 접두사에 0 가 붙음
	%x - 16진수 정수형으로 출력 ( %X 사용시 모든 값을 대문자로 출력 ) %#x 로 할시 접두사에 0x 가 붙음
	%f - 부동 소수점 형식으로 출력
	%e - 지수 표현식 형식으로 출력
	%c - 문자로 출력
	%s - 문자열로 출력
	
	- 해당 지시자는 여러 값을 입력 시 간격을 맞춰줄 때 사용한다.
	%5d - 빈 공간 5자리를 기준으로 출력 ( 뒤에서 부터 출력 ) -> "    4"
	%-5d - 빈 공간 5자리를 기준으로 출력 ( 앞에서 부터 출력 ) -> "4     "
	%05d - 5자리를 0으로 채우고 뒤에서 부터 출력 -> "00004"
	
	10진수를 2진수로 변환하기 위해선 Integer.toBinaryString(int) 를 사용해야 한다.
	이 메서드는 String로 변환되므로 %s 를 사용해야 한다.
	또한 Char 형은 int로 출력할 수 없기 떄문에 (char) ch 처럼 형 변환을 해야한다.
	
	%f의 경우 기본적으로 소수점 밑 6자리만 표현하기 때문에 7자리에서 반올림한다.
	하지만 %14.10f 처럼 소수점 자릿수를 지정해줄 수 있다.
	
	%14.10f -> 전체 14자리 중에 소수점은 10자리 ( %전체자리.소수점아래자리f ) - 단, 소수점도 1자리 차지한다.
		ㄴ 따라서 112.4567890 이 된다.
		정수의 빈 부분은 공백이며, 소수점 아래 빈 공간은 0으로 채운다.
		
	문자열도 숫자를 넣으면 원하는 만큼 출력 공간을 잡을 수 있다.
	%s - 출력 길이만큼 확보
	%20s - 최소 20자리 만큼 확보 ( 우측 정렬 )
	%-20s -> 최소 20자리 만큼 확보 ( 좌측 정렬 )
	%.8s -> 왼쪽에서 8자리만 출력
		
[ 바이트 - 비트 ]
1 비트는 컴퓨터가 저장할 수 있는 최소 단위이며, 이러한 비트가 8개 모이면 1바이트가 된다.
이러한 바이트는 데이터의 기본 단위로 사용한다.
워드는 CPU가 한 번에 처리할 수 있는 데이터의 크기를 의미하며, 32 비트 CPU에서는 4바이트이고 64비트 CPU에서는 8바이트이다.

n비트일 경우 총 2의 n 승의 값을 표현할 수 있으며, 10진수로는 2의 n승 - 1 의 값을 표현할 수 있다.

[ 진법 ]
8진법과 16진법을 사용하는 이유는 2진법으로 표현하기에 값이 길어진다는 단점을 해결하기 위해 존재한다.
	ㄴ 8 진법은 2진법의 3자리 수를 묶은것이고, 16 진법은 2진법의 4자리를 묶은 것이다.
	ㄴ 16진법은 A를 10, F를 15로 표현한다.
2진법를 8진법 ,16진법로 바꾸는 방법은 간단하다.
	ㄴ 우선 8진법의 경우 2진법의 뒤에서 부터 3자리 씩 묶고 해당하는 8진법으로 변환한다,
	ㄴ 16진법은 2진법의 뒤에서 부터 4자리 씩 묶고 해당하는 16진법으로 변환한다,
	ㄴ 8진법, 16진법을 2진법으로 바꾸는 방법은 위의 방법을 반대로 하면 된다.
	
10진법을 다른 진법으로 변환하는 방법
	ㄴ 우선 10진수를 해당 진법으로 계속 나눈다.
	ㄴ 더이상 나눌 수 없을 떄 까지 반복한 다음 나머지 값을 아래에서 위로 순서대로 적으면 된다.
ex ) 816를 8진법으로 바꾸는 방법
8	816	0
8	102	6
8	12	4
	1
-> 816은 8진법으로 1460

n진법을 10진법으로 변환하는 방법
	- 각 진법에 해당하는 수를 모두 구한 후 더하면 된다.
	
ex ) 8진법 1460를 10진법으로 바꾸기
( 1 * 8*3 ) + ( 4 * 8*2 ) + ( 6 * 8*1 ) + ( 0 ) = 512 + 256 + 48 + 0 = 816

소수점수를 10진법에서 2진법으로 바꾸기
123.123 처럼 정수 부분은 위의 방법 그대로 하면된다.
다만 소수점 단위는 소수점 수에 2를 계속 곱한다.
	ㄴ 즉 소수점 부분이 사라질 때 까지 반복한다.
0.625인 경우에는 다음과 같이 된다.
0.625 * 2 = 1.25
0.25 * 2 = 0.5
0.5 * 2 = 1.0

즉 0.101 이 된다. ( 정수 부분을 위에서 아래로 가져온다. )


소수점수 2진법을 10진법으로 바꾸기
각 자리의 수에 해당하는 값을 곱해서 더하면 된다.

0.101 -> ( 1 * 2 의-1승 ) + ( 0 * 2 의-2승 ) + ( 1 * 2의 -3승 )
0.101 -> 1 * 0.5 + 0 * 0.25 + 1 * 0.125
0.101 -> 0.5 + 0.125 = 0.625

만약 정수부가 있다면, 정수부의 결과 값과, 소수점 수의 결과 값을 더하면 된다.


[ 2의 보수 ]
음수는 2의 보수법을 따른다.
N의 보수는 어떤 값에 N의 보수를 더했을 때 N이 되는 수를 말한다.

만약 부호가 있는 정수 ( -,+ ) 일 경우에는 가장 앞 비트를 값의 부호로 사용한다.
즉 첫번 째 비트가 0 이면 정수, 1이면 음수로 시작한다.

2의 보수에서는 2진법에서 절대값이 같은 두 양수와 음수를 더하면 2진수로 0이 되며 ( -2 ( 1110 ) + +2 ( 0010 ) )
2진수가 늘어날 때 마다 10진법이 줄어들지 않는다.
하지만 첫번째 비트를 바꾸는 것만으로는 값의 부호를 바꿀 수 없다.


[ 기본형 ]
> 논리형 - boolean ( 기본 값 : false , 1 byte )
	ㄴ true, false 2가지 값만을 가져서 1bit만으로도 충분하지만, Java에서는 최소 데이터 단위가 byte이기 때문에 1byte가 된다.
> 문자형 - Char ( 2 byte )
	ㄴ 단 하나의 문자를 저장하며, 값을 대입 시 '문자' 가 저장되는 것이 아닌, 해당 문자의 유니코드가 저장된다.
	ㄴ 즉 char ch = 65; 처럼 유니코드의 값을 직접 대입할 수 있으며, (int)ch 를 통해 해당 문자의 유니코드를 알 수 있다.
	ㄴ char 형에는 특수 문자를 저장할 수 있다.
\t - tab
\b - backspace
\f - formfeed
\n - newline
\r - carriage return
\\ - \
\' = '
\" = "
\u유니코드 = 유니코드 반환

또한 Char형은 음수를 사용하지 않기 때문에 0 ~ 65535 ( 2의 16승 ) 의 범위를 사용할 수 있다. ( 문자형이기 때문에 부호를 사용하지 않는다. )
	ㄴ 부호는 양수와 음수를 구분하기 위한 bit 인데, 문자형은 bit가 없기 때문이다.
	ㄴ 그에 비해 Short는 음의 부호를 사용하기 때문에 -2의 15승 ~ 2의 15승 - 1 의 범위를 사용한다.
	ㄴ 다만 두 값이 같다 하더라도 변수의 타입에 따라 결과가 달라질 수 있다. ( 65일 때 정수형은 그대로지만, 문자형은 'A' 가 출력된다. )
	
[ 인코딩 & 디코딩 ] 

컴퓨터는 숫자만 알기 때문에 문자를 숫자로 바꿔 저장하는데 그의 기준이 유니코드이다. * A -> 65 , a -> 97 *
즉, 컴퓨터는 문자를 숫자로 바꾸는 '문자 인코딩( Encoding )'을 하여 저장하고, 불러올 때는 '문자 디코딩 ( Decoding )' 을 통해 다시 숫자를 문자로 바꾼다.
	ㄴ 문자 'A' 를 유니코드로 인코딩하면 65가 된다.
	ㄴ 여기서 Encoding은 '코드화 하다' , '암호화하다' 라는 뜻을 가진다.
	
[ 아스키와 유니코드 ]
아스키 코드는 7bit로 구성되어 있으며, 128개의 문자를 가지고 있다.
처음 33번 까지의 문자는 출력할 수 없으며 이후로 부터는 숫자와 특수 문자, 영대소문자로 구성되어있다.

확장 아스키는 여기서 남은 1bit를 활용해서, 각자 다른 국가나 기업이 필요에 따라 다르게 정의해서 사용한다.
인터넷이 발명되면서 서로 다른 국가간의 문서교류 시 다른 인코딩을 사용하여 디코딩에 어려움을 겪었는데, 그 문제를 해결하기 위해 유니코드가 나왔다.
유니코드는 21 bit ( 200만 문자 ) 를 사용하여 모든 문자를 기록을 하였다.
	ㄴ 이후 새로 추가된 문자들은 보충 문자라고 불리며, 이 문자들은 char가 아닌 int를 사용해야 한다.
유니코드는 유니코드에 포함하고자 하는 문자들의 집합을 정의 했는데 이것을 유니코드 문자 셋 ( 캐릭터 셋 ) 이라고 한다. 그리고 이 캐릭터 셋에 번호를 붙인 것이 유니코드 인코딩이다. ( UTF-8 , UTF-16, UTF-32 )
	ㄴ 유니코드는 아스키를 그대로 사용하고 있으며 그 때문에 처음 127문자는 아스키와 동일하다.

[ UTF-8 과 UTF-16 ]
UTF-8 : 문자의 크기가 1 byte ~ 4 byte로 가변적이다. 크기가 가변적이기 때문에 문자를 다루기 어렵지만, 문서가 가볍다는 장점이 있다.
UTF-16 : 문자의 크기가 2 byte로 고정되어 있다. 크기가 고정되어 있어 문자를 다루기 편리하지만 웹 페이지 문서가 커진다는 단점이 있다.
 터넷에서는 크기가 작은 문서가 전송 속도가 빠르기 때문에 UTF-8 문서가 늘어나고 있다.
 
> 정수형 - byte, short, int, long

byte는 1byte, short는 2byte, int는 4byte , long - 8byte 이다.
정수형은 부호가 있기 때문에 맨 왼쪽 bit은 부호 기호로 사용한다. ( 맨 왼쪽은 부호 기호, 나머지는 값으로 사용한다. )
부호가 1이면 음수, 0이면 양수를 나타내며 값의 범위는 -2 의 n - 1승 ~ 2의 n-1승 - 1 이다.
	ㄴ 여기서 1을 빼는 이유는 양수에 0도 포함되어 있기 때문이다.
	
byte와 short는 4byte보다 작아서 메모리를 절약할 수 있지만, JVM의 피연산자 스택이 피연산자를 4byte 단위로 저장한다.
이때 4byte 보다 작을 경우 4byte로 변환하여 연산하기 때문에 int를 사용하는 것이 좋다.

따라서 정수형 변수를 선언할 때는 int 나 long을 사용하면 되며,
short나 byte는 성능 보다는 저장공간을 절약해야할 때 사용하자.

[ 오버플로우 ]
int의 경우 32bit의 크기를 넘어선다면 오버플로우가 발생한다.
오버플로우는 오류가 발생하진 않지만 예상하지 못한 값을 받게된다.

만약 4bit로 이루어진 2진수 1111에서 1을 더하면 10000이 아닌 0000이 된다.
즉 최대값에서 1을 더하면 최소값이 되며, 반대로 최소값 ( 0000 ) 에서 1을 빼면 ( 1111 ) 이 된다.

- char의 경우 범위가 0~65535 이다.
char ch = 65535;
ch + 1 을 출력하면 0이 된다.
반대로 char ch = 0;
ch - 0 를 출력하면 65535가 된다.

[ 실수형 float, double ]

float 타입은 4byte이며, double 타입은 8byte이다.
이때, float는 표현할 수 있는 범위는 넓지만 ( ~ 3.4 x 10의 38승 ) -1.4 x 10의 - 45승 ~ 1.4 x 10의 -45승 사이의 값은 표현할 수 없다.
	ㄴ 즉 0에서 가장 가까운 작은 수를 표현할 수 없다.
	ㄴ 또한 정수형과는 다르게 오버플로우가 발생하면 값이 무한대가 되며, 언더플로우 발생시 값이 0이 된다.
	ㄴ 언더플로우는 실수형에서만 존재하며, 실수형에서 표현할 수 있는 작은 값 보다 작아지면 발생한다. ( 1.4 x 10의 -45승 )
여기서 보면 float는 int와 같은 크기이지만 더 큰 값을 표현할 수 있다. 
	ㄴ 그 이유는 float는 부호와 값으로 저장되는 정수형과 달리 부호와 지수, 가수로 나뉘어서 저장된다. ( S.부호(1) , E.지수(8) , M.가수(23) )
	ㄴ 즉 가수 * 2의 E (지수) 승 의 값을 저장할 수 있어서 큰 값을 저장할 수 있다.
	ㄴ 다만 실수형은 오차가 발생할 수 있는데, 이는 '정밀도' 범위 안에 있는 값을 저장하지 않으면 오차가 발생할 수 있다는 뜻이다.
	ㄴ float는 정밀도가 7자리이며 이는 a*10의 7승의 값은 오차없이 저장할 수 있다는 뜻이다. ( 1.234567 는 정밀도 범위 안이지만, 1.2345678 부터는 정밀도가 손실된다. )
		ㄴ 즉 float는 1.234567890 를 저장한다 해도 앞에 7자리인 1.234567 는 정확하지만 그 뒤인 890은 다른 값으로 나올 수 있다.
	ㄴ double 형은 정밀도가 15자리이다. 실수형의 값을 저장할 때 double을 사용하는 이유는 정밀도가 더 높기 때문이다. ( 물론 큰 값을 저장할 수 있다는 장점도 있다. )
	ㄴ 다만 float 는 double 보다 연산 속도가 빠르고 메모리를 아낄 수 있다.
	
- 실수형의 저장 방식
실수형은 부동소수점수의 형태로 저장한다.
부동소수점수는 S.부호, E.지수 , M.가수로 나뉘어져 있으며, 실수를 ( +-M * 2의 E ) 로 표현한다.
	ㄴ double은 S(1) , E(11) , M(52)
	ㄴ float는 S(1) , E(8) , M(23)
S 는 부호를 뜻하며 0은 양수, 1는 음수를 뜻한다.
	ㄴ 실수는 2의 보수를 사용하지 않기 때문에 양수와 음수 간 변경은 해당 비트만 바꾸면 된다.
E 는 부호있는 지수를 뜻하며 지수의 범위는 -127 ~ 128 / -1023 ~ 1024 이다.
	ㄴ 지수를 저장하는 범위로 float의 경우 2의 8승을 가진다. ( 8bit의 크기이기 때문이다. )
	ㄴ 다만 부호있는 지수는 -2의 7승 ~ 2의 7승-1 이므로 -127 ~ 128 이 된다. 즉 2의 -127승 ~ 2의 128승이 값의 범위가 된다.
	ㄴ 이 중에서 -127과 128은 NaN과 음의 무제한, 양의 무제한의 특수 값으로 사용되므로 사실상은 2의 -126승 ~ 2의 127승이 값의 범위가 된다.
	ㄴ 이는 10진수로 변환하면 10의 38승이지만 가수의 최소값은 2의 -23승 이므로 이보다 더 작은 10의-45승이 된다.
M 는 실제로 값이 저장되는 부분이며, 정밀도를 책임진다.
	ㄴ float의 경우 23bit로 즉 2진수 23자리를 저장할 수 있다.
	ㄴ 2의 23자리는 10진수로 7자리를 저장할 수 있는데 이는 float의 정밀도가 된다.
	ㄴ double은 52bit 이므로 역시 10진수의 15자리까지 정밀하게 저장할 수 있다.
	
[ 부동소수점 오차 ]
실수는 정수와 다르게 오차가 발생할 수 있다.
실수는 정수와 다르게 무한 소수가 존재하며, 10진수로는 유한 소수인데 2진수로는 무한 소수가 발생할 수 있다.
	ㄴ ex ) 9.1234678 = 1001.000111111001101011011011011...
반대로 2진수로도 유한 소수이지만, 가수 부분에 저장할 수 있는 공간이 모자라여 값이 버려질 경우 오차가 발생한다.
즉 실수에서 2진수로는 10진수를 정확히 표현하지 못한다.

float는 2진수로 변환된 값을 저장할 때 정규화를 하여 저장한다.
	ㄴ 정규화는 1001.100 의 값을 1.0011000 x 2의 3승 으로 변환하여 저장하며 1. 뒤에 자릿수를 23비트 ( float 기준 ) 에 저장한다.
		ㄴ 즉 1.xxx * 2의 e 승 으로 변환한다.
	ㄴ 이때 지수인 3은 지수 부분에 저장되는데, 기저법으로 인해 127을 더한 130을 2진수로 변환되어 저장되고, 이는 2진수로 10000010 이 된다.
	ㄴ 기저법은 저장할 때 127을 더하고, 읽을 때 127을 뺀다.
	ㄴ 여기서 기저법은 2의 보수처럼 부호있는 정수를 저장하는 방법이다.
	
float의 경우 잘려나간 값으로 인해 발생할 수 있는 최대 오차는 2의 -23승이다. 이 값은 가수의 마지막 비트 단위와 같다.
2의 -23승은 0.0000001192 ( 10의 -7승 ) 이므로 float에서 정밀도를 7자리라고 하는 것이다.

[ 형변환 ( casting ) ]
형 변환은 변수나 리터럴을 다른 타입으로 변환하는 것을 말한다.
형 변환은 변환 하고자 하는 변수 앞에 타입을 지정하고 해당 타입을 캐스트 연산자인 () 를 묶어준다.
	ㄴ ex ) (타입) 변수 나 리터럴
	
기본형은 boolean을 제외한 int, float, double, char, short 는 본인들 끼리 형 변환이 가능하다.
	ㄴ 이때 double은 int로 변환하면 뒤에 소수점 자리가 모두 버려지고 ( 반올림을 하지 않는다. ) , char를 int로 변환 시 아스키 코드가 나온다.
	
정수형에서는 큰 타입을 ( int ) 작은 타입 ( byte ) 으로 형 변환 할 경우 값 손실이 발생할 수 있다.
( 예를 들어 300의 int 값을 byte로 강제 형 변환시 값은 44가 된다. ) 
반대로 작은 타입 ( byte ) 을 큰 타입으로 변환 ( int ) 하는 경우에는 값 손실은 발생하지 않는다.
	ㄴ 형 변환으로 생기는 메모리 공간에는 0 또는 1로 채운다.
	ㄴ 보통은 0 으로 채워지지만 음수의 경우 1로 채운다. ( 그 이유는 형 변환을 해도 값과 부호를 보존하기 위해서이다. )
	ㄴ Integer.toBinaryString(int) 메서드를 활용하면 해당 10진수의 2진수 문자열을 받을 수 있다.
	
실수형의 경우에도 작은 타입을 큰 타입으로 변환 시 남은 공간을 0으로 가득 채운다.
	ㄴ 다만 float에서 double로 변환 시, 지수 부분은 float의 기저인 127을 빼고, double의 기저인 1023을 더한다.
	ㄴ 나머지 가수 부분은 0 으로 채운다.
	ㄴ 반대로 double타입을 float 타입으로 변환하는 경우에는 지수 부분에는 double의 기저은 1023을 빼고 float의 기저인 127을 더한다.
	그리고 가수 부분에는 52자리 중 앞 23자리만 채워지고 나머지 부분은 버려진다.
	ㄴ 이 때 24자리 부분이 1 이면 반올림이 되어 23자리의 값이 1 올라간다.
	
	ㄴ 만약 float의 범위를 벗어난 값을 저장하면 무한대 혹은 0이 저장된다.
		ㄴ float의 범위보다 큰 값을 저장하면 무한대가 된다.
		ㄴ float의 범위보다 작은 값을 입력하면 0이 된다.
		
정수형을 실수형으로 변환
	ㄴ 정수를 우선 2진수로 변환한 다음 정규화를 하고, 부동소수점 형태로 저장한다.
	ㄴ 1. 7의 경우 2진수로 111 일 때, 정규화로 1.11 x 2의 2승으로 표현될 수 있다.
	ㄴ 여기서 지수 부분을 127을 더해 129를 2진수로 변환하여 지수 부분에 저장한다.
	ㄴ 나머지 0.11 부분은 가수 부분에 저장한다.
	
실수형을 정수형으로 형 변환
	ㄴ 실수형을 정수형으로 변환 시 소수점 이하의 자릿수는 모두 버려지며, 형 변환도 발생하지 않는다.
	ㄴ 따라서 9.9999f 를 int로 형 변환하면 9가 된다.
	
자동 형 변환
	ㄴ 서로 다른 타입 간 대입이나 연산을 할 때, 타입이 다를 경우 형 변환을 해주어야 한다.
	ㄴ 하지만 편의상으로 형 변환을 하지 않을 경우 컴파일러가 자동으로 형 변환을 해준다.
	ㄴ ex) float f = 1234;
	ㄴ 다만 자동 형 변환은 작은 타입을 큰 타입에 넣을 때에만 가능하며, 반대로 큰 타입을 작은 타입에 넣을 경우엔 자동 형 변환을 하지 않는다.
	ㄴ ex) char ch = 1000; <- incompatible type 오류. - 값 손실이 발생할 수 있기에 예외가 발생한다.
	ㄴ 위의 경우 char ch = (char) 1000; 처럼 명시를 해주면 오류는 발생하지 않는다.
만약 덧셈에서 타입이 다른 경우에는 두 타입 중 표현 범위가 넓은 타입으로 형 변환된다. 그렇게 해야 값 손실 위험이 적어지기 때문이다.
	ㄴ ex ) int + double = int + int
	ㄴ short + byte = short + short
	
형변환 기준 및 규칙
	- 컴파일러는 기존의 값을 최대한 보존할 수 있는 타입으로 형 변환을 한다.
	- byte > short/char > int > long > float > double
	- 왼쪽에서 오른쪽 방향으로 형 변환을 할 경우 형 변환 연산자를 생략할 수 있다.
	- 실수형은 정수형과 크기가 같아도, 표현 형식이 다르기 때문에 실수형의 표현 범위가 더 넓다.
	- short와 char는 크기가 같은 2byte라 할 지라도 char는 부호가 없고, short는 부호가 있기 때문에 두 타입간 형 변환 시 값 손실이 발생한다.
	
1. boolean 을 제외한 나머지 7개의 기본 자료형은 서로 형 변환이 가능하다.
2. 기본형과 참조형은 서로 형 변환을 할 수 없다.
3. 서로 다른 타입 간 연산을 위해 형 변환하는 것은 원칙이지만, 크기가 작은 타입에서 큰 타입으로의 형 변환은 생략할 수 있다.