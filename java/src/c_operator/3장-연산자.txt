연산자 : 연산을 수행하는 기호 ( + - * / )
피연산자 : 연산의 대상 ( 변수, 상수 )
x + 3 에서 x와 3은 피연산자이고 + 는 연산자이다.
	ㄴ 이때 + 연산자는 두개의 피연산자를 필요로 한다. ( 물론 어떤 연산자는 하나 또는 3개의 피 연산자를 요구한다. )
	ㄴ 연산자는 항상 결과 값을 반환한다.

식 ( expression ) : 연산자와 피 연산자를 활용하여 계산하고자 하는 바를 표현 ( 3 + 2 , 2 + 1 / 3 )
	ㄴ 이렇게 만들어진 식에서 결과를 얻는 것을 '식을 평가( evaluation )한다' 고 한다. ( 간단하게 말해서 연산 결과 )
	ㄴ 이러한 식을 평가할 때는 단 하나의 값을 반환한다. ( 3 + 2 는 결과가 1개 뿐이다. )
	
대입연산자 : 우변의 값을 좌변에 넣는다.
	- 식을 평가할 때 나온 결과는 어떠한 변수에 보관하지 않으면 그대로 사라진다. 따라서 평가한 결과를 변수에 저장해야 한다.
		ㄴ ex) int a = 3 + 3;

연산자의 종류
	ㄴ 산술 연산자 : 사칙 연산과 나머지 연산 ( + - * / % << >> )
	ㄴ 비교 연산자 : 크고 작음과 / 같고 다름을 비교 ( < > <= >= == != )
	ㄴ 논리 연산자 : AND 와 OR 로 조건을 연결 ( && || ! & | ^ ~ )
	ㄴ 대입 연산자 : 우변의 값을 좌변에 넣는다 ( = )
	ㄴ 기타 : (type) , ?: , instanceof
	
- 연산자는 피 연산자의 개수에 따라 구분되기도 한다.
	ㄴ 피 연산자가 하나면 단항 연산자
	ㄴ 두개면 이항 연산자
	ㄴ 3개면 삼항 연산자
-3-2 의 식처럼 같은 연산자인 ( - ) 를 사용하지만 서로 용도가 다른 연산자이다. 이때는 피 연산자의 갯수를 알면 구분할 수 있다.
	ㄴ 피연산자가 하나인 - 는 부호 연산자, 두개인 - 는 뺄셈 연산자가 된다.
	
[ 우선순위와 결합규칙 ]

연산자 우선순위
	ㄴ 논리 연산자 중 AND는 OR 보다 우선순위가 높다. 따라서 AND를 수행한 후에 OR가 수행된다.
	ㄴ 쉬프트 연산자 << 는 산술연산보다 우선순위가 낮기 때문에 산술 연산을 수행 후 쉬프트 연산자가 실행된다.
	ㄴ 비트 연산자 & 는 비교 연산자 == 보다 우선 순위가 낮다.
	ㄴ 만약 우선순위가 확실하지 않거나, 임의로 조정해야 할 때 () 를 사용하여 지정할 수 있다.

연산자의 결합규칙
	ㄴ 만약 하나의 식에 같은 우선순위의 연산자가 여러개 있을 경우엔 결합규칙에 따라 연산 순서를 정한다.
	ㄴ 단항 연산자와 대입 연산자를 제외하고는 모든 연산자는 왼쪽에서 오른쪽으로 계산된다.
		ㄴ 즉 3 + 2 - 35 + 13 이 있을 경우 왼쪽에 있는 3 + 2 부터 계산해야 한다.

정리
	ㄴ 연산자의 우선순위는 산술 > 비교 > 논리 > 대입 순이며 대입 연산자가 가장 마지막에 실행된다.
	ㄴ 또한 단항 연산자 > 이항 연산자 > 삼항 연산자 순이며 단항 연산자가 가장 먼저 실행된다.
	ㄴ 단향 연산자와 대입 연산자를 제외하고 모든 연산 방향은 왼쪽에서 오른쪽이다.
	
[ 산술 변환 ]
서로 다른 타입을 가진 피연산자들 간에 연산 시에 같은 타입으로 형 변환이 된다.
	ㄴ 이를 산술 변환 혹은 일반 산술 변환이라고 하며, 이항 연산뿐만이 아니라 단항 연산에서도 발생한다.

일반 산술 변환 : 연산을 수행하기 직전에 발생하는 피연산자의 자동 형변환
산술 변환 ( 일반 산술 변환 ) 의 규칙은 다음과 같다.
	ㄴ 1. 두 피연산자의 타입이 다를 경우, 둘 중 큰 타입으로 통일시킨다. ( 값 손실을 방지 )
	ㄴ 2. 피연산자 타입이 int 보다 작은 타입이면 int로 변환된다. ex ) short + byte -> int , short + short -> int + int
* 산술 변환은 쉬프트 연산자와 증감 연산자를 제외한 모든 연산에서 발생한다.
* int 타입으로 바뀌는 이유는 기본 연산자인 int로 처리해야 가장 효율성이 좋고, short 나 byte는 오버플로우가 발생할 위험이 높아 int로 변환한다.

또한 연산의 결과는 피 연산자의 타입과 일치한다. 만약 정수형끼리 나눗셈을 할 경우 반환 타입은 실수형이 아닌 정수형이 된다.
이때 나눗셈을 통해 발생한 소수점 이하는 버려지게 된다.
ex ) 5 / 2 = 2 이 된다. 2.5가 아니다.
만약 2.5라는 값을 받고 싶으면 피 연산자 중 하나를 float 형으로 변환하면 된다. 그렇게 되면 다른 피 연산자도 실수형으로 형변환되고 반환 값도 실수형이 될 것 이다.

[ 단항 연산자 ]
증감 연산자 ++ --
	ㄴ 증감 연산자는 피 연산자의 값에 1을 상승 또는 감소 시킨다.
	ㄴ 원래 연산자는 피 연산자의 값을 변경 시키지 않고 연산 결과를 반환 시키는데, 대입 연산자와 증감 연산자는 피 연산자의 값을 변경시킨다.
	ㄴ 증감 연산자는 일반 산술 변환이 발생하지 않는다.

증가 연산자 ( ++ ) 피 연산자의 값을 1 증가 시킨다.
감소 연산자 ( -- ) 피 연산자의 값을 1 감소 시킨다.
일반 단항 연산자는 피 연산자의 좌측에 위치하지만, 증감 연산자는 양쪽에 사용 가능하다.
	ㄴ 좌측에 붙은 전위형 ( ++a ) : 값을 참조하기 전에 1을 증가시킨다.
	ㄴ 우측에 부튼 후위형 ( a++ ) : 값을 참조하고 1을 증가시킨다.
	ㄴ 즉 전위형과 후위형의 차이는 값을 변경시키는 시점이다. ( 참조 전과 후 )
	
만약, 수식이나 메서드 호출에 사용되지 않고 독립적으로 사용될 경우 2개 모두 차이가 없다.
a++;
++a; 
위와 같이 단순 1을 더하는 코드는 뭘 써도 차이가 없다.
callMethod(a++);
	ㄴ 만약 위와 같이 메서드의 매개변수로 전달 한 경우 a의 값이 전달된 후에 1을 더한다.
	ㄴ 전위형 ( ++a ) 의 경우 1을 더하고 값이 전달된다.
증감 연산자를 사용할 때는 식에 같은 변수가 2개 이상 들어갔을 땐 사용하는 것을 피하자 ( 가독성 떨어짐 )
	ㄴ ex ) int value = a++ - a;
	
[ 부호 연산자 ]
부호 연산자는 피연산자의 부호를 바꿔서 반환한다.
	ㄴ ex) int value = -a; ( 부호연산자"-" 는 a가 음수면 양수, 양수면 음수로 바꾼다. )
반대로 부호 연산자"+" 는 하는 일이 없으며 잘 사용하지 않는다. - 가 있어서 형식적으로 추가된 것이다. 보통은 - 만 사용한다.
부호 연산자는 기본 자료형 중에서도 boolean, char 를 제외한 기본 자료형에서만 사용할 수 있다.
부호 연산자는 산술 연산자와 기호는 같지만 피 연산자의 갯수로 구분할 수 있다.

[ 산술 연산자 ]
사칙 연산자 : + - * /
나머지 연산자 : %

- 나눗셈 : 5 / 2 의 값은 2.5가 아닌 2가 된다. 그 이유는 int 와 int 의 연산 결과는 int 이기 때문이다. 그렇기 때문에 피연산자 중 어느 한 값을 실수형으로 형 변환한 다음 연산하면 다른 피연산자는 float로 자동 형 변환되기 때문에 2.5라는 값을 얻을 수 있다.
	ㄴ 추가로 int 형 간에 나눗셈을 하면 반올림하는 것이 아니라 소숫점을 버리게 된다.
	ㄴ 이렇게 버려지는 소수점을 반올림하고 싶다면 ( 3.15 + 0.5 ) 처럼 float에 0.5를 더하거나, Math.round를 쓰면된다.
	ㄴ Math.round 는 매개변수로 받은 실수형의 첫째 자리를 반올림하여 정수로 반환한다.
그리고 나눗셈은 0으로 나눌 수 없다. 만약 나눈다면 런타임 오류 ( ArithmeticException )가 발생하며, 0.0 으로 나눌 경우 Infinity ( NaN ) 라는 값을 얻는다. 이때 NaN은 Not a Number 라는 뜻이다.

- 덧셈 : byte + byte 의 결과 값은 byte가 아니라 int 형이다. 그 이유는 int 형보다 작은 타입에서 연산을 할 경우 연산자는 int 타입으로 형 변환하여 연산하기 때문이다.
	ㄴ 그래서 byte + byte의 결과는 int 타입이고, 이 결과를 byte 타입의 변수에다가 넣으려고 하면 예외가 발생한다. 따라서 byte 타입에 넣으려고 하면 ( byte ) 로 형 변환 해야한다.
	ㄴ 만약 int 보다 큰 타입인 float, double 에 저장한다고 하면 자동 형변환이 된다.
	
- 곱셈 : long c = 100000(int) * 100000(int) 와 같은 식을 보면 결과 값인 10_000_000_000 값이 정상적으로 c에 들어갈 것이라 예상된다.
	ㄴ 하지만 int * int 의 결과는 int 이기 때문에 21억의 값을 넘기지 못하고 오버플로우가 발생되어 이상한 값이 저장된다.
	ㄴ 해당 문제를 해결하기 위해 두 int 값 중 하나를 long 형으로 변환하여 계산하면 해결할 수 있다.
	ㄴ 이미 오버플로우가 발생한 값을 큰 타입으로 변환한다고 해도 소용이 없다.
	ㄴ (long) 으로 형 변환해도 괜찮은데 100000L 로 리터럴 값에 L 을 붙여줘도 된다.
	
char 형은 문자와 숫자 모두 사칙 연산이 가능하다. char는 저장될 대 해당 문자의 유니코드 ( 부호없는 정수 ) 가 저장되기 때문이다.
	ㄴ ex ) 'c' - 'a' = 2
	위와 같은 공식을 이용해여 문자 간에 간격을 알 수 있다.
	ㄴ 만약 문자의 크기를 더하고자 char ch = 'c' + 1 를 할 경우 우측에 있는 'c'는 int로 형 변환된다. 따라서 다음과 같이 형 변환을 해주어야 한다.
		ㄴ char ch = (char) ('c' + 1)

char a = 'a';
char b = 'a' + 1;
//char c =  (a + b); 오류
char c =  (char) (a + b);

c 같은 경우는 이항 연산자는 int보다 작은 타입은 int로 형 변환하기 때문에 char로 형 변환하는 것은 알 수 있다.
다만 b를 보면 'a' + 1 는 char 형으로 형 변환하지 않아도 오류가 나지 않는다.
	ㄴ 그 이유는 상수나 리터럴 간의 연산은 컴파일러가 컴파일 시에 해당 하는 값을 미리 넣어 놓기 때문이다.
	ㄴ 예를 들어 char ch = 'a' + 1; 이라는 코드가 있을 경우 컴파일러는 'a'+1 에 해당하는 'b'로 대체한다.
	ㄴ char ch = 'b'; 다음과 같이 코드가 바뀌게 된다.
반대로 3번째 오류나는 코드를 보면 식에 변수가 있을 경우에 컴파일러가 미리 계산할 수 없다. 따라서 컴파일 시점에 오류가 발생하므로 형 변환을 직접 해주어야한다.
	ㄴ 즉 시간을 저장하는 변수 int day = 60 * 60 * 24; 같은 경우도 컴파일러에 의해 86400 으로 변경되기 때문에, 성능에는 변화가 없다. 따라서 가독성과 유지보수를 위해서 이렇게 작성할 수 있다.

참고로 문자는 a~z , A~Z , 0~9 까지 연속적으로 저장되어 있으며, 'a'에서 1을 더할 대 마다 다음 영문자가 순서대로 나온다. 또한 대소문자 간에 코드 차이는 32이므로, 대문자에서 32를 더하면 소문자 / 소문자에서 32를 빼면 대문자가 된다.

- 나머지 %
	ㄴ 나머지는 정수만 입력이 가능하다. 이때 음수도 허용되게 되는데, 나머지 연산은 부호를 무시하기 때문에 부호의 의미는 없다.
	ㄴ 나눗셈 처럼 나누는 수를 0으로 할 수 없다.
	ㄴ 부호가 있는 나눗셈 연산은 우선 부호를 무시하고 나머지 연산이 되고, 그 후에 왼쪽 피연산자의 부호를 붙이면 된다.
	ex ) -10 % 8 = -2 / 10 % -8 = 2 / -10 % -8 = -2
	ㄴ 나머지 연산자는 주로 짝수,홀수 체크 및 배수 체크에 주로 사용된다.
	
[ 비교 연산자 ]
두 피연산자의 크기를 비교하는데 사용되며, 이항연산자이다. true와 false 2개의 값만 반환한다.
	ㄴ 비교 연산자는 이항연산자이기 때문에 두개의 피연산자간에 크기가 다를 경우 둘 중 큰타입으로 자동 형 변환된다.

- 대소비교 연산자 < > <= >=
	ㄴ 두 피연산자의 값의 크기를 비교하는 연산자로 true와 false 값을 반환한다.
	ㄴ 기본형 중에서 boolean을 제외한 모든 기본형은 사용할 수 있으며, 참조형은 사용할 수 없다.
	
- 등가비교 연산자 == !=
	ㄴ 두 피연산자의 값이 같은지 확인하는 연산자로 true와 false 를 반환한다.
	ㄴ 대소비교 연산자와는 달리 모든 기본 자료형과 참조형에 사용될 수 있다.
		ㄴ 기본 자료형 : 변수에 저장된 값이 같은지 확인
		ㄴ 참조형 : 참조변수가 같은 객체를 참조하고 있는지 확인
	ㄴ 단 기본형과 참조형은 서로 형 변환이 안되기 때문에, 기본형과 참조형 간에 등가비교 연산자를 사용할 수 없다.
이때 '0' == 0 은 false이다. 그 이유는 '0'은 유니코드로 48이기 때문에 48 == 0 으로 형 변환된다.
이때 0.1==0.1f 역시 false이다. 그 이유는 실수형은 해당 값의 근사값을 저장하기 때문에 오차가 발생할 수 있다.
	ㄴ 0.1은 2진수로 변환하는 과정에서 오차가 발생할 수 있다.
	ㄴ float의 경우 0.1이 저장된 것 처럼 보이지만 사실 0.10000001031 처럼 값이 오차가 생겼다.
	ㄴ double 역시 오차가 발생하지만 float보다 정밀도가 높기 때문에 오차가 더 적다. 0.1000000000001031
	ㄴ 이런 오차로 실수형 간에 비교를 할 때는 double 타입을 float 타입으로 형변환하거나, 뒷 소수점 중 몇 개만 잘라 가져와서 연산하는 방법도 있다. *오차가 발생할 수 있는 뒷 자리를 자름*
	
- 문자열의 비교
	ㄴ 문자열의 경우 두 문자열이 같은지 비교하려면 등가비교 연산자인 == 를 사용하는 것이 아니라 .equals 메서드를 사용해야한다.
	ㄴ .equals() 메서드는 두 문자열의 내용이 같으면 true, 다르면 false 를 반환한다.
	ㄴ == 는 객체가 같을 때에만 true를 반환한다.
	ㄴ 만일 대소문자를 구분하지 않고 비교하고 싶으면 .equalsIgnoreCase() 를 사용하면 된다.

[ 논리 연산자 ]
논리 연산자는 여러개의 조건을 AND 나 OR 을 사용해서 하나로 표현할 수 있게 해준다.
&& - AND의 뜻을 말하며 피연산자가 모두 true 일 때 true를 반환
|| - OR 를 뜻하며 피연산자 중 하나가 true 인 경우에 true를 반환

이때 논리 연산자는 모든 피 연산자를 boolean 타입이거나, boolean 을 반환하는 메서드를 넣어야 한다.
&& 는 || 보다 우선 순위가 높기 때문에 하나의 식에 && 와 || 가 함께 있을 경우 && 가 먼저 실행된다.

* 효율적인 연산 *
논리 연산자는 OR연산의 경우 좌측의 피 연산자가 true 일 경우 우측의 피 연산자를 평가하지 않는다.
AND연산도 좌측의 피 연산자가 false일 경우 우측의 피 연산자를 평가하지 않는다.
따라서 같은 조건문일 지라도, 피 연산자의 위치에 따라 성능 차이가 발생할 수 있다.

실제로 a가 5이고 b가 0인 경우에 a != 0 || ++b != 0 의 조건문을 실행하면 b는 증감 연산자가 작동하지 않는다.
그 이유는 a가 이미 true이기 때문에 우측 피 연산자는 실행되지 않았기 때문이다.
마찬가지로 if(a == 5 || OperatorEx5()) 와 같이 boolean을 반환하는 OperatorEx5() 메서드가 있을 경우, a가 true 일 경우 OperatorEx5() 메서드는 실행되지 않는다.

논리 부정 연산자 !
논리 부정 연산자는 boolean 타입의 값을 반대로 바꾼다.
true인 경우에는 false로 바꾸고, false인 경우에는 true로 변경한다.
주로 조건식이나, 반복문의 조건식에서 많이 활용된다.
!!true -> true / !false -> true