연산자 : 연산을 수행하는 기호 ( + - * / )
피연산자 : 연산의 대상 ( 변수, 상수 )
x + 3 에서 x와 3은 피연산자이고 + 는 연산자이다.
	ㄴ 이때 + 연산자는 두개의 피연산자를 필요로 한다. ( 물론 어떤 연산자는 하나 또는 3개의 피 연산자를 요구한다. )
	ㄴ 연산자는 항상 결과 값을 반환한다.

식 ( expression ) : 연산자와 피 연산자를 활용하여 계산하고자 하는 바를 표현 ( 3 + 2 , 2 + 1 / 3 )
	ㄴ 이렇게 만들어진 식에서 결과를 얻는 것을 '식을 평가( evaluation )한다' 고 한다. ( 간단하게 말해서 연산 결과 )
	ㄴ 이러한 식을 평가할 때는 단 하나의 값을 반환한다. ( 3 + 2 는 결과가 1개 뿐이다. )
	
대입연산자 : 우변의 값을 좌변에 넣는다.
	- 식을 평가할 때 나온 결과는 어떠한 변수에 보관하지 않으면 그대로 사라진다. 따라서 평가한 결과를 변수에 저장해야 한다.
		ㄴ ex) int a = 3 + 3;

연산자의 종류
	ㄴ 산술 연산자 : 사칙 연산과 나머지 연산 ( + - * / % << >> )
	ㄴ 비교 연산자 : 크고 작음과 / 같고 다름을 비교 ( < > <= >= == != )
	ㄴ 논리 연산자 : AND 와 OR 로 조건을 연결 ( && || ! & | ^ ~ )
	ㄴ 대입 연산자 : 우변의 값을 좌변에 넣는다 ( = )
	ㄴ 기타 : (type) , ?: , instanceof
	
- 연산자는 피 연산자의 개수에 따라 구분되기도 한다.
	ㄴ 피 연산자가 하나면 단항 연산자
	ㄴ 두개면 이항 연산자
	ㄴ 3개면 삼항 연산자
-3-2 의 식처럼 같은 연산자인 ( - ) 를 사용하지만 서로 용도가 다른 연산자이다. 이때는 피 연산자의 갯수를 알면 구분할 수 있다.
	ㄴ 피연산자가 하나인 - 는 부호 연산자, 두개인 - 는 뺄셈 연산자가 된다.
	
[ 우선순위와 결합규칙 ]

연산자 우선순위
	ㄴ 논리 연산자 중 AND는 OR 보다 우선순위가 높다. 따라서 AND를 수행한 후에 OR가 수행된다.
	ㄴ 쉬프트 연산자 << 는 산술연산보다 우선순위가 낮기 때문에 산술 연산을 수행 후 쉬프트 연산자가 실행된다.
	ㄴ 비트 연산자 & 는 비교 연산자 == 보다 우선 순위가 낮다.
	ㄴ 만약 우선순위가 확실하지 않거나, 임의로 조정해야 할 때 () 를 사용하여 지정할 수 있다.

연산자의 결합규칙
	ㄴ 만약 하나의 식에 같은 우선순위의 연산자가 여러개 있을 경우엔 결합규칙에 따라 연산 순서를 정한다.
	ㄴ 단항 연산자와 대입 연산자를 제외하고는 모든 연산자는 왼쪽에서 오른쪽으로 계산된다.
		ㄴ 즉 3 + 2 - 35 + 13 이 있을 경우 왼쪽에 있는 3 + 2 부터 계산해야 한다.

정리
	ㄴ 연산자의 우선순위는 산술 > 비교 > 논리 > 대입 순이며 대입 연산자가 가장 마지막에 실행된다.
	ㄴ 또한 단항 연산자 > 이항 연산자 > 삼항 연산자 순이며 단항 연산자가 가장 먼저 실행된다.
	ㄴ 단향 연산자와 대입 연산자를 제외하고 모든 연산 방향은 왼쪽에서 오른쪽이다.
	
[ 산술 변환 ]
서로 다른 타입을 가진 피연산자들 간에 연산 시에 같은 타입으로 형 변환이 된다.
	ㄴ 이를 산술 변환 혹은 일반 산술 변환이라고 하며, 이항 연산뿐만이 아니라 단항 연산에서도 발생한다.

일반 산술 변환 : 연산을 수행하기 직전에 발생하는 피연산자의 자동 형변환
산술 변환 ( 일반 산술 변환 ) 의 규칙은 다음과 같다.
	ㄴ 1. 두 피연산자의 타입이 다를 경우, 둘 중 큰 타입으로 통일시킨다. ( 값 손실을 방지 )
	ㄴ 2. 피연산자 타입이 int 보다 작은 타입이면 int로 변환된다. ex ) short + byte -> int , short + short -> int + int
* 산술 변환은 쉬프트 연산자와 증감 연산자를 제외한 모든 연산에서 발생한다.
* int 타입으로 바뀌는 이유는 기본 연산자인 int로 처리해야 가장 효율성이 좋고, short 나 byte는 오버플로우가 발생할 위험이 높아 int로 변환한다.

또한 연산의 결과는 피 연산자의 타입과 일치한다. 만약 정수형끼리 나눗셈을 할 경우 반환 타입은 실수형이 아닌 정수형이 된다.
이때 나눗셈을 통해 발생한 소수점 이하는 버려지게 된다.
ex ) 5 / 2 = 2 이 된다. 2.5가 아니다.
만약 2.5라는 값을 받고 싶으면 피 연산자 중 하나를 float 형으로 변환하면 된다. 그렇게 되면 다른 피 연산자도 실수형으로 형변환되고 반환 값도 실수형이 될 것 이다.

[ 단항 연산자 ]
증감 연산자 ++ --
	ㄴ 증감 연산자는 피 연산자의 값에 1을 상승 또는 감소 시킨다.
	ㄴ 원래 연산자는 피 연산자의 값을 변경 시키지 않고 연산 결과를 반환 시키는데, 대입 연산자와 증감 연산자는 피 연산자의 값을 변경시킨다.
	ㄴ 증감 연산자는 일반 산술 변환이 발생하지 않는다.

증가 연산자 ( ++ ) 피 연산자의 값을 1 증가 시킨다.
감소 연산자 ( -- ) 피 연산자의 값을 1 감소 시킨다.
일반 단항 연산자는 피 연산자의 좌측에 위치하지만, 증감 연산자는 양쪽에 사용 가능하다.
	ㄴ 좌측에 붙은 전위형 ( ++a ) : 값을 참조하기 전에 1을 증가시킨다.
	ㄴ 우측에 부튼 후위형 ( a++ ) : 값을 참조하고 1을 증가시킨다.
	ㄴ 즉 전위형과 후위형의 차이는 값을 변경시키는 시점이다. ( 참조 전과 후 )
	
만약, 수식이나 메서드 호출에 사용되지 않고 독립적으로 사용될 경우 2개 모두 차이가 없다.
a++;
++a; 
위와 같이 단순 1을 더하는 코드는 뭘 써도 차이가 없다.
callMethod(a++);
	ㄴ 만약 위와 같이 메서드의 매개변수로 전달 한 경우 a의 값이 전달된 후에 1을 더한다.
	ㄴ 전위형 ( ++a ) 의 경우 1을 더하고 값이 전달된다.
증감 연산자를 사용할 때는 식에 같은 변수가 2개 이상 들어갔을 땐 사용하는 것을 피하자 ( 가독성 떨어짐 )
	ㄴ ex ) int value = a++ - a;
	
[ 부호 연산자 ]
부호 연산자는 피연산자의 부호를 바꿔서 반환한다.
	ㄴ ex) int value = -a; ( 부호연산자"-" 는 a가 음수면 양수, 양수면 음수로 바꾼다. )
반대로 부호 연산자"+" 는 하는 일이 없으며 잘 사용하지 않는다. - 가 있어서 형식적으로 추가된 것이다. 보통은 - 만 사용한다.
부호 연산자는 기본 자료형 중에서도 boolean, char 를 제외한 기본 자료형에서만 사용할 수 있다.
부호 연산자는 산술 연산자와 기호는 같지만 피 연산자의 갯수로 구분할 수 있다.
