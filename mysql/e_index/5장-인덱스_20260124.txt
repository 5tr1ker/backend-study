
[ 디스크 읽기 방식 ]
- 하드 디스크 드라이브 ( HDD ) 와 솔리드 스테이트 드라이브 ( SSD )
하드디스크는 기계식 장치로 전자식 저장 매체인 SSD 보다 속도가 느리다. 그리고 디스크 장치는 병목이 발생하는 위치가 될 때가 많다.

SSD는 기존 하드 디스크와의 순차 I/O 속도와 차이는 크게 나진 않지만, 랜덤 I/O 에서는 SSD가 더 빠른 성능을 보인다.
그리고 DBMS 에서는 랜덤 I/O 를 통해 작은 데이터를 읽고 쓰는 작업이 대부분이라 SSD는 RDBMS 용 스토리지에 최적이다.

# 데이터베이스 성능 튜닝은 어떻게 디스크 I/O를 줄이는 지에 관건일 떄가 많다.

- 랜덤 I/O 와 순차 I/O
랜덤 I/O와 순차 I/O는 하드 디스크 드라이브의 플래터 ( 원판 ) 을 돌려서 읽어야 할 데이터가 저장된 위치에 디스크 헤더를 이동시킨 다음 데이터를 읽는다.

순차 I/O는 3개의 데이터를 디스크에 기록하기 위해 시스템 콜을 1번 요청하고, 랜덤 I/O는 같은 조건으로 시스템 콜을 3번 요청한다.
즉, 데이터 기록 위치를 찾기 위해 순차 I/O는 디스크의 헤드르 1번 움직이고 랜덤 I/O는 3번 움직인다.
디스크에서 데이터를 쓰고 읽는데 걸리는 시간은 디스크 헤더를 움직이는 단계에서 결정되기 때문에 순차 I/O가 랜덤 I/O 보다 3배 더 빠르다.

그래서 여러번 쓰기 또는 읽기를 자주하는 데이터베이스 작업 ( 랜덤 I/O 작업 ) 특성 상 MySQL 서버에서 작업의 부하가 크다.
이는 디스크 원판을 가지지 않는 SSD 가 더 빠를 것 같지만, SSD 에서도 랜덤 I/O의 성능이 떨어진다.
# 물론 디스크 헤더의 위치 이동 없이 얼마나 많은 데이터를 한번에 기록하는 것이 중요하다.

사실 쿼리 튜닝은 랜덤 I/O 자체를 줄이는 것이 목적이다. 즉 필요한 데이터만 읽도록 쿼리를 개선하는 것이다.

[ 인덱스란? ]
인덱스는 책의 맨 뒤에 있는 찾아보기와 같다. 책의 맨 뒤에 있는 찾아보기에 나오는 내용은 데이터 파일에 해당한다 볼 수 있다.
그리고 찾아보기에서 나오는 페이지 번호는 데이터가 저장된 주소가 될 수 있다.
DBMS 도 특정 칼럼과 해당 레코드가 저장된 주소를 키와 값의 쌍으로 인덱스를 만든다. 그리고 정렬을 통해 빠르게 데이터를 찾을 수 있게 한다.

인덱스는 항상 정렬된 상태를 유지하기 때문에 조회인 SELECT 는 성능이 빠르지만, 데이터의 추가와 삭제인 UPDATE 와 DELETE 작업은 속도가 느리다.
이는 인덱스에 사용할 컬럼이 많아질수록 저장 속도는 더 느려질 것이다. 물론 데이터의 조회 기능이 중요하다면 희생할 수 있어야 한다.

인덱스는 데이터를 관리하는 방식과 중복 값 허용에 따라 여러 가지가 있다.
인덱스를 역할별로 구분해본다면 프라이머리 키와 보조 키 ( 세컨더리 인덱스 ) 로 나뉠 수 있다.

- 프라이머리 키
해당 레코드를 대표하는 컬럼의 값으로 만들어진 인덱스로, 해당 컬럼으로는 레코드를 식별할 수 있는 기준이 되기 때문에 식별자라고 부른다.
프라이머리 키는 NULL 과 중복을 허용하지 않는다.

- 보조 키
프라이머리 키를 제외한 모든 인덱스를 말한다. 
유니크 인덱스는 프라이머리 키와 성격이 유사하고, 프라이머리 키를 대체할 수 있어서 대체 키라고도 하는데, 별도로 분류하기도 하고 세컨더리 인덱스라고도 한다.

- B-Tree 알고리즘
B-Tree 알고리즘은 가장 많이 사용된 알고리즘이며, 값을 변경하지 않고 인덱싱하는 알고리즘이다.

- Hash 인덱스 알고리즘
Hash 인덱스 알고리즘은 칼럼의 값으로 해시값을 계산해서 인덱싱하는 알고리즘으로 검색 속도가 매우 빠르다는 특징을 가지고 있다.
하지만 값의 변형으로 Prefix 를 통한 검색이나 범위 검색과 같은 인덱스는 사용할 수 없다.
Hash 인덱스는 주로 메모리 기반 데이터베이스에서 많이 사용된다.

- 유니크 인덱스
단순히 1개의 값이 존재한다.
이는 동등 조건으로 조회했을 때 1건의 데이터가 조회되면 더이상 찾이 않아도 된다는 것을 옵티마이저에게 알려주는 효과를 낸다.
뿐만 아니라 MySQL에서의 처리 방식의 변화나 차이점이 많다.

- 유니크하지 않은 인덱스
2개 이상의 값이 존재한다.

[ B-Tree 인덱스 ]
B-Tree 는 데이터베이스의 인덱스 알고리즘으로 가장 많이 사용되는 알고리즘이자 가장 먼저 도입된 알고리즘이다.
B-Tree 에서 B 의 약자는 Binary ( 이진 ) 이 아니라 Balanced 를 의미한다.

B-Tree는 원래의 값을 변형하지 않고, 인덱스 내에서 항상 정렬된 상태를 유지한다.
# 물론 값의 일부분만 잘라서 관리한다.
전문 검색과 같은 특수항 경우가 아니라면 대부분 인덱스는 B-Tree를 사용한다.

- B-Tree 의 구조
B-Tree는 트리 형태의 구조로 최 상단에는 루트 노드가 있고 그 하단에 자식 노드들이 있다.
그리고 최 하단의 있는 ( 자식이 없는 ) 노드는 리프 노드라 하고, 그 중간에 있는 노드를 브랜치 노드라 한다.

데이터베이스에서 인덱스와 실제 데이터가 저장된 주소 위치가 따로 관리 되는데, 리프 노드에는 항상 실제 데이터가 저장된 위치인 주소값이 있다.
여기서 인덱스는 항상 정렬된 상태를 유지하지만, 실제 데이터인 데이터 파일들은 정렬된 상태는 아니다.
# 데이터 파일들은 INSERT된 순서대로 저장하는 것이 아니다. 물론 삭제와 수정 없이 INSERT만 한다면 순서대로 저장되지만, RDBMS 는 삭제되어 발생한 빈 공간에 INSERT 될 수 있게 설계되어 있다.

인덱스는 레코드의 키 칼럼만 가지고 있으므로 다른 컬럼을 가져오기 위해선 데이터 파일에서 해당 레코드를 조회해야 한다.
이를 위해 인덱스의 리프 노드에는 해당 레코드가 저장된 주소를 가진다. ( 해당 주소는 데이터 파일에서 레코드가 저장된 위치이다. )

MyISAM 테이블에서는 세컨더리 인덱스는 물리적 주소를 가지고 있고, InnoDB 테이블에서는 프라이머리 키를 주소처럼 사용된다.
그래서 InnoDB 테이블에서 인덱스를 통해 레코드를 읽을 때 프라이머리 키 값을 이용해 인덱스 검색을 한 후, 리프 노드를 거쳐 데이터를 읽는다.
그에 비해 MyISAM 은 인덱스에 물리적 주소를 가지고 있어 바로 데이터 파일로 접근할 수 있다.

[ B-Tree 인덱스 키 추가 및 삭제 ]
- B-Tree의 삽입
B-Tree에 새로운 키 값이 저장될 때 B-Tree 에 적재될 위치 중 적절한 위치를 검색해야 한다.
저장될 위치가 결정되면 레코드의 키 값과 레코드가 저장된 주소 위치를 B-Tree의 리프 노드에 저장한다.
만약 리프 노드가 꽉 차서 더이상 저장할 수 없을 때, 리프 노드를 분리해야 하는데 이는 상위 브랜치 노드까지 작업의 영향을 미치므로 작업 시간이 많이 든다.

MyISAM 이나 MEMORY 스토리지 엔진은 INSERT 문장이 실행되면 즉시 새로운 키 값을 B-Tree 에 추가한다.
다만 InnoDB는 필요하다면 인덱스 키 추가 작업을 지연시켜 나중에 처리하게 한다. 하지만 프라이머리 키나 유니크 인덱스는 중복체크를 해야하기때문에 즉시 B-Tree에 추가한다.

- 인덱스 키 삭제
B-Tree의 키 삭제의 경우, 해당 키 값이 저장된 B-Tree 의 리프 노드를 찾아 제거 마크만 하면 된다.
제거 마크가 활성화된 인덱스는 방치되거나 재활용 된다. 이때 인덱스에 마킹 작업 또한 디스크에 쓰기가 필요하므로 디스크 I/O 작업이 필요하다.

InnoDB 스토리지 엔진에서는 해당 작업또한 지연처리 될 수 있다. 물론 사용자 입장에서 영향력을 미치진 않는다.
반대로 MyISAM 이나 MEMORY 스토리지 엔진에서는 체인지 버퍼와 같은 기능이 없으므로 인덱스 키 삭제 완료 후 다음 작업을 처리한다.

- 인덱스 변경
인덱스의 키 값에 따라 리프 노드의 위치가 결정되기 때문에 B-Tree에서 인덱스 상 키 값만 변경하는 것은 불가능하다.
그렇기 때문에 기존 키 값을 삭제한 후 다시 새로운 키 값을 추가하는 형태로 진행된다.
물론 InnoDB는 체인지 버퍼를 통해 지연 처리 될 수 있다.

- 인덱스 키 검색
UPDATE, DELETE, INSERT 작업 수행 시 작업의 성능을 떨어트리는 인덱스 구축은 사실 빠른 검색을 위해서이다.
인덱스를 검색하는 과정은 B-Tree의 루트 노드부터 시작해 브랜치 노드를 거쳐 최종 리프 노드까지 이동하는 트리 탐색을 진행한다.

트리 탐색은 SELECT 뿐만 아니라 UPDATE 나 DELETE 를 처리하기 위해 사용된다. ( 작업 대상 레코드를 검색할 경우 )
B-Tree 인덱스는 완전 일치나, 앞부분 일치, 비교 검색에서도 활용할 수 있지만 뒷 글자로는 사용할 수 없다.
또한 인덱스의 키 값이 변경된 후 비교되는 경우에는 인덱스를 사용할 수 없다. 이는 변형된 값은 인덱스에 존재하는 값이 아니기 때문이다.
	ㄴ 예를 들어 함수나 연산을 수행한 결과로 정렬하거나 검색하는 작업을 말한다.
	
InnoDB 스토리지 엔진은 레코드 잠금이나 넥스트 키락이 검색에 사용된 인덱스를 잠근 후 테이블의 레코드를 잠그는 방식으로 되어 있다.
이때 UPDATE나 DELETE 문장이 실행될 때 테이블에 적절히 사용할 수 있는 인덱스가 없으면 불필요하게 많은 레코드를 잠근다. ( 때로는 모든 레코드를 잠글 수 있다. )
따라서 InnoDB 스토리지 엔진에서는 그만큼 인덱스의 설계가 중요하다.

[ B-Tree 인덱스 사용에 영향을 미치는 요소 ]

- 인덱스 키 값의 크기
B-Tree 인덱스는 인덱스를 구성하는 컬럼의 크기와 레코드 건수, 유니크한 인덱스 키 값의 갯수에 따라 작업의 성능이 영향 받는다.

InnoDB 스토리지 엔진은 디스크에 데이터를 저장하는 기본 단위를 페이지 또는 블록이라고 하며, 디스크의 모든 읽기 및 쓰기의 최소 단위가 된다.
인덱스는 페이지 단위로 관리되며 B-Tree를 구성하는 루트,브랜치,리프 노드의 기준은 페이지 단위이다.

B-Tree에 있는 각 노드들의 자식 노드는 가변적이며, 자식 노드는 인덱스 페이지의 크기나 키 값의 크기에 따라 달라진다.
InnoDB 스토리지 엔진은 페이지의 크기를 4KB ~ 64KB 사이의 값을 선택할 수 있으며 기본 값은 16KB 이다.

인덱스 페이지가 16KB일 경우 주소값 16바이트와 자식노드주소는 N바이트를 가지게 된다. 자식노드주소는 페이지의 종류에 따라 6B ~ 12바이트의 크기를 가진다.
위의 경우 하나의 인덱스 페이지에는 16*1024/(16+12) = 585개의 자식 노드를 저장할 수 있다. ( 자식노드주소를 12바이트로 가정 )
만약 인덱스 키 값이 32바이트로 커진다면 16*1024/(32+12) = 372개의 자식 노드를 저장할 수 있다.
이떄 SELECT 의 조회결과가 500개일 경우 인덱스 키 값이 16바이트인 경우 한번으로 끝나지만 32바이트인 경우 2번을 디스크로부터 읽어야 한다.
이는 인덱스 키 값이 커지면 디스크로부터 읽어야 하는 횟수가 늘어나고 이를 통해 성능이 저하된다는 것을 알 수 있다.

그리고 인덱스의 키 길이가 길어진다는 것은 인덱스 크기가 커진다는 것을 의미한다. 이는 캐시할 수 있는 제한적인 영역인 버퍼 풀 ( InnoDB ) 나 키 캐시 ( MyISAM ) 에 캐시해 둘 수 있는 레코드의 수가 줄어든다는 것을 말한다.

#자식노드주소에는 여러가지 복합 정보가 포함되어 있다

- B-Tree 깊이
B-Tree 인덱스의 깊이는 중요하지만 직접 제어하는 방법은 없다.
인덱스의 깊이는 MySQL 에서 값을 검색할 때 몇 번 디스크에서 읽어야 하는지와 연결된다.

만약 인덱스 키 값의 크기가 커진다면, 인덱스 페이지에 저장되는 인덱스의 개수가 적어지고, 그 때문에 같은 레코드 건수일수록 B-Tree의 깊이가 깊어져서 디스크를 더 많이 읽게 된다.
따라서 인덱스 키 값의 크기는 가능하면 작게 만드는 것이 좋으며, 실제로 대용량 데이터베이스일지라도 B-Tree의 깊이가 5단계 이상 깊어지진 않는다.

- 선택도(기수성)
인덱스에서 선택도와 기수성은 거의 같은 의미로 사용되며, 인덱스 키 값 중에서 유니크한 값의 수를 말한다.
만약 전체 인덱스 키 값 100개 중에서 유니크한 값이 10개라면 기수성은 10이 된다.
# 이는 중복된 값이 많아질수록 기수성과 선택도는 줄어든다.
인덱스는 선택도가 높을수록 검색할 대상이 줄어들기 때문에 성능이 빨라진다.

만약 10000개의 레코드 중 유니크한 값의 개수가 10건이라면, 인덱스로 키를 검색한다고 해도 1000건의 데이터를 더 검색해야 한다.
	ㄴ 유니크 값으로 1개를 찾았다 하더라도 10000/10 = 1000 ( 전체 레코드 수 / 유니크 한 값의 갯수 ) 번을 더 검색해야 원하는 하나의 데이터가 나올 수 있기 떄문이다. ( 데이터 중복이 없다는 가정 )
그렇기 떄문에 유니크한 값의 개수가 작다 하면 유니크 키로 적절한가 생각해야 한다.
# 선택도가 좋지 않더라도 정렬이나 그루핑과 같은 작업을 위해 선택도가 낮은 인덱스가 필요한 경우도 있다.

- 읽어야 하는 레코드 건수
인덱스를 통해 테이블의 레코드를 읽는 작업이, 인덱스를 거치지 않고 바로 테이블을 조회하는 것 보다 높은 비용이 발생할 수 있는 상황이 있다.
일반적인 DBMS의 옵티마이저에서는 인덱스를 통해 레코드를 1건 읽는 것이, 테이블에서 직접 레코드 1건을 읽는 것 보다 4~5배 더 비용이 발생할 것으로 예측한다.

이는 인덱스를 통해 읽어야 할 레코드의 건수가 전체 테이블의 20~25%일 경우 전체 테이블을 전부 가져와서 필요한 것만 가져오는 것이 효율적이다. ( 물론 옵티마이저가 예상한 수 )
이는 MySQL 옵티마이저가 이러한 상황이 올 경우 인덱스를 사용하지 않고 전체 테이블을 처음부터 끝까지 가져와서 처리할 것이다.
	ㄴ 인덱스를 사용하도록 힌트를 준다 하더라도 이를 무시할 것이다.
	
[ B-Tree 인덱스를 통한 데이터 읽기 ]

- 인덱스 레인지 스캔
인덱스 레인지 스캔은 인덱스 접근 방법 중에서 가장 대표적이고 빠른 방법이다.
인덱스 레인지 스캔은 한 건만 읽거나 여러 건을 읽는데 차이가 있지만, 여기선 하나의 이름인 인덱스 레인지 스캔을 활용한다.

인덱스 레인지 스캔은 탐색해야 할 범위가 정해졌을 때 사용하는 방식이다.
루트 노드를 거쳐, 브랜치 노드, 리프 노드까지 찾아 들어가고 시작해야 할 위치를 찾으면 리프 노드를 차례 대로 스캔하면 된다.
그리고 최종적으로 스캔을 멈춰야 할 위치에 다다르면 해당 결과를 사용자에게 반환한다.
# 인덱스는 항상 정렬된 상태를 유지하기 때문에 한 리프 노드를 기준으로 정순 혹은 역순으로 조회하면 오름차순 혹은 내림차순으로 데이터를 읽을 수 있다.

더 중요한 것은 리프 노드에 있는 레코드의 주소로 실제 디스크에 저장된 레코드 데이터를 가지고 와야 한다.
문제는 레코드 한 건을 조회할 때 마다 랜덤 I/O가 한 번씩 일어난다는 것이다.
그렇기 때문에 인덱스를 통해 데이터 레코드를 읽는 작업은 비용이 많이 드는 작업으로 분류된다.
그리고 인덱스를 통해 읽어야할 데이터의 레코드기 20~25%를 넘으면 테이블의 데이터를 직접 읽는 것이 더 효율적이다.

인덱스 레인지 스캔의 순서
1. 인덱스에서 조건에 일치하는 값이 저장된 위치를 찾는다, ( 인덱스 탐색 )
2. 1번에서 탐색된 위치부터 필요한 만큼의 인덱스를 쭉 읽는다. ( 인덱스 스캔 )
3. 2번에서 조회한 인덱스 키와 레코드 주소를 통해 레코드가 저장된 페이지를 가져오고 최종 레코드를 읽어온다.

쿼리가 필요로 하는 데이터에 따라 3번 과정이 수행되지 않을 수도 있는데 이를 커버링 인덱스라고 한다.
커버링 인덱스는 디스크에 레코드를 읽지 않아도 되어 읽기 속도가 빠르다는 특징을 가지고 있다.

위에 1번, 2번 과정이 얼마나 수행됐는지는 SELECT STATUS LIKE '%Handler_%' 쿼리를 통해 알 수 있다.
단 해당 레코드로 실제 디스크에 레코드를 조회했는지는 알 수 없다.
Handler_read_key 는 1번 , Handler_read_next Handler_read_prev 는 2번 단계에서 수행한 건수.

- 인덱스 풀 스캔
인덱스 풀 스캔은 인덱스를 사용하지만 인덱스를 처음부터 끝까지 모두 읽는 방식을 뜻한다.
이는 조건절에 사용된 컬럼이 인덱스의 첫 번째 컬럼이 아닌 경우에 인덱스 풀 스캔이 발생한다.
# 예를 들어 인덱스가 (A,B,C) 순으로 되어있을 떄, 쿼리의 조건절이 B 이나 , C 컬럼으로 검색하는 경우

이는 쿼리가 인덱스에 명시된 컬럼으로만 조건을 처리할 수 있는 경우에만 해당 방식으로 처리한다. 인덱스 뿐만이 아니라 데이터 레코드도 조회해야 한다면 해당 방식을 사용하지 않는다.
# 인덱스의 크기는 테이블 크기보다 작으므로, 직접 테이블을 조회하는 것 보다는 효율적이다.

이는 인덱스 리프 노드의 맨 앞이나 맨 뒤로 이동한 후, 인덱스의 리프 노드들을 연결하는 링크드 리스트를 따라서 처음부터 끝까지 탐색하는 방식이다.
인덱스 레인지 스캔보다는 빠르진 않지만 테이블 풀 스캔보다는 효율적이다.
# 그 이유는 인덱스에 포함된 컬럼만으로 처리가 가능하다면 테이블 레코드를 조회하지 않아도 되기 때문이다. 그렇기 떄문에 더 적은 디스크 I/O 로 처리할 수 있다.

- 루즈 인덱스 스캔
루즈 인덱스 스캔은 느슨하게 인덱스를 읽는 것을 뜻한다. ( 반대로 위에 두 인덱스 스캔은 타이트 인덱스 스캔으로 분류된다. )
루즈 인덱스 스캔은 인덱스 레인지 스캔과 비슷하지만, 중간에 필요하지 않은 인덱스는 무시하고 다음으로 넘어간다.
	ㄴ 일반적으로 Group By나 집합 함수 MIN() , MAX() 에 대해 최적화하는 경우 사용된다.
	ㄴ 위와 같이 최적화 했을 경우 각 그룹 별로 맨 앞 or 맨 뒷 레코드만 읽고 다음 그룹으로 넘어가는 최적화를 할 수 있다. ( WHERE 가 있다 하더라도 조건에 맞는 데이터들을 모두 스캔할 필요가 없다는 것을 옵티마이저가 판단한다. )
	
	
- 인덱스 스킵 스캔
데이터베이스에서 인덱스를 구성하는 컬럼의 순서는 중요하다.
그 이유는 (A,B) 순서로 인덱스를 생성하였을 경우, 조건절에 A 를 사용하지 않고, B만 사용했을 경우 인덱스를 사용할 수 없다.
MySQL 8.0 버전 부터는 옵티마이저가 A를 건너뛰고 B만으로도 인덱스 검색이 가능하도록 인덱스 스킵 스캔 최적화 기능이 도입됐다.

MySQL 8.0 이전 부터는 조건절에 A를 사용하지 않았다면 인덱스 풀 스캔 or 테이블 풀 스캔을 진행할 것이다. ( SET optimizer_switch='skip_scan=off' 를 통해 확인 가능 )
옵티마이저는 A 컬럼에 대해 유니크한 값을 모두 조회한 후, 주어진 쿼리에 A 컬럼을 추가해서 다시 실행한다.
	ㄴ 즉 B 조건을 그대로 두고, A에 유니크한 값이 10가지 일 경우, 10번의 쿼리를 실행한다.
	
인덱스 스킵 스캔은 생략된 인덱스 컬럼의 유니크 값은 적어야 하며, 커버링 인덱스로 처리되어야 한다.
만약 생략된 인덱스 컬럼에 유니크한 값이 많다면 스캔 시작 지점을 검색하는 비용이 많아져서 결국 성능이 떨어지게 될 것이다.
또한 커버링 인덱스가 아닌 경우 나머지 컬럼도 필요로 하기 때문에 풀 테이블 스캔으로 실행 계획을 세우게 된다.

[ 다중 컬럼 인덱스 ]
인덱스에 사용된 컬럼이 2개 이상인 경우 다중 컬럼 인덱스라고 한다.
인덱스 중 두번쨰 컬럼은 첫번째 칼럼에 의존하여 정렬되어 있다. 이는 두번쨰 칼럼의 정렬은 첫번째 인덱스 컬럼이 같아야 의미있는 것이다.
또한 다중 컬럼 인덱스에서 각 칼럼이 순서는 중요하다. 이는 두번째 컬럼이 정렬 순서가 빠르다 하더라도 첫번째 컬럼 값의 우선순위가 낮다면 리프노드의 뒷 쪽에 배치된다.

[ B-Tree 인덱스의 정렬 및 스캔 방향 ]
인덱스를 생성할 때 설정한 규칙에 따라서 인덱스의 키는 오름차순이거나 내림차순으로 정렬한다. ( 물론 오름차순으로 정렬할 때 항상 오름차순으로만 읽을 수 있는 것은 아니다. )
인덱스의 끝에서부터 처음 방향으로 읽으면 내림차순으로도 읽을 수 있는 것이다.
이는 쿼리에 따라 옵티마이저가 어느 방향으로 읽을 지 실행 계획에 따라 결정된다.

- 인덱스의 정렬
DBMS 에서는 인덱스를 생성할 때 인덱스를 구성하는 각 컬럼에 대해 오름차순 또는 내림차순으로 설정할 수 있다.
CREATE INDEX ix_teamname_userscore ON employees (team_name ASC, user_score DESC)

- 인덱스 스캔 방향
인덱스가 오름차순으로 정렬되어 있을 때, 그중 한 컬럼 중 가장 큰 값 1개를 가져오는 쿼리에 대해
옵티마이저는 인덱스를 반대부터 읽어서 그중 가장 큰 값을 가져온다. ( 오름차순으로 끝까지 읽는 것은 아니다. )
인덱스가 오름차순으로 정렬되어 있다고 하더라도, 반대로 읽으면 내림차순을 얻을 수 있다는 것은 옵티마이저가 알고있기 떄문이다.
즉, 인덱스의 정렬 순서는 인덱스 생성 시점에 결정은 되지만, 쿼리가 실행되는 시점에도 인덱스의 스캔 방향이 결정된다.

SELECT * FROM table WHERE first_name >= 'Anneke' ORDER BY first_name LIMIT 4;
위의 쿼리에 대해 first_name 이 정의된 인덱스를 탐색하고, 그 부분부터 순서대로 4개의 레코드만 조회하면 되기 때문에 성능이 빠르다.

이처럼 ORDER BY나 MIN , MAX 와 같은 함수에서 최적화가 필요한 경우에 MySQL 옵티마이저는 인덱스의 읽기 방향을 조절해서 실행 계획을 만들어 낸다.

# 물론 두개 이상의 컬럼에 대해 오름차순, 내림차순으로 정렬 할 때, MySQL 8.0 부터 지원하는 각 컬럼을 각각 오름차순 과 내림차순 방향으로 인덱스를 만들어야한다. 모두 같은 오름차순이나 내림차순은 성능이 그렇게 좋지 못하다.

- 내림차순 인덱스
MySQL 서버에서는 인덱스의 정렬 순서에 관계 없이 인덱스의 읽는 순서에 따라서 간단하게 해결할 수 있다.
단, InnoDB 스토리지 엔진은 내부적으로 오른차순으로 정렬된 인덱스에 대해 역순 스캔이 정순 스캔보다 보통 30% 가량 느린 이유가 있다.
1. 페이지 잠금이 인덱스 정순 스캔에 적합한 구조
2. 페이지 내 인덱스 레코드가 단방향으로만 연결된 구조

그렇기 때문에 내림차순 인덱스는 효율이 낮기 때문에, 내림차순 정렬을 자주해야 하는 경우 인덱스를 내림차순으로 하는 것이 좋다.
물론, 내림차순이 드물게 실행되고 소량의 데이터라면 굳이 내림차순 정렬을 할 필요가 없을 것이다.

[ B-Tree 인덱스의 가용성과 효율성 ]

- 비교 조건의 종류와 효율성
다중 칼럼 인덱스에서는 각 칼럼의 순서나, 그 칼럼의 사용된 조건이 같다 ( = ) 인지, 범위 조건 ( < , > ) 인지에 따라 활용 형태가 달라진다.
SELECT * FROM table WHERE dept_no = 'd002' AND emp_no >= 10114;

그리고 두개의 인덱스가 있다고 가정하자.
1. INDEX(dept_no, emp_no)
2. INDEX(emp_no, dept_no)

1번의 경우 dept_no = 'd002' AND emp_no >= 10114 인 레코드를 읽고, 이후 dept_no 가 d002 가 아닐 때 까지 인덱스를 읽기만 하면된다.
2번의 경우 emp_no >= 10114 AND dept_no = 'd002' 인 레코드를 읽고, 이후 dept_no 가 d002 인지 비교를 해야 한다.
이처럼 인덱스를 통해 읽은 레코드가 나머지 조건에 맞는지 확인하는 작업을 '필터링' 이라고 한다.

여기서 다중 컬럼 인덱스의 정렬 방식 떄문에 1 번이 더 빠르다. 그 이유는 첫 번째 검색 조건이 비교 작업을 좁히는 데 도움을 주었다.
하지만 반대로 2번째 인덱스는 도움을 주지 못했따.

- 인덱스의 가용성
B-Tree 인덱스의 특징은 왼쪽 값을 기준으로 오른쪽 값을 정렬한다. 이는 하나의 컬럼 뿐만이 아니라 다중 컬럼 인덱스도 적용된다.
하나의 컬럼으로 검색할 때 값의 왼쪽 부분이 없으면 인덱스 레인지 스캔 방식으로의 검색이 불가능하며, 다중 컬럼 인덱스에서도 왼쪽 컬럼의 값을 모르면 인덱스 레인지 스캔을 사용할 수 없다.

SELECT * FROM table WHERE first_name LIKE '%ke';
위의 쿼리의 경우 왼쪽부터 값을 비교해갈 수 없기 때문에 왼쪽 기준(Left-most) 정렬 기반의 인덱스인 B-Tree에서는 인덱스 효과를 얻을 수 없다.
왼쪽 기준 정렬 기반인 B-Tree의 인덱스 효과를 얻으려면 왼쪽부터 한 글자씩 비교해가면서 일치하는 레코드를 찾아야 한다. -> LIKE 'ke%'

SELECT * FROM table WHERE emp_no >= 10144;
인덱스가 (A,emp_no) 로 생성되어 있다면 인덱스의 선행 컬럼인 A 없이 emp_no 로만 값을 검색하면 인덱스를 효율적으로 사용할 수 없다.
이는 A 로 정렬된 후 emp_no 로 정렬되어 있기 때문이다.

# 여기서는 WHERE 절만 언급했지만 인덱스의 왼쪽 값 규칙은 GROUP BY 나 ORDER BY 에서도 적용된다.

- 가용성과 효율성 판단
기본적으로 B-Tree 인덱스에서는 다음과 같은 조건에서는 인덱스를 사용할 수 없다.

1. Not Equals 로 비교된 경우 ( <> , not in , not between , is not null )
2. Like '%??' 처럼 문자열의 뒷부분을 비교하는 경우
3. 스토어드 함수나 연산자로 인해 인덱스 칼럼이 변형되는 경우
4. not-deterministic 속성의 스토어드 함수가 비교 조건으로 사용되는 경우
5. 비교하는 데이터 타입이 서로 다른 경우 ( 인덱스 칼럼의 타입을 변환해야 하는 경우 )
6. 문자열 데이터의 콜레이션이 다른 경우

다중 컬럼 인덱스의 경우 인덱스를 사용하지 못하는 경우는 다음과 같다.
1. 작업 범위 결정 조건으로 인덱스를 사용할 수 없는 경우 ( 앞선 인덱스의 조건이 없는 경우 , 혹은 인덱스를 사용할 수 없는 경우 )

작업 범위 결정 조건으로 사용할 수 있는 경우
1. 1 번째 컬럼부터 i 번째 컬럼까지 동등 비교 형태 ( = 혹은 IN 연산자 ) 로 비교
2. i 번째 컬럼에 대해 동등 비교 ( = , IN ) or 크고 작음을 비교 ( < , > ) or LIKE 로 좌측 일치 패턴을 사용할 경우 ( LIKE 'abc%' )


위의 두 조건을 모두 만족하는 쿼리는 1번쨰 컬럼부터 i 번째 컬럼까지는 작업 범위 결정 조건으로 사용되고 그 이후로 부터는 체크 조건으로 사용된다.

# 밑의 쿼리는 모두 범위 결정 조건이 된다.
WHERE col_1 IN (1,2) AND col_2 = 2 AND col_3 <= 10

# col_1 는 범위 결정 조건, col_2는 체크 조건
WHERE col_1 = 5 AND col_2 <> 10

# 밑의 컬럼은 모두 범위 결정 조건이 된다. 좌측 패턴 일치 LIKE 는 작다 또는 크다 비교와 동급이다.
WHERE col_1 LIKE 'ab%'

여기서의 인덱스 특징은 B-Tree 인덱스의 특징이므로 대부분 RDBMS 에서도 동일하게 적용된다.

[ 전문 검색 인덱스 ]
전체 데이터 중 일부만 잘라서 인덱스로 활용하는 B-Tree 와는 달리, 문서 전체의 내용을 분석하거나 검색하는 인덱스 알고리즘을 전문 검색 인덱스라고 한다.
전문 검색 인덱스는 문서 내용 전체를 인덱스화해서 특정 키워드가 포함된 문서를 검색하는 것을 전문 검색이라고 한다.

- 인덱스 알고리즘
전문 검색에서는 문서 본문에서 사용자가 검색하게 될 키워드들을 분석하고, 이 키워드들로 인덱스를 구축해서 빠른 검색을 할 수 있게한다.
전문 검색 인덱스에서 문서의 키워드를 인덱싱하는 기법에 따라 크게 어근 분석 알고리즘, n-gram 분석 알고리즘으로 분류된다.

- 어근 분석 알고리즘
MySQL 서버에서의 전문 검색 인덱스는 불용어 처리와 어근 분석을 거쳐서 색인 작업이 수행된다.
불용어 처리는 검색에서 사용되지 않을 것 같은 단어를 필터링해서 제거하는 작업을 말한다.
불용어는 상수로 정의해서 사용하는 경우도 있고 동적으로 DB를 활용해서 제거하는 방법도 있다.

어근 분석은 검색어로 선정된 단어의 원형을 찾는 작업이다.
MySQL 서버에서는 오픈소스 형태소 분석 라이브러리인 MeCab 을 플러그인 형태로 사용할 수 있게 지원한다.

- n-gram 알고리즘
MeCab을 위한 형태소 분석은 전문적인 전문 검색 알고리즘이여서 만족할만한 결과를 내기 위해선 많은 시간이 필요로 한다.
이러한 단점을 보완하기위해 나온 알고리즘이 n-gram 알고리즘이며, MeCab은 형태소 형식의 문장을 이해하는 것이라면, n-gram 은 단순히 키워드를 검색하는 인덱스 알고리즘이다.

n-gram 은 본문에서 몇 글자씩 잘라서 인덱싱 하는 방법으로, 형태소 분석 알고리즘보다 단순하고 국가 언어마다 이해와 준비 작업이 필요 없지만 인덱스의 크기가 큰 편이다.
n-gram에서 n은 인덱싱할 키워드의 최소 글자 수를 의미하는데, 보통 2 글자씩 잘라서 인덱싱하는 2-gram ( Bi-gram ) 방식을 많이 사용한다.

to be or not to be
위의 문장을 2글자씩 중첩해서 토큰으로 분리하면 다음과 같이 된다. 중복되는 토큰은 하나의 인덱스 엔트리로 병합한다.
또한 MySQL 서버에 내장된 불용어에 포함 ( like ) 하거나 일치 ( = ) 하는 경우엔 걸러져 버려진다. ( x 표시 된 토큰 )
to	to(x)
be	be(x)
or	or(x)
not no ot
this	th hi(x) is(x)

이렇게 걸러진 토큰들은 B-Tree 인덱스에 저장된다. ( 물론 성능 향상을 위해 Merge-Tree와 같은 기능이 있다. )

- 불용어 변경 및 삭제
위의 토큰 중 hi 와 같은 토큰들은 "i" 의 불용어가 포함되어 있기 때문에 걸러졌다. 이는 사용자에게 도움을 주기 보단 혼란을 주기 때문에 
불용어를 무시하거나, MySQL 에서 제공하는 기본 불용어 사전보다는 사용자가 만들어서 사용하는 것이 좋다.

이때 전문 검색 인덱스의 불용어 처리를 무시하는 방법은 다음과 같다.
1. MySQL 서버의 설정 파일 my.cnf 의 ft_stopword_file='' 설정을 하면 된다. 설정이 완료되면 MySQL 서버를 재시작해야 한다.
ft_stopword 는 사용자가 정의한 불용어 사전을 적용할 떄에도 사용될 수 있다. 사용자가 정의한 불용어 사전의 경로를 넣으면 적용이 된다.

2. InnoDB 스토리지 엔진을 사용하는 테이블에 대해서만 적용하려면 innodb_ft_enable_stopword 시스템 변수를 off 로 지정하면 된다.
이는 다른 스토리지 엔진은 적용되지 않으며, MySQL 서버를 재시작하지 않아도 된다.
> SET GLOBAL innodb_ft_enable_stopword=OFF;

- 사용자 정의 불용어

MySQL 서버에서 내장 불용어가 아닌 사용자 정의 불용어를 사용하는 방법은 다음과 같다.
1. 불용어 목록 파일을 저장하고 MySQL 서버 파일 ( my.cnf ) 의 ft_stopword_file 속성에 해당 경로를 넣으면 된다.
2. InnoDB 스토리지 엔진에만 적용되는 방법인데, 불용어 목록을 테이블로 저장한 다음 innodb_ft_server_stopword_table 시스템 변수에 해당 테이블을 설정하면 된다.
	ㄴ 이는 불용어 목록을 변경한 이후 전문 검색 인덱스가 생성되어야 적용된다.

- 전문 검색 인덱스의 가용성
전문 검색 인덱스를 사용하려면 두가지 조건을 만족해야 한다.
1. 쿼리 문장이 전문 검색을 위한 문법 ( MATCH ... AGAINST ...) 을 사용해야 한다.
2. 테이블이 전문 검색 대상 컬럼이 전문 인덱스를 가지고 있어야 한다.

WHERE MATCH(doc_body) AGAINST('애플' IN BOOLEAN MODE);

- 멀티 벨류 인덱스
전문 검색 인덱스를 제외한 모든 인덱스는 데이터 레코드 1개당 1개의 인덱스 키를 가지고 있다.
하지만 멀티 벨류 인덱스는 하나의 데이터 레코드에 여러 개의 키 값을 가질 수 있다.

이는 정규화에 위배되는 형태이지만, RDBMS가 JSON 데이터 타입을 지원하게 되면서 JSON 배열 타입의 필드에 저장된 원소들에 대해 인덱스 요건이 발생했다.
JSON 포멧으로 데이터를 관리하는 MongoDB 는 이러한 형태의 인덱스를 지원하고 있었지만, 기존의 MySQL 서버는 멀티 벨류 인덱스를 지원하지 않아 MongoDB와 비교되곤 했다.
하지만 MySQL 8.0 부터는 멀티 밸류 인덱스를 제공하게 되면서 JSON 데이터 타입의 관리 기능은 MongoDB 에 비해서 부족함이 없게 됐다.

멀티 벨류 인덱스를 사용하기 위해선, 일반적인 조건 방식을 사용하면 안되고 MEMBER OF() , JSON_CONTAINS() , JSON_OVERLAPS() 함수를 활용해야
옵티마이저가 인덱스를 활용한 실행 계획을 수립한다.

[ 클러스터링 인덱스 ]
클러스터링이란 여러 개를 하나로 묶는다는 의미를 말하며, MySQL 서버에서 프라이머리 키 값이 비슷한 레코드를 묶어서 저장하는 것을 말한다. 이는 비슷한 값을 동시에 조회하는 경우가 많은걸 착안한 것이다.
MySQL 에서 클러스터링 인덱스는 InnoDB 스토리지 엔진에서만 지원한다.

이는 프라이머리 키 값에 따라 레코드의 저장 위치가 결정되는 것을 의미한다. 여기서 프라이머리 키 값이 변경될 경우에도 레코드의 저장 위치가 바뀌어야 한다.
이는 프라이머리에 대한 의존도가 크기 때문에 프라이머리 키를 신중하게 선택해야 한다.
여기서 클러스터링에 사용되는 키를 클러스터링 키라고도 한다.

# 클러스터링 인덱스와 클러스터링 테이블은 동의어다. 그 이유는 해당 방식이 알고리즘 보다는 테이블 레코드의 저장 방식에 가깝기 때문이다.

클러스터링 인덱스를 사용하는 테이블은 클러스터링 키로 검색하는 경우 속도가 매우 빠르다. 물론 프라이머리 키의 변경은 느리다.
	ㄴ 만약 클러스터링 키가 바뀌었을 경우 리프 노드(페이지) 의 위치는 변경된다. ( 데이터 위치 변경 )
	ㄴ 그 외 MyISAM 이나 MEMORY 스토리지 엔진은 위치가 바뀔일은 없다.
클러스터링 인덱스는 세컨더리 인덱스를 위한 B-Tree 의 리프 노드와는 달리 클러스터링 인덱스의 리프 노드에는 모든 컬럼이 함께 저장되어 있다.

# B-Tree 는 인덱스 키가 정렬되어 있고, 클러스터링 인덱스는 클러스터링 키를 기반으로 레코드가 정렬되어 있다.

만약 프라이머리 키가 없는 InnoDB 테이블에 대해 다음과 같은 우선순위로 프라이머리 키를 대체한다.
1. 프라이머리 키가 있으면 해당 키를 클러스터링 키로 선택
2. NOT NULL 옵션 + 유니크 인덱스 중 첫번쨰 인덱스를 클러스터링 키로 선택
3. 자동으로 유니크한 값을 가지도록 증가하는 칼럼을 내부적으로 추가하고 클러스터링 키로 선택
	ㄴ 이는 사용자가 검색할 수도, 사용자에게 나타내지도 않는다.
	
클러스터링 인덱스는 테이블당 명시적으로 하나만 선택하는 것이 좋다.

- 세컨더리 인덱스에 미치는 영향
MyISAM 과 MEMORY 스토리지 엔진은 레코드의 위치가 바뀔 일이 없기 떄문에 프라이머리 키와 세컨더리 키의 구조는 다르지 않다.
하지만 InnoDB 는 클러스터링 키의 변경으로 데이터의 위치가 바뀔 경우 바뀐 테이블의 모든 인덱스에 저장된 주소 값을 변경해 주어야 하는데 
이런 오버헤드를 줄이기 위해 세컨더리 인덱스는 데이터가 저장된 주소가 아닌 프라이머리 키 값이 저장되게 구현됐다.

- 클러스터링 인덱스의 장단점
장점
프라이머리 키로 검색할 떄 성능이 매우 빠름 ( 범위 검색 포함 )
세컨더리 인덱스는 프라이머리 키 값을 가지고 있기 때문에 인덱스만으로 처리될 수 있는 경우가 많음

단점
테이블의 모든 세컨터리 인덱스는 클러스터링 키를 가지기 때문에 클러스터링 키가 클 수록 인덱스의 크기가 커진다.
세컨더리 인덱스를 통해 검색할 때 프라이머리 키로 한번 더 검색하기 떄문에 성능이 느림
INSERT 할 때 프라이머리 키에 의해 레코드의 저장 위치를 정하기 떄문에 성능이 느림
프라이머리 키를 변경할 때 DELETE 하고 INSERT 하는 작업을 하기 때문에 처리 성능이 느림

간단하게 말하면 클러스터링의 장점은 빠른 읽기와 단점은 느린 쓰기이다.
일반적으로 웹 서비스의 온라인 트랜잭션 환경 ( OLTP Online Transaction Processing ) 에서는 읽기 비율이 많기 때문에 적절한 선택이 좋다.

- 클러스터링 테이블 사용시 주의사항
1. 클러스터링의 인덱스 크기
테이블의 모든 세컨더리 인덱스는 프라이머리 키를 가진다. 이는 프라이머리 키가 거질수록 세컨더리 인덱스가 함꼐 커진다.
만약 세컨더리 인덱스가 5개일 경우 프라이머리 키 크기 x 5 만큼의 크기가 커질 것이다. ( 물론 레코드 갯수에 따라 크기도 증가할 것이다. )

2. 가능하면 프라이머리 키는 AUTO-INCREMENT 보다는 업무적인 컬럼으로 생성
InnoDB 스토리지 엔진은 프라이머리 키는 클러스터링 키로 활용된다.
또한 프라이머리 키로 검색하는 경우 성능이 빠르기 때문에 해당 레코드를 업무적으로 많이 검색된다면 해당 컬럼을 키로 설정하는 것이 좋다.
# 비록 크기가 클지라도..

3. 프라이머리 키는 명시할 것
InnoDB는 프라이머리 키를 설정하지 않으면 내부에서 일련번호를 생성한다. 이는 사용자가 접근할 수 없으며 보이지도 않는다.
InnoDB가 내부적으로 만든 일련 번호는 , AUTO_INCREMENT 를 생성하고 프라이머리 키로 설정한 것과 같다.

이는 사용하지 못하는 것 보다 낫기 떄문에 적어도 AUTO_INCREMENT 로 설정하고 사용하는 것이 낫다.

4. AUTO-INCREMENT 칼럼을 인조 식별자로 사용할 경우
인조 식별자는 프라이머리 키를 대체하기 위해 인위적으로 만든 프라이머리 키를 말한다.\
가끔 프라이머리키가 길고, 세컨더리 인덱스도 많다면 AUTO-INCREMENT 컬럼을 추가하고 해당 컬럼을 프라이머리 키로 설정하면 인덱스가 커지는 것을 방지할 수 있다.
비슷 하게 로그 테이블 같은 경우는 INSERT만 하기 때문에 이와 같이 인조 식별자를 사용하는 것이 좋다.

[ 유니크 인덱스 ]
유니크는 인덱스보다는 제약 조건에 가깝다. 이는 같은 인덱스에 같은 값이 2개 이상 저장될 수 없음을 의미한다. MySQL 에서는 인덱스 없이 유니크 제약만 설정할 수 없다.
근데 유니크 인덱스에는 NULL이 저장될 수 있으나, NULL은 값이 없기 떄문에 2개 이상 저장될 수 있다.
MySQL에서는 프라이머리 키는 기본적으로 NULL을 허용하지 않는 유니크 속성이 부여된다. 다만 InnoDB 테이블에 대해 프라이머리 키는 클러스터링 키와 같은 역할을 하므로 유니크 인덱스와는 살짝 다르다.

- 유니크 인덱스와 일반 세컨더리 인덱스 비교
유니크 인덱스와 유니크 하지 않은 세컨더리 인덱스는 인덱스 구조상 차이점이 없다.

1. 인덱스 읽기
유니크 인덱스와 유니크 하지 않은 세컨더리 인덱스는 성능상 차이는 거의 없다.
이는 유니크 하지 않은 세컨더리 인덱스는 읽어야 할 데이터가 더 많기 때문에 시간이 더 걸리는 것 뿐이다.
	ㄴ 데이터를 더 읽어야 하는건 디스크 읽기가 아니라 CPU에서 컬럼 값을 비교하는 것 뿐이다.
만약 읽어야 할 레코드의 건수가 같다면 성능상의 차이는 미미하다.

2. 인덱스 쓰기
새로운 레코드를 INSERT 하고나 UPDATE 를 하는 경우에 인덱스 쓰기 작업이 필요하다.
하지만 유니크 인덱스는 저장하는 과정은 빨리 처리되지만 ( 체인지 버퍼를 사용한다. ) 값을 쓸 때 중복된 값이 있는지 없는지 체크하기 때문에 유니크 하지 않은 인덱스보다 느리다.

# MySQL 에서는 유니크 인덱스에서 중복된 값을 체크할 때 읽기 잠금, 쓰기 잠금을 하는데 해당 과정에서 데드락이 자주 발생한다.

- 유니크 인덱스 주의사항
꼭 필요하다면 사용하면 좋겠지만, 더 성능이 좋아질 것으로 생각하고 불필요하게 유니크 인덱스를 생성하는 것은 좋지 못하다.
MySQL에서 유니크 인덱스는 일반 인덱스와 같은 역할을 하기 때문에 중복해서 생성할 필요는 없다.
그 외 세컨더리 인덱스, 프라이머리 키와 동일한 역할을 하기 떄문에 생성할 필요는 없다.

그 밖에도 유니크 인덱스는 실행 계획이나 테이블의 파티션에 미치는 영향이 있다.
결론적으로 유니크 인덱스는 유일성이 꼭 보장되어야 하는 컬럼에 대해서만 유니크 인덱스를 생성하되, 그렇지 않다면 유니크하지 않는 세컨더리 인덱스를 고려해보자.

[ 외래키 ]
MySQL 에서 외래키는 InnoDB 스토리지 엔진만 설정할 수 있으며, 외래키 제약으로 설정되면 자동으로 연관된 테이블의 컬럼에 인덱스가 자동으로 설정된다.
외래키가 제거되지 않은 상태에서는 자동으로 생성된 인덱스를 제거할 수 없다.

InnoDB의 외래키 관리엔 중요한 특징이 있다.
1. 테이블 변경이 발생하는 경우에만 잠금 대기(경합)가 발생한다.
2. 외래키와 연관 없는 컬럼을 변경할 땐 최대한 잠금 대기(경합)을 발생시키지 않는다. 

- 자식 테이블의 변경이 대기하는 경우
자식 테이블이 외래키를 변경할 때, 부모 테이블의 레코드를 확인해야 하는데 이때 부모 테이블의 해당 레코드가 쓰기 잠금이 걸려있으면 해당 쓰기 잠금이 해제될 떄 까지 기다린다.
즉, 부모 테이블의 레코드가 트랜잭션이 시작되어 쓰기 잠금되어 있다면, 연관된 자식 테이블의 레코드는 트랜잭션이 COMMIT되거나 ROLLBACK 될 때 까지 기다린다.

만약 외래키가 아닌 컬럼을 수정할 경우 위와 같은 잠금 확장이 발생하지 않는다.

- 부모 테이블의 변경 작업이 대기하는 경우
부모 테이블의 레코드를 삭제할 때, 자식 테이블의 레코드에 ( 쓰기 잠금 ) 락이 걸려 있으면 해당 레코드의 락이 해제될 때 까지 대기 한다.
그 이유는 외래키의 특성(ON DELETE CASCADE) 때문에 부모 레코드가 삭제되면 자식 레코드도 삭제되어야 하기 때문이다.

데이터베이스에서는 외래키에 이러한 특징 떄문에 잠금 경합까지 고려하여 데이터 모델링을 하는 것이 좋다.
외래키를 다룰 때 확인을 위해 읽기 잠금을 걸어야 하는데 만약 경합이 걸리면 전체적인 성능을 떨어뜨릴 수 있다.