
[ 디스크 읽기 방식 ]
- 하드 디스크 드라이브 ( HDD ) 와 솔리드 스테이트 드라이브 ( SSD )
하드디스크는 기계식 장치로 전자식 저장 매체인 SSD 보다 속도가 느리다. 그리고 디스크 장치는 병목이 발생하는 위치가 될 때가 많다.

SSD는 기존 하드 디스크와의 순차 I/O 속도와 차이는 크게 나진 않지만, 랜덤 I/O 에서는 SSD가 더 빠른 성능을 보인다.
그리고 DBMS 에서는 랜덤 I/O 를 통해 작은 데이터를 읽고 쓰는 작업이 대부분이라 SSD는 RDBMS 용 스토리지에 최적이다.

# 데이터베이스 성능 튜닝은 어떻게 디스크 I/O를 줄이는 지에 관건일 떄가 많다.

- 랜덤 I/O 와 순차 I/O
랜덤 I/O와 순차 I/O는 하드 디스크 드라이브의 플래터 ( 원판 ) 을 돌려서 읽어야 할 데이터가 저장된 위치에 디스크 헤더를 이동시킨 다음 데이터를 읽는다.

순차 I/O는 3개의 데이터를 디스크에 기록하기 위해 시스템 콜을 1번 요청하고, 랜덤 I/O는 같은 조건으로 시스템 콜을 3번 요청한다.
즉, 데이터 기록 위치를 찾기 위해 순차 I/O는 디스크의 헤드르 1번 움직이고 랜덤 I/O는 3번 움직인다.
디스크에서 데이터를 쓰고 읽는데 걸리는 시간은 디스크 헤더를 움직이는 단계에서 결정되기 때문에 순차 I/O가 랜덤 I/O 보다 3배 더 빠르다.

그래서 여러번 쓰기 또는 읽기를 자주하는 데이터베이스 작업 ( 랜덤 I/O 작업 ) 특성 상 MySQL 서버에서 작업의 부하가 크다.
이는 디스크 원판을 가지지 않는 SSD 가 더 빠를 것 같지만, SSD 에서도 랜덤 I/O의 성능이 떨어진다.
# 물론 디스크 헤더의 위치 이동 없이 얼마나 많은 데이터를 한번에 기록하는 것이 중요하다.

사실 쿼리 튜닝은 랜덤 I/O 자체를 줄이는 것이 목적이다. 즉 필요한 데이터만 읽도록 쿼리를 개선하는 것이다.

[ 인덱스란? ]
인덱스는 책의 맨 뒤에 있는 찾아보기와 같다. 책의 맨 뒤에 있는 찾아보기에 나오는 내용은 데이터 파일에 해당한다 볼 수 있다.
그리고 찾아보기에서 나오는 페이지 번호는 데이터가 저장된 주소가 될 수 있다.
DBMS 도 특정 칼럼과 해당 레코드가 저장된 주소를 키와 값의 쌍으로 인덱스를 만든다. 그리고 정렬을 통해 빠르게 데이터를 찾을 수 있게 한다.

인덱스는 항상 정렬된 상태를 유지하기 때문에 조회인 SELECT 는 성능이 빠르지만, 데이터의 추가와 삭제인 UPDATE 와 DELETE 작업은 속도가 느리다.
이는 인덱스에 사용할 컬럼이 많아질수록 저장 속도는 더 느려질 것이다. 물론 데이터의 조회 기능이 중요하다면 희생할 수 있어야 한다.

인덱스는 데이터를 관리하는 방식과 중복 값 허용에 따라 여러 가지가 있다.
인덱스를 역할별로 구분해본다면 프라이머리 키와 보조 키 ( 세컨더리 인덱스 ) 로 나뉠 수 있다.

- 프라이머리 키
해당 레코드를 대표하는 컬럼의 값으로 만들어진 인덱스로, 해당 컬럼으로는 레코드를 식별할 수 있는 기준이 되기 때문에 식별자라고 부른다.
프라이머리 키는 NULL 과 중복을 허용하지 않는다.

- 보조 키
프라이머리 키를 제외한 모든 인덱스를 말한다. 
유니크 인덱스는 프라이머리 키와 성격이 유사하고, 프라이머리 키를 대체할 수 있어서 대체 키라고도 하는데, 별도로 분류하기도 하고 세컨더리 인덱스라고도 한다.

- B-Tree 알고리즘
B-Tree 알고리즘은 가장 많이 사용된 알고리즘이며, 값을 변경하지 않고 인덱싱하는 알고리즘이다.

- Hash 인덱스 알고리즘
Hash 인덱스 알고리즘은 칼럼의 값으로 해시값을 계산해서 인덱싱하는 알고리즘으로 검색 속도가 매우 빠르다는 특징을 가지고 있다.
하지만 값의 변형으로 Prefix 를 통한 검색이나 범위 검색과 같은 인덱스는 사용할 수 없다.
Hash 인덱스는 주로 메모리 기반 데이터베이스에서 많이 사용된다.

- 유니크 인덱스
단순히 1개의 값이 존재한다.
이는 동등 조건으로 조회했을 때 1건의 데이터가 조회되면 더이상 찾이 않아도 된다는 것을 옵티마이저에게 알려주는 효과를 낸다.
뿐만 아니라 MySQL에서의 처리 방식의 변화나 차이점이 많다.

- 유니크하지 않은 인덱스
2개 이상의 값이 존재한다.

[ B-Tree 인덱스 ]
B-Tree 는 데이터베이스의 인덱스 알고리즘으로 가장 많이 사용되는 알고리즘이자 가장 먼저 도입된 알고리즘이다.
B-Tree 에서 B 의 약자는 Binary ( 이진 ) 이 아니라 Balanced 를 의미한다.

B-Tree는 원래의 값을 변형하지 않고, 인덱스 내에서 항상 정렬된 상태를 유지한다.
# 물론 값의 일부분만 잘라서 관리한다.
전문 검색과 같은 특수항 경우가 아니라면 대부분 인덱스는 B-Tree를 사용한다.

- B-Tree 의 구조
B-Tree는 트리 형태의 구조로 최 상단에는 루트 노드가 있고 그 하단에 자식 노드들이 있다.
그리고 최 하단의 있는 ( 자식이 없는 ) 노드는 리프 노드라 하고, 그 중간에 있는 노드를 브랜치 노드라 한다.

데이터베이스에서 인덱스와 실제 데이터가 저장된 주소 위치가 따로 관리 되는데, 리프 노드에는 항상 실제 데이터가 저장된 위치인 주소값이 있다.
여기서 인덱스는 항상 정렬된 상태를 유지하지만, 실제 데이터인 데이터 파일들은 정렬된 상태는 아니다.
# 데이터 파일들은 INSERT된 순서대로 저장하는 것이 아니다. 물론 삭제와 수정 없이 INSERT만 한다면 순서대로 저장되지만, RDBMS 는 삭제되어 발생한 빈 공간에 INSERT 될 수 있게 설계되어 있다.

인덱스는 레코드의 키 칼럼만 가지고 있으므로 다른 컬럼을 가져오기 위해선 데이터 파일에서 해당 레코드를 조회해야 한다.
이를 위해 인덱스의 리프 노드에는 해당 레코드가 저장된 주소를 가진다. ( 해당 주소는 데이터 파일에서 레코드가 저장된 위치이다. )

MyISAM 테이블에서는 세컨더리 인덱스는 물리적 주소를 가지고 있고, InnoDB 테이블에서는 프라이머리 키를 주소처럼 사용된다.
그래서 InnoDB 테이블에서 인덱스를 통해 레코드를 읽을 때 프라이머리 키 값을 이용해 인덱스 검색을 한 후, 리프 노드를 거쳐 데이터를 읽는다.
그에 비해 MyISAM 은 인덱스에 물리적 주소를 가지고 있어 바로 데이터 파일로 접근할 수 있다.

[ B-Tree 인덱스 키 추가 및 삭제 ]
- B-Tree의 삽입
B-Tree에 새로운 키 값이 저장될 때 B-Tree 에 적재될 위치 중 적절한 위치를 검색해야 한다.
저장될 위치가 결정되면 레코드의 키 값과 레코드가 저장된 주소 위치를 B-Tree의 리프 노드에 저장한다.
만약 리프 노드가 꽉 차서 더이상 저장할 수 없을 때, 리프 노드를 분리해야 하는데 이는 상위 브랜치 노드까지 작업의 영향을 미치므로 작업 시간이 많이 든다.

MyISAM 이나 MEMORY 스토리지 엔진은 INSERT 문장이 실행되면 즉시 새로운 키 값을 B-Tree 에 추가한다.
다만 InnoDB는 필요하다면 인덱스 키 추가 작업을 지연시켜 나중에 처리하게 한다. 하지만 프라이머리 키나 유니크 인덱스는 중복체크를 해야하기때문에 즉시 B-Tree에 추가한다.

- 인덱스 키 삭제
B-Tree의 키 삭제의 경우, 해당 키 값이 저장된 B-Tree 의 리프 노드를 찾아 제거 마크만 하면 된다.
제거 마크가 활성화된 인덱스는 방치되거나 재활용 된다. 이때 인덱스에 마킹 작업 또한 디스크에 쓰기가 필요하므로 디스크 I/O 작업이 필요하다.

InnoDB 스토리지 엔진에서는 해당 작업또한 지연처리 될 수 있다. 물론 사용자 입장에서 영향력을 미치진 않는다.
반대로 MyISAM 이나 MEMORY 스토리지 엔진에서는 체인지 버퍼와 같은 기능이 없으므로 인덱스 키 삭제 완료 후 다음 작업을 처리한다.

- 인덱스 변경
인덱스의 키 값에 따라 리프 노드의 위치가 결정되기 때문에 B-Tree에서 인덱스 상 키 값만 변경하는 것은 불가능하다.
그렇기 때문에 기존 키 값을 삭제한 후 다시 새로운 키 값을 추가하는 형태로 진행된다.
물론 InnoDB는 체인지 버퍼를 통해 지연 처리 될 수 있다.

- 인덱스 키 검색
UPDATE, DELETE, INSERT 작업 수행 시 작업의 성능을 떨어트리는 인덱스 구축은 사실 빠른 검색을 위해서이다.
인덱스를 검색하는 과정은 B-Tree의 루트 노드부터 시작해 브랜치 노드를 거쳐 최종 리프 노드까지 이동하는 트리 탐색을 진행한다.

트리 탐색은 SELECT 뿐만 아니라 UPDATE 나 DELETE 를 처리하기 위해 사용된다. ( 작업 대상 레코드를 검색할 경우 )
B-Tree 인덱스는 완전 일치나, 앞부분 일치, 비교 검색에서도 활용할 수 있지만 뒷 글자로는 사용할 수 없다.
또한 인덱스의 키 값이 변경된 후 비교되는 경우에는 인덱스를 사용할 수 없다. 이는 변형된 값은 인덱스에 존재하는 값이 아니기 때문이다.
	ㄴ 예를 들어 함수나 연산을 수행한 결과로 정렬하거나 검색하는 작업을 말한다.
	
InnoDB 스토리지 엔진은 레코드 잠금이나 넥스트 키락이 검색에 사용된 인덱스를 잠근 후 테이블의 레코드를 잠그는 방식으로 되어 있다.
이때 UPDATE나 DELETE 문장이 실행될 때 테이블에 적절히 사용할 수 있는 인덱스가 없으면 불필요하게 많은 레코드를 잠근다. ( 때로는 모든 레코드를 잠글 수 있다. )
따라서 InnoDB 스토리지 엔진에서는 그만큼 인덱스의 설계가 중요하다.

[ B-Tree 인덱스 사용에 영향을 미치는 요소 ]

- 인덱스 키 값의 크기
B-Tree 인덱스는 인덱스를 구성하는 컬럼의 크기와 레코드 건수, 유니크한 인덱스 키 값의 갯수에 따라 작업의 성능이 영향 받는다.

InnoDB 스토리지 엔진은 디스크에 데이터를 저장하는 기본 단위를 페이지 또는 블록이라고 하며, 디스크의 모든 읽기 및 쓰기의 최소 단위가 된다.
인덱스는 페이지 단위로 관리되며 B-Tree를 구성하는 루트,브랜치,리프 노드의 기준은 페이지 단위이다.

B-Tree에 있는 각 노드들의 자식 노드는 가변적이며, 자식 노드는 인덱스 페이지의 크기나 키 값의 크기에 따라 달라진다.
InnoDB 스토리지 엔진은 페이지의 크기를 4KB ~ 64KB 사이의 값을 선택할 수 있으며 기본 값은 16KB 이다.

인덱스 페이지가 16KB일 경우 주소값 16바이트와 자식노드주소는 N바이트를 가지게 된다. 자식노드주소는 페이지의 종류에 따라 6B ~ 12바이트의 크기를 가진다.
위의 경우 하나의 인덱스 페이지에는 16*1024/(16+12) = 585개의 자식 노드를 저장할 수 있다. ( 자식노드주소를 12바이트로 가정 )
만약 인덱스 키 값이 32바이트로 커진다면 16*1024/(32+12) = 372개의 자식 노드를 저장할 수 있다.
이떄 SELECT 의 조회결과가 500개일 경우 인덱스 키 값이 16바이트인 경우 한번으로 끝나지만 32바이트인 경우 2번을 디스크로부터 읽어야 한다.
이는 인덱스 키 값이 커지면 디스크로부터 읽어야 하는 횟수가 늘어나고 이를 통해 성능이 저하된다는 것을 알 수 있다.

그리고 인덱스의 키 길이가 길어진다는 것은 인덱스 크기가 커진다는 것을 의미한다. 이는 캐시할 수 있는 제한적인 영역인 버퍼 풀 ( InnoDB ) 나 키 캐시 ( MyISAM ) 에 캐시해 둘 수 있는 레코드의 수가 줄어든다는 것을 말한다.

#자식노드주소에는 여러가지 복합 정보가 포함되어 있다

- B-Tree 깊이
B-Tree 인덱스의 깊이는 중요하지만 직접 제어하는 방법은 없다.
인덱스의 깊이는 MySQL 에서 값을 검색할 때 몇 번 디스크에서 읽어야 하는지와 연결된다.

만약 인덱스 키 값의 크기가 커진다면, 인덱스 페이지에 저장되는 인덱스의 개수가 적어지고, 그 때문에 같은 레코드 건수일수록 B-Tree의 깊이가 깊어져서 디스크를 더 많이 읽게 된다.
따라서 인덱스 키 값의 크기는 가능하면 작게 만드는 것이 좋으며, 실제로 대용량 데이터베이스일지라도 B-Tree의 깊이가 5단계 이상 깊어지진 않는다.

- 선택도(기수성)
인덱스에서 선택도와 기수성은 거의 같은 의미로 사용되며, 인덱스 키 값 중에서 유니크한 값의 수를 말한다.
만약 전체 인덱스 키 값 100개 중에서 유니크한 값이 10개라면 기수성은 10이 된다.
# 이는 중복된 값이 많아질수록 기수성과 선택도는 줄어든다.
인덱스는 선택도가 높을수록 검색할 대상이 줄어들기 때문에 성능이 빨라진다.

만약 10000개의 레코드 중 유니크한 값의 개수가 10건이라면, 인덱스로 키를 검색한다고 해도 1000건의 데이터를 더 검색해야 한다.
	ㄴ 유니크 값으로 1개를 찾았다 하더라도 10000/10 = 1000 ( 전체 레코드 수 / 유니크 한 값의 갯수 ) 번을 더 검색해야 원하는 하나의 데이터가 나올 수 있기 떄문이다. ( 데이터 중복이 없다는 가정 )
그렇기 떄문에 유니크한 값의 개수가 작다 하면 유니크 키로 적절한가 생각해야 한다.
# 선택도가 좋지 않더라도 정렬이나 그루핑과 같은 작업을 위해 선택도가 낮은 인덱스가 필요한 경우도 있다.

- 읽어야 하는 레코드 건수
인덱스를 통해 테이블의 레코드를 읽는 작업이, 인덱스를 거치지 않고 바로 테이블을 조회하는 것 보다 높은 비용이 발생할 수 있는 상황이 있다.
일반적인 DBMS의 옵티마이저에서는 인덱스를 통해 레코드를 1건 읽는 것이, 테이블에서 직접 레코드 1건을 읽는 것 보다 4~5배 더 비용이 발생할 것으로 예측한다.

이는 인덱스를 통해 읽어야 할 레코드의 건수가 전체 테이블의 20~25%일 경우 전체 테이블을 전부 가져와서 필요한 것만 가져오는 것이 효율적이다. ( 물론 옵티마이저가 예상한 수 )
이는 MySQL 옵티마이저가 이러한 상황이 올 경우 인덱스를 사용하지 않고 전체 테이블을 처음부터 끝까지 가져와서 처리할 것이다.
	ㄴ 인덱스를 사용하도록 힌트를 준다 하더라도 이를 무시할 것이다.
	
[ B-Tree 인덱스를 통한 데이터 읽기 ]

- 인덱스 레인지 스캔
인덱스 레인지 스캔은 인덱스 접근 방법 중에서 가장 대표적이고 빠른 방법이다.
인덱스 레인지 스캔은 한 건만 읽거나 여러 건을 읽는데 차이가 있지만, 여기선 하나의 이름인 인덱스 레인지 스캔을 활용한다.

인덱스 레인지 스캔은 탐색해야 할 범위가 정해졌을 때 사용하는 방식이다.
루트 노드를 거쳐, 브랜치 노드, 리프 노드까지 찾아 들어가고 시작해야 할 위치를 찾으면 리프 노드를 차례 대로 스캔하면 된다.
그리고 최종적으로 스캔을 멈춰야 할 위치에 다다르면 해당 결과를 사용자에게 반환한다.
# 인덱스는 항상 정렬된 상태를 유지하기 때문에 한 리프 노드를 기준으로 정순 혹은 역순으로 조회하면 오름차순 혹은 내림차순으로 데이터를 읽을 수 있다.

더 중요한 것은 리프 노드에 있는 레코드의 주소로 실제 디스크에 저장된 레코드 데이터를 가지고 와야 한다.
문제는 레코드 한 건을 조회할 때 마다 랜덤 I/O가 한 번씩 일어난다는 것이다.
그렇기 때문에 인덱스를 통해 데이터 레코드를 읽는 작업은 비용이 많이 드는 작업으로 분류된다.
그리고 인덱스를 통해 읽어야할 데이터의 레코드기 20~25%를 넘으면 테이블의 데이터를 직접 읽는 것이 더 효율적이다.

인덱스 레인지 스캔의 순서
1. 인덱스에서 조건에 일치하는 값이 저장된 위치를 찾는다, ( 인덱스 탐색 )
2. 1번에서 탐색된 위치부터 필요한 만큼의 인덱스를 쭉 읽는다. ( 인덱스 스캔 )
3. 2번에서 조회한 인덱스 키와 레코드 주소를 통해 레코드가 저장된 페이지를 가져오고 최종 레코드를 읽어온다.

쿼리가 필요로 하는 데이터에 따라 3번 과정이 수행되지 않을 수도 있는데 이를 커버링 인덱스라고 한다.
커버링 인덱스는 디스크에 레코드를 읽지 않아도 되어 읽기 속도가 빠르다는 특징을 가지고 있다.

위에 1번, 2번 과정이 얼마나 수행됐는지는 SELECT STATUS LIKE '%Handler_%' 쿼리를 통해 알 수 있다.
단 해당 레코드로 실제 디스크에 레코드를 조회했는지는 알 수 없다.
Handler_read_key 는 1번 , Handler_read_next Handler_read_prev 는 2번 단계에서 수행한 건수.

- 인덱스 풀 스캔
인덱스 풀 스캔은 인덱스를 사용하지만 인덱스를 처음부터 끝까지 모두 읽는 방식을 뜻한다.
이는 조건절에 사용된 컬럼이 인덱스의 첫 번째 컬럼이 아닌 경우에 인덱스 풀 스캔이 발생한다.
# 예를 들어 인덱스가 (A,B,C) 순으로 되어있을 떄, 쿼리의 조건절이 B 이나 , C 컬럼으로 검색하는 경우

이는 쿼리가 인덱스에 명시된 컬럼으로만 조건을 처리할 수 있는 경우에만 해당 방식으로 처리한다. 인덱스 뿐만이 아니라 데이터 레코드도 조회해야 한다면 해당 방식을 사용하지 않는다.
# 인덱스의 크기는 테이블 크기보다 작으므로, 직접 테이블을 조회하는 것 보다는 효율적이다.

이는 인덱스 리프 노드의 맨 앞이나 맨 뒤로 이동한 후, 인덱스의 리프 노드들을 연결하는 링크드 리스트를 따라서 처음부터 끝까지 탐색하는 방식이다.
인덱스 레인지 스캔보다는 빠르진 않지만 테이블 풀 스캔보다는 효율적이다.
# 그 이유는 인덱스에 포함된 컬럼만으로 처리가 가능하다면 테이블 레코드를 조회하지 않아도 되기 때문이다. 그렇기 떄문에 더 적은 디스크 I/O 로 처리할 수 있다.

- 루즈 인덱스 스캔
루즈 인덱스 스캔은 느슨하게 인덱스를 읽는 것을 뜻한다. ( 반대로 위에 두 인덱스 스캔은 타이트 인덱스 스캔으로 분류된다. )
루즈 인덱스 스캔은 인덱스 레인지 스캔과 비슷하지만, 중간에 필요하지 않은 인덱스는 무시하고 다음으로 넘어간다.
	ㄴ 일반적으로 Group By나 집합 함수 MIN() , MAX() 에 대해 최적화하는 경우 사용된다.
	ㄴ 위와 같이 최적화 했을 경우 각 그룹 별로 맨 앞 or 맨 뒷 레코드만 읽고 다음 그룹으로 넘어가는 최적화를 할 수 있다. ( WHERE 가 있다 하더라도 조건에 맞는 데이터들을 모두 스캔할 필요가 없다는 것을 옵티마이저가 판단한다. )
	
	
- 인덱스 스킵 스캔
데이터베이스에서 인덱스를 구성하는 컬럼의 순서는 중요하다.
그 이유는 (A,B) 순서로 인덱스를 생성하였을 경우, 조건절에 A 를 사용하지 않고, B만 사용했을 경우 인덱스를 사용할 수 없다.
MySQL 8.0 버전 부터는 옵티마이저가 A를 건너뛰고 B만으로도 인덱스 검색이 가능하도록 인덱스 스킵 스캔 최적화 기능이 도입됐다.

MySQL 8.0 이전 부터는 조건절에 A를 사용하지 않았다면 인덱스 풀 스캔 or 테이블 풀 스캔을 진행할 것이다. ( SET optimizer_switch='skip_scan=off' 를 통해 확인 가능 )
옵티마이저는 A 컬럼에 대해 유니크한 값을 모두 조회한 후, 주어진 쿼리에 A 컬럼을 추가해서 다시 실행한다.
	ㄴ 즉 B 조건을 그대로 두고, A에 유니크한 값이 10가지 일 경우, 10번의 쿼리를 실행한다.
	
인덱스 스킵 스캔은 생략된 인덱스 컬럼의 유니크 값은 적어야 하며, 커버링 인덱스로 처리되어야 한다.
만약 생략된 인덱스 컬럼에 유니크한 값이 많다면 스캔 시작 지점을 검색하는 비용이 많아져서 결국 성능이 떨어지게 될 것이다.
또한 커버링 인덱스가 아닌 경우 나머지 컬럼도 필요로 하기 때문에 풀 테이블 스캔으로 실행 계획을 세우게 된다.