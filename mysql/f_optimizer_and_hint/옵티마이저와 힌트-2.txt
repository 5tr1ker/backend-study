- 인덱스 머지
대부분의 옵티마이저는 테이블 별로 하나의 인덱스만 활용하도록 실행 계획을 세운다.
하지만 인덱스 머지 실행 계획을 사용하면 하나의 테이블에 2개 이상의 인덱스를 활용해 처리할 수 있다.

일반적인 경우 하나의 쿼리에 대해 여러 WHERE 조건이 있더라도, 인덱스에 포함된 컬럼 중 하나만 인덱스를 통해 조회를 하고 나머지 조건에 대해서 체크만 하는 형식으로 진행된다.
물론 한 인덱스를 활용해서 작업의 범위를 줄일 수 있는 경우라면 하나의 인덱스만 활용하는 것이 효율적이다.
하지만 각각의 조건이 서로 다른 인덱스를 사용할 수 있고, 해당 조건의 결과 레코드의 값이 많을 때 MySQL 서버는 인덱스 머지 실행 계획을 선택한다.

인덱스 머지 실행 계획은 3가지 계획으로 나눌 수 있다.
3가지 방법 모두 여러개의 인덱스를 가져오는 것은 같으나, 각각의 결과를 어떻게 병합할지에 따라 구분된다.
1. index_merge_intersection
2. index_merge_sort_union
3. index_merge_union

index_merge 옵티마이저 옵션은 위의 3가지 옵션을 모두 제어할 수 있다.

- 인덱스 머지 ( 교집합 )

SELECT * FROM tables WHERE column_1 = ? AND column_2 = ?

위의 쿼리 중 column_1 과 column_2 에 대해 각각의 인덱스를 가지고 있고, 조건이 인덱스를 사용할 수 있을 때
옵티마이저는 두개의 인덱스를 각각 검색해서 그 결과의 교집합만 반환하는 것을 의미한다.
# 물론 각 조건의 실행 결과 레코드 갯수가 많을 경우 해당 방식을 사용한다.
# 두 조건에 만족하는 레코드 건수가 적을 때, 불필요한 데이터 페이지 읽기 횟수를 줄이고자 사용한다. ( 즉 하나의 조건만 사용했을 경우 5000건인데 그 중 15건이 다른 조건에 만족하는 경우 4985건은 버려지게 된다. )

이때 세컨더리 인덱스에는 프라이머리 키를 포함하고 있기 때문에 하나의 인덱스만 사용해서 처리하는 것도 성능이 좋을 수도 있다.
이때는 index_merge_intersection 최적화를 비활성화하면 된다.

이때 실행 계획의 Extra 컬럼에 Using intersect 라고 표시된다.

# 만약 두 컬럼 중 하나만 인덱스를 사용할 수 있다면 인덱스 레인지 스캔을 사용한다.

- 인덱스 머지 ( 합집합 )

SELECT * FROM tables WHERE column_1 = ? OR column_2 = ?

위의 쿼리 중 column_1 과 column_2 에 대해 각각의 인덱스를 가지고 있고, 조건이 인덱스를 사용할 수 있을 때
OR 조건으로 연결된 경우에 사용하는 최적화이다.
# 교집합은 AND 로 연결된 것과는 달리 합집합은 OR 로 연결되어 있다.

이때 실행 계획에서 Extra 컬럼에 Using union 으로 표시된다.
이때 각각의 인덱스를 통해 조회된 결과는 프라이머리 키로 이미 정렬되어 있기 때문에 MySQL 서버는 이러한 각각의 컬럼들을
하나씩 가져와 비교하면서 중복을 제거하고 정렬된 상태로 반환한다. ( 조회된 결과는 이미 정렬되어 있기 때문에 별도의 정렬 작업은 안한다. )
이렇게 두 집합의 결과를 가져와 중복을 제거할 때 사용하는 알고리즘은 우선순위 큐라고 한다.
# 우선순위 큐는 두 집합이 인덱스 검색을 통해 이미 정렬되어 있기 때문에 정렬된 값에서 하나씩 가져와서 비교하면서 중복을 제거한다.

# 만약 두 조건중 하나라도 인덱스를 사용할 수 없다면 풀 테이블 스캔으로 처리한다.

- 인덱스 머지 ( 정렬 후 합집합 )

위와 같이 우선순위 큐 알고리즘을 사용하기 위해선 각 컬럼의 조회 결과가 정렬된 상태를 유지해야 한다.
하지만 두 집합 중 하나라도 정렬이 되어 있지 않다면, MySQL 서버는 각 집합을 특정 컬럼으로 ( 보통 프라이머리 키 ) 로 정렬을 수행한 다음 중복을 제거한다.
이때 실행계획에서 Extra 컬럼에는 Using sort_union 으로 표기 된다.

- 세미 조인
세미 조인은 실제 조인을 수행하지 않고, 다른 테이블에 조건에 일치하는 레코드가 있는지 확인하는 형태의 쿼리를 말한다.

SELECT * FROM table_1 WHERE IN (SELECT * FROM table_2)
MySQL 5.7 서버는 위와 같은 쿼리에 대해 table_1 테이블을 풀 스캔하면서 한건씩 서브쿼리의 조건과 일치하는지 비교했다.

여기서 = (subquery) 와 IN (subquery) 의 형태의 세미 조인 쿼리에 3가지 최적화 방법이 있다.
1. 세미 조인 최적화 
2. In to Exists 최적화
3. Materialization 최적화

<> (subquery) 와 NOT IN (subquery) 형태의 안티 세미 조인 쿼리의 3가지 최적화 방법은 2가지가 있다.
1. IN to Exists 최적화
2. Materialization 최적화

여기서 세미 조인 최적화 전략들은 Table Pull-out , Duplicate Weed-out , First Match , Loose Scan , Materialization 이 있다.
쿼리에 사용된 테이블이나 조인 조건에 따라 옵티마이저는 사용 가능한 전략들을 선택한다.

- 테이블 풀 아웃
Table Pull-out 최적화는 세미 조인의 서브쿼리에 사용된 테이블을 아우터 쿼리로 끄집어낸 후 쿼리를 조인 쿼리로 재작성하는 최적화이다.
이는 서브 쿼리 최적화 도입 전 수동으로 쿼리를 튜닝하던 대표적인 방법이다.

SELECT * FROM table_1 WHERE IN (SELECT * FROM table_2) 와 같은 쿼리의 실행 계획을 보면
두개의 테이블에 대해 id 컬럼 값이 1로 동일하며 Extra 컬럼에는 Using table pullout 과 같은 메세지가 없다.
id 컬럼 값이 같다는 것은 조인되어서 사용됐음을 의미한다.

더 정확히 아는 방법은 EXPLAIN 쿼리를 실행 후 SHOW WARNINGS 명령으로 MySQL 옵티마이저가 재작정한 쿼리를 살펴보는 방법이 있다.
해당 명령으로 실행된 쿼리를 보면 IN (subquery) 형태가 사라지고, JOIN 으로 쿼리가 재작성된 것을 확인할 수 있다.

Table pullout 최적화는 모든 형태의 서브 쿼리에서만 사용할 수 있는 것은 아니며 제한 사항이 있다..
1. 세미 조인 서브 쿼리에서만 사용 가능하다.
2. 서브 쿼리 부분이 UNIQUE 인덱스나 프라이머리 키 룩업으로 결과가 1건인 경우에만 사용 가능하다.

또한 Table pullout 의 특징은 다음과 같다.
1. 해당 최적화가 적용될 때 기존 쿼리에서 사용했던 최적화가 사라지는 것이 아니다.
2. 만약 아우터 조인으로 그집어 낼 수 있다면 서브 쿼리는 사라진다.
3. 최대한 서브쿼리를 조인으로 풀어서 사용하라 라는 튜닝 가이드를 따라하는 역할을 한다. 서브 쿼리를 쓴다해도 못쓰는 건 아니다.