- 인덱스 머지
대부분의 옵티마이저는 테이블 별로 하나의 인덱스만 활용하도록 실행 계획을 세운다.
하지만 인덱스 머지 실행 계획을 사용하면 하나의 테이블에 2개 이상의 인덱스를 활용해 처리할 수 있다.

일반적인 경우 하나의 쿼리에 대해 여러 WHERE 조건이 있더라도, 인덱스에 포함된 컬럼 중 하나만 인덱스를 통해 조회를 하고 나머지 조건에 대해서 체크만 하는 형식으로 진행된다.
물론 한 인덱스를 활용해서 작업의 범위를 줄일 수 있는 경우라면 하나의 인덱스만 활용하는 것이 효율적이다.
하지만 각각의 조건이 서로 다른 인덱스를 사용할 수 있고, 해당 조건의 결과 레코드의 값이 많을 때 MySQL 서버는 인덱스 머지 실행 계획을 선택한다.

인덱스 머지 실행 계획은 3가지 계획으로 나눌 수 있다.
3가지 방법 모두 여러개의 인덱스를 가져오는 것은 같으나, 각각의 결과를 어떻게 병합할지에 따라 구분된다.
1. index_merge_intersection
2. index_merge_sort_union
3. index_merge_union

index_merge 옵티마이저 옵션은 위의 3가지 옵션을 모두 제어할 수 있다.

- 인덱스 머지 ( 교집합 )

SELECT * FROM tables WHERE column_1 = ? AND column_2 = ?

위의 쿼리 중 column_1 과 column_2 에 대해 각각의 인덱스를 가지고 있고, 조건이 인덱스를 사용할 수 있을 때
옵티마이저는 두개의 인덱스를 각각 검색해서 그 결과의 교집합만 반환하는 것을 의미한다.
# 물론 각 조건의 실행 결과 레코드 갯수가 많을 경우 해당 방식을 사용한다.
# 두 조건에 만족하는 레코드 건수가 적을 때, 불필요한 데이터 페이지 읽기 횟수를 줄이고자 사용한다. ( 즉 하나의 조건만 사용했을 경우 5000건인데 그 중 15건이 다른 조건에 만족하는 경우 4985건은 버려지게 된다. )

이때 세컨더리 인덱스에는 프라이머리 키를 포함하고 있기 때문에 하나의 인덱스만 사용해서 처리하는 것도 성능이 좋을 수도 있다.
이때는 index_merge_intersection 최적화를 비활성화하면 된다.

이때 실행 계획의 Extra 컬럼에 Using intersect 라고 표시된다.

# 만약 두 컬럼 중 하나만 인덱스를 사용할 수 있다면 인덱스 레인지 스캔을 사용한다.

- 인덱스 머지 ( 합집합 )

SELECT * FROM tables WHERE column_1 = ? OR column_2 = ?

위의 쿼리 중 column_1 과 column_2 에 대해 각각의 인덱스를 가지고 있고, 조건이 인덱스를 사용할 수 있을 때
OR 조건으로 연결된 경우에 사용하는 최적화이다.
# 교집합은 AND 로 연결된 것과는 달리 합집합은 OR 로 연결되어 있다.

이때 실행 계획에서 Extra 컬럼에 Using union 으로 표시된다.
이때 각각의 인덱스를 통해 조회된 결과는 프라이머리 키로 이미 정렬되어 있기 때문에 MySQL 서버는 이러한 각각의 컬럼들을
하나씩 가져와 비교하면서 중복을 제거하고 정렬된 상태로 반환한다. ( 조회된 결과는 이미 정렬되어 있기 때문에 별도의 정렬 작업은 안한다. )
이렇게 두 집합의 결과를 가져와 중복을 제거할 때 사용하는 알고리즘은 우선순위 큐라고 한다.
# 우선순위 큐는 두 집합이 인덱스 검색을 통해 이미 정렬되어 있기 때문에 정렬된 값에서 하나씩 가져와서 비교하면서 중복을 제거한다.

# 만약 두 조건중 하나라도 인덱스를 사용할 수 없다면 풀 테이블 스캔으로 처리한다.

- 인덱스 머지 ( 정렬 후 합집합 )

위와 같이 우선순위 큐 알고리즘을 사용하기 위해선 각 컬럼의 조회 결과가 정렬된 상태를 유지해야 한다.
하지만 두 집합 중 하나라도 정렬이 되어 있지 않다면, MySQL 서버는 각 집합을 특정 컬럼으로 ( 보통 프라이머리 키 ) 로 정렬을 수행한 다음 중복을 제거한다.
이때 실행계획에서 Extra 컬럼에는 Using sort_union 으로 표기 된다.

- 세미 조인
세미 조인은 실제 조인을 수행하지 않고, 다른 테이블에 조건에 일치하는 레코드가 있는지 확인하는 형태의 쿼리를 말한다.

SELECT * FROM table_1 WHERE IN (SELECT * FROM table_2)
MySQL 5.7 서버는 위와 같은 쿼리에 대해 table_1 테이블을 풀 스캔하면서 한건씩 서브쿼리의 조건과 일치하는지 비교했다.

여기서 = (subquery) 와 IN (subquery) 의 형태의 세미 조인 쿼리에 3가지 최적화 방법이 있다.
1. 세미 조인 최적화 
2. In to Exists 최적화
3. Materialization 최적화

<> (subquery) 와 NOT IN (subquery) 형태의 안티 세미 조인 쿼리의 3가지 최적화 방법은 2가지가 있다.
1. IN to Exists 최적화
2. Materialization 최적화

여기서 세미 조인 최적화 전략들은 Table Pull-out , Duplicate Weed-out , First Match , Loose Scan , Materialization 이 있다.
쿼리에 사용된 테이블이나 조인 조건에 따라 옵티마이저는 사용 가능한 전략들을 선택한다.

- 테이블 풀 아웃
Table Pull-out 최적화는 세미 조인의 서브쿼리에 사용된 테이블을 아우터 쿼리로 끄집어낸 후 쿼리를 조인 쿼리로 재작성하는 최적화이다.
이는 서브 쿼리 최적화 도입 전 수동으로 쿼리를 튜닝하던 대표적인 방법이다.

SELECT * FROM table_1 WHERE IN (SELECT * FROM table_2) 와 같은 쿼리의 실행 계획을 보면
두개의 테이블에 대해 id 컬럼 값이 1로 동일하며 Extra 컬럼에는 Using table pullout 과 같은 메세지가 없다.
id 컬럼 값이 같다는 것은 조인되어서 사용됐음을 의미한다.

더 정확히 아는 방법은 EXPLAIN 쿼리를 실행 후 SHOW WARNINGS 명령으로 MySQL 옵티마이저가 재작정한 쿼리를 살펴보는 방법이 있다.
해당 명령으로 실행된 쿼리를 보면 IN (subquery) 형태가 사라지고, JOIN 으로 쿼리가 재작성된 것을 확인할 수 있다.

Table pullout 최적화는 모든 형태의 서브 쿼리에서만 사용할 수 있는 것은 아니며 제한 사항이 있다..
1. 세미 조인 서브 쿼리에서만 사용 가능하다.
2. 서브 쿼리 부분이 UNIQUE 인덱스나 프라이머리 키 룩업으로 결과가 1건인 경우에만 사용 가능하다.

또한 Table pullout 의 특징은 다음과 같다.
1. 해당 최적화가 적용될 때 기존 쿼리에서 사용했던 최적화가 사라지는 것이 아니다.
2. 만약 아우터 조인으로 그집어 낼 수 있다면 서브 쿼리는 사라진다.
3. 최대한 서브쿼리를 조인으로 풀어서 사용하라 라는 튜닝 가이드를 따라하는 역할을 한다. 서브 쿼리를 쓴다해도 못쓰는 건 아니다.

- 퍼스트 매치
IN(subquery) 형태의 세미 조인을 EXISTS(subquery) 형태로 튜닝한 것과 비슷한 방법으로 실행된다.

SELECT * FROM table_1 IN (subquery)

위의 쿼리에 실행계획은 두 테이블의 id는 모두 1이고 Extra 컬럼에는 FirstMatch(e) 문구가 출력된다.
id가 모두 1로 통일 됐다는 것은 서브 쿼리가 아닌 조인으로 처리가 되었고, table_1 테이블의 레코드에 대해 subquery 에서 일치하는 레코드를 1건이라도 찾으면 더이상 subquery 에 있는 테이블을 검색하지 않는다는 것을 의미한다.

실제 의미로는 EXISTS(subquery) 와 동일하게 처리된 것이다.
이는 MySQL 5.5 버전에서 수행됐던 IN-to-EXISTS 변환과 비슷하게 진행된다. 하지만 IN-to-EXISTS 변환에 비해 이 최적화의 장점은 다음과 같다.
1. 여러 테이블이 조인될 때 원래 쿼리에 없던 동등 조건을 옵티마이저가 자동으로 추가한다. 
2. IN-to-EXISTS 변환 최적화는 최적화가 가능하면 무조건 수행을 하지만, FirstMatch 최적화는 일부를 수행하거나 수행하지 않게 설정할 수 있다.

퍼스트 매치 최적화의 제한 사항과 특징은 다음과 같다.
1. 퍼스트 매치 최적화는 GROUP BY나 집합 함수가 사용된 서브쿼리에서는 최적화를 사용할 수 없다.
2. 서브 쿼리가 참조하는 모든 아우터 테이블이 먼저 조회된 이후로 최적화가 진행된다.

- 루스 스캔
루스 스캔은 인덱스를 사용하는 GROUP BY 최적화 방법과 비슷하게 읽기 방식을 사용한다.

SELECT * FROM table_1 WHERE ~~ IN (SELECT ~ FROM table_2)

위와 같은 쿼리가 존재하고 서브 쿼리의 테이블에 수십만 건의 레코드가 있고, 중복을 제거한 데이터가 9건 밖에 없을 때 루스 스캔을 통해서 효율적으로 쿼리를 실행한다.
즉, 서브 쿼리의 테이블이 드라이빙 테이블로 실행되며, table_2 테이블의 프라이머리 키 부분을 유니크하게 한 건씩 읽어서 쿼리를 실행한다.

위와 같이 실행된 쿼리의 실행 계획은 Extra 컬럼에 LooseScan 이라는 문구가 표시된다.
또한 id 컬럼의 값이 모두 1 이며, 이는 조인으로 처리됐음을 보여준다.

루스 인덱스 스캔은 서브쿼리 테이블을 먼저 읽고, 그 이후 아우터 테이블을 드리븐으로 사용한다. 그래서 서브쿼리에 있는 테이블은 루스 인덱스 스캔을 사용할 수 있는 조건이 되어야 한다.

- 구체화 ( Materialization )
구체화는 세미 조인에 사용된 서브쿼리를 통째로 구체화해서 쿼리를 최적화 하는 것을 의미한다.
여기서 구체화는 내부에 임시 테이블을 생성하는 것을 의미한다.

SELECT * FROM table_1 WHERE ~ IN ( SELECT ~ FROM table_2 WHERE ~ )

위의 쿼리에서 FirstMatch 최적화를 수행하면 table_1 은 조건이 서브 쿼리 외에 아무것도 없기 때문에 table_1 을 풀 스캔해야 한다.
옵티마이저는 이러한 형태의 쿼리를 위해 서브 쿼리 구체화라는 최적화를 도입했다.

위의 쿼리의 실행 계획을 보면 총 3개의 라인이 나오며 마지막 라인의 select_type 은 MATERIALIZED 라고 표기된다.
이는 서브 쿼리가 먼저 실행되고 해당 결과로 임시 테이블을 만들고, 해당 임시테이블과 table_1 과 조인을 해서 결과를 반환한다.
# 여기서 구체화가 사용된 경우 임시 테이블이 사용된 것을 알 수 있다.

Materialization 최적화는 다른 최적화와는 달리 서브 쿼리 내에 group by 절이나 집합 함수가 있어도 사용할 수 있다.

# 단 구체화는 IN(subquery) 에서 서브쿼리는 상관 서브쿼리가 아니여야 한다.

- 중복제거
세미 조인 서브쿼리를 일반적인 INNER JOIN 으로 처리하고 마지막에 중복을 제거하는 최적화 방법이다.

SELECT * FROM table_1 WHERE ~ IN ( SELECT t2.~ FROM table_2 WHERE ~ > 15000 );

위의 쿼리에 대해 table_2 테이블에서 중복된 t2.~ 가 발생할 수 있다. 그래서 위의 쿼리를 하단의 쿼리와 같이 INNER JOIN + GROUP BY 절로 바꿔서 실행한다.
# 이는 실제로 중복 제거 최적화가 실행되는 방법을 보여준다.

SELECT * from table_1 , table_2 WHERE ~ AND ~ > 15000 GROUP BY table_2

이렇게 최적화 되면 위의 세미 조인과 같은 결과를 얻는다.

중복 제거 최적화의 처리 과정은 다음과 같다.
1. table_2 테이블의 인덱스를 스캔해서 조건에 맞는 레코드를 table_1 과 조인을 통해 탐색
2. 조인된 결과를 임시 테이블에 저장
3. 임시 테이블에서 특정 컬럼을 기준으로 중복 제거
4. 중복제거하고 남은 레코드를 반환


# 사실 1번과 2번 과정은 반복되서 처리된다. 즉, 조인 후 임시 테이블에 저장하는 과정을 반복한다. 
여기서 실행 계획에서는 Extra 컬럼에 Duplicate Weedout 이라는 문구가 없다.
대신 Start temporary 와 End temporary 라는 문구가 있는데 Start temporary 는 조인을 수행해서 임시 테이블로 저장하는 반복 과정이 실행되는 테이블,
End temporary 는 반복 과정이 끝나는 테이블을 말한다. ( 여기서 Start temporary 는 table_2 가 되고, End temporary 는 table_1 이 된다. )

중복 제거의 특징은 다음과 같다.
1. 서브쿼리가 상관 쿼리라고 해도 사용할 수 있다.
2. 서브쿼리가 GROUP BY절이나 집합 함수를 사용하면 사용할 수 없다.
3. 서브쿼리의 테이블을 조인으로 처리하기 때문에 최적화할 수 있는 방법이 많다.

- 컨디션 팬아웃
조인을 실행할 때 테이블의 조인 순서에 따라 쿼리의 성능 차이가 크다.
예를 들어 A 테이블의 레코드건수가 1만건이고 , B테이블의 레코드가 10건일 때 A 테이블을 드라이빙 테이블로 결정하면 B 테이블을 1만 번 읽어야 한다.
그래서 옵티마이저는 조건에 일치하는 레코드 건수가 낮은 테이블 부터 먼저 조인이 실행된다.

- 파생 테이블 머지
이전 버전의 MySQL 서버에서는 FROM 절에 서브 쿼리가 있을 경우, 서브 쿼리를 먼저 실행해서 그 결과를 임시 테이블에 넣어놓은 후 다음 외부 쿼리를 실행한다

SELECT * FROM (subquery) WHERE ~;
이 실행 계획을 보면 subquery 부분의 select_Type 이 DERIVED 라고 되어 있는데, 먼저 서브 쿼리를 실행하고, 그 이후 외부 쿼리를 실행다는 것이다. 
MySQL 서버에서는 이렇게 FROM 절에 사용된 쿼리를 파생 테이블 ( Derived Table ) 이라고 한다.

이때 MySQL 서버는 내부 임시테이블에 복사하고 읽는 오버헤드가 증가한다. 또한 처음에는 임시 테이블이 메모리에 관리되지만 레코드의 크기가 커지면 디스크로 이동해야 하는데, 이 과정에서 오버헤드가 더 크게 발생할 수 있다.

MySQL 5.7 버전 부터는 파생 테이블로 만들어진 서브 쿼리를 외부 쿼리와 병합해서 서브 쿼리 부분을 제거하는 최적화를 도입했다.
이 최적화를 활성화하면 select_Type 에서 DERIVED 부분이 사라지고, 하나의 테이블만 조회하는 단순 형태로 바뀐다.

하지만 다음과 같은 조건이 있을 경우 MySQL 서버는 파생 테이블을 외부 쿼리와 병합하지 못한다.
이 같은 경우 수동으로 외부 쿼리로 병합을 해주면 된다.
1. 집계 함수와 윈도우 함수가 적용된 서브 쿼리
2. DISTINCT 가 사용된 서브 쿼리
3. GROUP BY나 HAVING이 사용된 서브 쿼리
4. LIMIT이 사용된 서브쿼리
5. UNION 또는 UNION ALL 이 사용된 서브 쿼리
6. SELECT 절에 사용된 서브 쿼리
7. 값이 변경되는 사용자 변수가 사용된 서브 쿼리

- 인비저블 인덱스

MySQL 8.0 버전부터는 인덱스 가용 상태를 제어할 수 있는 기능이 제공된다.
MySQL 8.0 버전부터는 인덱스가 존재하면 옵티마이저가 항상 실행 계획을 수립할 때 해당 인덱스를 검토했지만, MySQL 8.0 버전부터는
인덱스를 삭제하지 않고, 해당 인덱스를 사용하지 못하게하는 옵션을 제공한다.

ALTER TABLE (table) ALTERI NDEX (index_id) INVISIBLE; // 해당 인덱스를 사용하지 못하게 설정
ALTER TABLE (table) ALTERI NDEX (index_id) VISIBLE; // 해당 인덱스를 사용하게 수정

SET optimizer_switch='use_invisible_index=on' 으로 설정하면 위의 설정 값 무시하고 옵티마이저가 인덱스를 활용한다.

- 스킵 스캔

인덱스가 (A,B,C) 로 구성되어 있을 때 WHERE 절에 A 에 대한 비교 조건은 필수적이다. ( 인덱스를 사용하기 위해서 )
이때 A를 건너뛰고 WHERE 절에 B부터 있을 경우 이 쿼리는 인덱스를 사용할 수 없으며, 이 같은 경우 B로 시작하는 인덱스를 새롭게 만들어 주어야 한다.

하지만 MYSQL 8.0 부터는 인덱스 스킵 스캔 최적화가 제공되어 인덱스의 선행 칼럼이 조건절에 없더라도 후행 칼럼만으로 인덱스를 이용한 쿼리 성능 개선이 가능하게 되었다.
옵티마이저는 테이블에 존재하는 모든 선행 컬럼의 값을 가져와 해당 선행 컬럼의 조건이 있는것 처럼 쿼리를 최적화 한다.
하지만 선행 컬럼이 다양한 값을 가진다면 오히려 최적화가 비효율적일 수도 있기 떄문에 옵티마이저는 선행 컬럼이 소수의 유니크한 값을 가질 때에만 인덱스 스킵 스캔을 사용한다.

- 해시 조인

해시 조인은 네스티드 루프 조인 ( 중첩 루프 조인 ) 과 많이 비교된다.
같은 쿼리가 시작되었을 때 해시 조인은 첫 번째 레코드를 찾는데 시간이 많이 걸렸지만 마지막 레코드를 찾을때 까지는 오래 걸리지 않았다., 중첩 루프 조인은 첫번째 레코드를 찾는데 빠르지만 마지막 레코드를 찾는데 시간이 걸린다.
즉, 해시 조인은 최고 스루풋 전략에 좋고 중첩 루프 조인은 최고 응답 속도 전략에 적합하다.

# 온라인 트랜잭션에서는 응답 속도가 중요하고, 분석 관련 서비스는 전체적인 처리 시간이 중요하기에 이를 구분해서 각각의 전략을 선택하면 된다.

MySQL 서버는 범용 RDBMS 이며, 여기서 범용은 온라인 트랜잭션 처리를 위한 데이터베이스 서버를 말한다.
때문에 MySQL 서버는 응답 속도에 집중해서 최적화가 되어있다. 그렇기 때문에 조인 조건의 컬럼에 인덱스가 없거나, 조인 대상 테이블 중 레코드의 건수가 적은 경우에 대해서만 해시 조인 알고리즘을 사용한다.
이는 중첩 루프 조인이 적합하지 않은 겨우 차선책으로 사용하는 기능이다. 그래서 일부로 옵티마이저 옵션으로 해시 조인을 설정하는 것은 좋지 못하다.

MySQL 8.0.17 버전까지는 해시 조인 기능이 없었기 때문에 중첩 루프 조인이 효율적으로 처리하지 못할 경우 블록 네스티드 루프 조인이라는 알고리즘을 사용했다.
MySQL 8.0.18 과 8.0.19 에서는 동등 조인을 위해 해시 조인을 사용하고, 안티 조인이나 세미 조인을 위해 블록 네스티드 루프 조인을 사용했으며, 8.0.20 부터는 블록 네스티드 루프 조인이 사용되지 않고,
네스티드 루프 조인을 사용할 수 없는 경우에 항상 해시 조인을 사용하게 바뀌었다.

만약 쿼리에서 해시 조인을 사용했다고 하면 Extra 컬럼에 hash join 이라는 문구가 표기된다.
# IGNORE INDEX 로 강제로 인덱스를 사용하지 못하게 하면 볼 수 있다.

일반적으로 해시 조인은 빌드 단계와 프로브 단계로 나뉜다.
빌드 단계는 조인 대상 테이블 중 레코드 수가 적어 해시 테이블로 만들기 용이한 테이블을 선택해 메모리에 해시 테이블로 생성하는 작업을 말한다.
# 빌드 단계에서 해시 테이블을 만들 때 사용하는 원본 테이블을 빌드 테이블이라 한다.
프로브 단계는 빌드 테이블 외에 나머지 테이블의 레코드를 읽어서 해시 테이블에 일치하는 레코드를 찾는 과정을 말한다.
# 여기서 빌드 테이블 외에 테이블을 프로브 테이블이라고 한다.
# 실행 계획에서 누가 빌드 테이블이고 누가 프로브 테이블인지 알기 어렵다. 그럴 땐 EXPLAIN FORMAT=TREE 명령을 통해 보면 쿼리 가장 안쪽에 들어간 테이블이 빌드 테이블이 된다.

해시 조인의 처리 과정은 다음과 같다.
1. MySQL 옵티마이저는 빌드 테이블의 레코드를 읽어서 해시 테이블을 생성한다.
2. 프로브 테이블들의 레코드를 하나씩 읽어 메모리에 생성된 해시 테이블에서 레코드를 찾아 결과를 반환한다.

해시 테이블을 메모리에 저장할 때 시스템 변수로 크기를 제어할 수 있는 조인 버퍼를 사용한다. 
조인 버퍼의 기본 크기는 256KB 이며, 해시 테이블의 총 레코드 건수가 조인 버퍼보다 클 경우 MySQL 서버는 빌드 테이블과 브로브 테이블을 적당한 청크로 나누어서 처리한다. ( 이떄 각 청크의 크기는 조인 버퍼보다 작게 )

MySQL 서버는 빌드 테이블을 활용해 메모리에 해시 테이블을 생성하고, 이후 조인 버퍼의 크기가 부족하면 디스크에 청크로 구분해서 저장한다.
이후 MySQL 서버는 드리븐 테이블을 활용해 해시 테이블에 검색해서 1차 조인 결과를 생성한다. 그리고 동시에 디스크에 청크로 저장한다.
따라서 디스크에는 빌드 테이블과 드리븐 테이블 각각의 2개의 청크가 생성된다.
이후 1차 조인이 완료되면 MySQL 서버는 디스크에 저장된 빌드 테이블 청크를 다시 읽어서 메모리 해시 테이블을 구축하고, 프로브 테이블 청크에서 청크를 읽어서 새로 구축된 해시 테이블과 조인해서 2차 결과를 가져온다.
이는 디스크에 저장된 청크 개수만큼 이 과정을 반복해서 완성된 조인 결과를 만든다.
# 이때 MySQL 서버는 2차 해시 함수를 이용해 빌드 테이블과 브로브 테이블을 동일 개수의 청크로 쪼개어 디스크에 저장한다.

MySQL 옵티마이저는 해시 테이블이 메모리 내에서 모두 처리할 수 있는 경우 클래식 해시 조인을 사용하고, 여러 청크로 나눠서 처리하는 경우 그레이스 해시 조인 알고리즘을 하이브리드 하게 사용한다.
또한 MySQL 서버에서 해시 해시 조인은 해시 키를 만들 때 xxHash64 를 사용하는데, xxHash64 해시 함수는 빠르고 분포도도 훌륭해서 이를 채택했다.