- 인덱스 머지
대부분의 옵티마이저는 테이블 별로 하나의 인덱스만 활용하도록 실행 계획을 세운다.
하지만 인덱스 머지 실행 계획을 사용하면 하나의 테이블에 2개 이상의 인덱스를 활용해 처리할 수 있다.

일반적인 경우 하나의 쿼리에 대해 여러 WHERE 조건이 있더라도, 인덱스에 포함된 컬럼 중 하나만 인덱스를 통해 조회를 하고 나머지 조건에 대해서 체크만 하는 형식으로 진행된다.
물론 한 인덱스를 활용해서 작업의 범위를 줄일 수 있는 경우라면 하나의 인덱스만 활용하는 것이 효율적이다.
하지만 각각의 조건이 서로 다른 인덱스를 사용할 수 있고, 해당 조건의 결과 레코드의 값이 많을 때 MySQL 서버는 인덱스 머지 실행 계획을 선택한다.

인덱스 머지 실행 계획은 3가지 계획으로 나눌 수 있다.
3가지 방법 모두 여러개의 인덱스를 가져오는 것은 같으나, 각각의 결과를 어떻게 병합할지에 따라 구분된다.
1. index_merge_intersection
2. index_merge_sort_union
3. index_merge_union

index_merge 옵티마이저 옵션은 위의 3가지 옵션을 모두 제어할 수 있다.

- 인덱스 머지 ( 교집합 )

SELECT * FROM tables WHERE column_1 = ? AND column_2 = ?

위의 쿼리 중 column_1 과 column_2 에 대해 각각의 인덱스를 가지고 있고, 조건이 인덱스를 사용할 수 있을 때
옵티마이저는 두개의 인덱스를 각각 검색해서 그 결과의 교집합만 반환하는 것을 의미한다.
# 물론 각 조건의 실행 결과 레코드 갯수가 많을 경우 해당 방식을 사용한다.
# 두 조건에 만족하는 레코드 건수가 적을 때, 불필요한 데이터 페이지 읽기 횟수를 줄이고자 사용한다. ( 즉 하나의 조건만 사용했을 경우 5000건인데 그 중 15건이 다른 조건에 만족하는 경우 4985건은 버려지게 된다. )

이때 세컨더리 인덱스에는 프라이머리 키를 포함하고 있기 때문에 하나의 인덱스만 사용해서 처리하는 것도 성능이 좋을 수도 있다.
이때는 index_merge_intersection 최적화를 비활성화하면 된다.

이때 실행 계획의 Extra 컬럼에 Using intersect 라고 표시된다.

# 만약 두 컬럼 중 하나만 인덱스를 사용할 수 있다면 인덱스 레인지 스캔을 사용한다.

- 인덱스 머지 ( 합집합 )

SELECT * FROM tables WHERE column_1 = ? OR column_2 = ?

위의 쿼리 중 column_1 과 column_2 에 대해 각각의 인덱스를 가지고 있고, 조건이 인덱스를 사용할 수 있을 때
OR 조건으로 연결된 경우에 사용하는 최적화이다.
# 교집합은 AND 로 연결된 것과는 달리 합집합은 OR 로 연결되어 있다.

이때 실행 계획에서 Extra 컬럼에 Using union 으로 표시된다.
이때 각각의 인덱스를 통해 조회된 결과는 프라이머리 키로 이미 정렬되어 있기 때문에 MySQL 서버는 이러한 각각의 컬럼들을
하나씩 가져와 비교하면서 중복을 제거하고 정렬된 상태로 반환한다. ( 조회된 결과는 이미 정렬되어 있기 때문에 별도의 정렬 작업은 안한다. )
이렇게 두 집합의 결과를 가져와 중복을 제거할 때 사용하는 알고리즘은 우선순위 큐라고 한다.
# 우선순위 큐는 두 집합이 인덱스 검색을 통해 이미 정렬되어 있기 때문에 정렬된 값에서 하나씩 가져와서 비교하면서 중복을 제거한다.

# 만약 두 조건중 하나라도 인덱스를 사용할 수 없다면 풀 테이블 스캔으로 처리한다.

- 인덱스 머지 ( 정렬 후 합집합 )

위와 같이 우선순위 큐 알고리즘을 사용하기 위해선 각 컬럼의 조회 결과가 정렬된 상태를 유지해야 한다.
하지만 두 집합 중 하나라도 정렬이 되어 있지 않다면, MySQL 서버는 각 집합을 특정 컬럼으로 ( 보통 프라이머리 키 ) 로 정렬을 수행한 다음 중복을 제거한다.
이때 실행계획에서 Extra 컬럼에는 Using sort_union 으로 표기 된다.

- 세미 조인
세미 조인은 실제 조인을 수행하지 않고, 다른 테이블에 조건에 일치하는 레코드가 있는지 확인하는 형태의 쿼리를 말한다.

SELECT * FROM table_1 WHERE IN (SELECT * FROM table_2)
MySQL 5.7 서버는 위와 같은 쿼리에 대해 table_1 테이블을 풀 스캔하면서 한건씩 서브쿼리의 조건과 일치하는지 비교했다.

여기서 = (subquery) 와 IN (subquery) 의 형태의 세미 조인 쿼리에 3가지 최적화 방법이 있다.
1. 세미 조인 최적화 
2. In to Exists 최적화
3. Materialization 최적화

<> (subquery) 와 NOT IN (subquery) 형태의 안티 세미 조인 쿼리의 3가지 최적화 방법은 2가지가 있다.
1. IN to Exists 최적화
2. Materialization 최적화

여기서 세미 조인 최적화 전략들은 Table Pull-out , Duplicate Weed-out , First Match , Loose Scan , Materialization 이 있다.
쿼리에 사용된 테이블이나 조인 조건에 따라 옵티마이저는 사용 가능한 전략들을 선택한다.

- 테이블 풀 아웃
Table Pull-out 최적화는 세미 조인의 서브쿼리에 사용된 테이블을 아우터 쿼리로 끄집어낸 후 쿼리를 조인 쿼리로 재작성하는 최적화이다.
이는 서브 쿼리 최적화 도입 전 수동으로 쿼리를 튜닝하던 대표적인 방법이다.

SELECT * FROM table_1 WHERE IN (SELECT * FROM table_2) 와 같은 쿼리의 실행 계획을 보면
두개의 테이블에 대해 id 컬럼 값이 1로 동일하며 Extra 컬럼에는 Using table pullout 과 같은 메세지가 없다.
id 컬럼 값이 같다는 것은 조인되어서 사용됐음을 의미한다.

더 정확히 아는 방법은 EXPLAIN 쿼리를 실행 후 SHOW WARNINGS 명령으로 MySQL 옵티마이저가 재작정한 쿼리를 살펴보는 방법이 있다.
해당 명령으로 실행된 쿼리를 보면 IN (subquery) 형태가 사라지고, JOIN 으로 쿼리가 재작성된 것을 확인할 수 있다.

Table pullout 최적화는 모든 형태의 서브 쿼리에서만 사용할 수 있는 것은 아니며 제한 사항이 있다..
1. 세미 조인 서브 쿼리에서만 사용 가능하다.
2. 서브 쿼리 부분이 UNIQUE 인덱스나 프라이머리 키 룩업으로 결과가 1건인 경우에만 사용 가능하다.

또한 Table pullout 의 특징은 다음과 같다.
1. 해당 최적화가 적용될 때 기존 쿼리에서 사용했던 최적화가 사라지는 것이 아니다.
2. 만약 아우터 조인으로 그집어 낼 수 있다면 서브 쿼리는 사라진다.
3. 최대한 서브쿼리를 조인으로 풀어서 사용하라 라는 튜닝 가이드를 따라하는 역할을 한다. 서브 쿼리를 쓴다해도 못쓰는 건 아니다.

- 퍼스트 매치
IN(subquery) 형태의 세미 조인을 EXISTS(subquery) 형태로 튜닝한 것과 비슷한 방법으로 실행된다.

SELECT * FROM table_1 IN (subquery)

위의 쿼리에 실행계획은 두 테이블의 id는 모두 1이고 Extra 컬럼에는 FirstMatch(e) 문구가 출력된다.
id가 모두 1로 통일 됐다는 것은 서브 쿼리가 아닌 조인으로 처리가 되었고, table_1 테이블의 레코드에 대해 subquery 에서 일치하는 레코드를 1건이라도 찾으면 더이상 subquery 에 있는 테이블을 검색하지 않는다는 것을 의미한다.

실제 의미로는 EXISTS(subquery) 와 동일하게 처리된 것이다.
이는 MySQL 5.5 버전에서 수행됐던 IN-to-EXISTS 변환과 비슷하게 진행된다. 하지만 IN-to-EXISTS 변환에 비해 이 최적화의 장점은 다음과 같다.
1. 여러 테이블이 조인될 때 원래 쿼리에 없던 동등 조건을 옵티마이저가 자동으로 추가한다. 
2. IN-to-EXISTS 변환 최적화는 최적화가 가능하면 무조건 수행을 하지만, FirstMatch 최적화는 일부를 수행하거나 수행하지 않게 설정할 수 있다.

퍼스트 매치 최적화의 제한 사항과 특징은 다음과 같다.
1. 퍼스트 매치 최적화는 GROUP BY나 집합 함수가 사용된 서브쿼리에서는 최적화를 사용할 수 없다.
2. 서브 쿼리가 참조하는 모든 아우터 테이블이 먼저 조회된 이후로 최적화가 진행된다.

- 루스 스캔
루스 스캔은 인덱스를 사용하는 GROUP BY 최적화 방법과 비슷하게 읽기 방식을 사용한다.

SELECT * FROM table_1 WHERE ~~ IN (SELECT ~ FROM table_2)

위와 같은 쿼리가 존재하고 서브 쿼리의 테이블에 수십만 건의 레코드가 있고, 중복을 제거한 데이터가 9건 밖에 없을 때 루스 스캔을 통해서 효율적으로 쿼리를 실행한다.
즉, 서브 쿼리의 테이블이 드라이빙 테이블로 실행되며, table_2 테이블의 프라이머리 키 부분을 유니크하게 한 건씩 읽어서 쿼리를 실행한다.

위와 같이 실행된 쿼리의 실행 계획은 Extra 컬럼에 LooseScan 이라는 문구가 표시된다.
또한 id 컬럼의 값이 모두 1 이며, 이는 조인으로 처리됐음을 보여준다.

루스 인덱스 스캔은 서브쿼리 테이블을 먼저 읽고, 그 이후 아우터 테이블을 드리븐으로 사용한다. 그래서 서브쿼리에 있는 테이블은 루스 인덱스 스캔을 사용할 수 있는 조건이 되어야 한다.

- 구체화 ( Materialization )
구체화는 세미 조인에 사용된 서브쿼리를 통째로 구체화해서 쿼리를 최적화 하는 것을 의미한다.
여기서 구체화는 내부에 임시 테이블을 생성하는 것을 의미한다.

SELECT * FROM table_1 WHERE ~ IN ( SELECT ~ FROM table_2 WHERE ~ )

위의 쿼리에서 FirstMatch 최적화를 수행하면 table_1 은 조건이 서브 쿼리 외에 아무것도 없기 때문에 table_1 을 풀 스캔해야 한다.
옵티마이저는 이러한 형태의 쿼리를 위해 서브 쿼리 구체화라는 최적화를 도입했다.

위의 쿼리의 실행 계획을 보면 총 3개의 라인이 나오며 마지막 라인의 select_type 은 MATERIALIZED 라고 표기된다.
이는 서브 쿼리가 먼저 실행되고 해당 결과로 임시 테이블을 만들고, 해당 임시테이블과 table_1 과 조인을 해서 결과를 반환한다.
# 여기서 구체화가 사용된 경우 임시 테이블이 사용된 것을 알 수 있다.

Materialization 최적화는 다른 최적화와는 달리 서브 쿼리 내에 group by 절이나 집합 함수가 있어도 사용할 수 있다.

# 단 구체화는 IN(subquery) 에서 서브쿼리는 상관 서브쿼리가 아니여야 한다.

- 중복제거
세미 조인 서브쿼리를 일반적인 INNER JOIN 으로 처리하고 마지막에 중복을 제거하는 최적화 방법이다.

SELECT * FROM table_1 WHERE ~ IN ( SELECT t2.~ FROM table_2 WHERE ~ > 15000 );

위의 쿼리에 대해 table_2 테이블에서 중복된 t2.~ 가 발생할 수 있다. 그래서 위의 쿼리를 하단의 쿼리와 같이 INNER JOIN + GROUP BY 절로 바꿔서 실행한다.
# 이는 실제로 중복 제거 최적화가 실행되는 방법을 보여준다.

SELECT * from table_1 , table_2 WHERE ~ AND ~ > 15000 GROUP BY table_2

이렇게 최적화 되면 위의 세미 조인과 같은 결과를 얻는다.

중복 제거 최적화의 처리 과정은 다음과 같다.
1. table_2 테이블의 인덱스를 스캔해서 조건에 맞는 레코드를 조인을 통해 탐색
2. 조인된 결과를 임시 테이블에 저장
3. 임시 테이블에서 특정 컬럼을 기준으로 중복 제거
4. 중복제거하고 남은 레코드를 반환


# 사실 1번과 2번 과정은 반복되서 처리된다. 즉, 조인 후 임시 테이블에 저장하는 과정을 반복한다. 
여기서 실행 계획에서는 Extra 컬럼에 Duplicate Weedout 이라는 문구가 없다.
대신 Start temporary 와 End temporary 라는 문구가 있는데 Start temporary 는 조인을 수행해서 임시 테이블로 저장하는 반복 과정이 실행되는 테이블,
End temporary 는 반복 과정이 끝나는 테이블을 말한다.

중복 제거의 특징은 다음과 같다.
1. 서브쿼리가 상관 쿼리라고 해도 사용할 수 있다.
2. 서브쿼리가 GROUP BY절이나 집합 함수를 사용하면 사용할 수 없다.
3. 서브쿼리의 테이블을 조인으로 처리하기 때문에 최적화할 수 있는 방법이 많다.