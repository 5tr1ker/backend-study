[ 옵티마이저란 ? ]
MySQL 서버를 포함한 RDMS 에서는 옵티마이저를 가지고 있으며, 가장 복잡한 부분을 담당하고 있다.
MySQL 서버에 전달된 쿼리를 가장 빠르고 효율적으로 실행하기 위해  실행 계획을 세운다.
EXPLAIN 이라는 명령을 활용하면 옵티마이저의 실행 계획을 알 수 있고, 불합리한 부분을 찾아내, 더 최적화된 실행 계획을 전달할 수 있다.

물론 실행 계획을 알아야 가능한 부분이다.

- 쿼리의 실행 절차
1. 사용자로 부터 요청된 SQL 문장을 잘개 쪼개서 SQL 서버가 이해할 수 있는 수준으로 분리한다. ( SQL 파스 트리가 만들어진다. )
	ㄴ MySQL 서버의 SQL 파서가 "SQL 파싱"하는 단계이다. 또한 SQL 문법이 잘못되면 이 단계에서 걸러진다. 그리고 SQL 파스 트리 ( 쪼개진 SQL 문장 ) 가 만들어진다. , MySQL 서버는 해당 SQL 파스 트리를 이용해 쿼리를 실행한다.
2. 분리된 SQL 문장을 확인하여 어떤 테이블로부터 읽고 어떤 인덱스를 이용해 테이블을 읽을지 결정한다.
	ㄴ 최적화 및 실행 계획 수립단계이며 옵티마이저가 담당한다. 이 단계가 끝나면 실행 계획이 만들어진다.
3. 2 단계에서 결정된 테이블 읽기 순서나 인덱스를 이용해 스토리지 엔진으로부터 데이터를 가져온다.
	ㄴ 2단계에서 만들어진 실행 계획으로 데이터를 가져와 MySQL 엔진에서 레코드를 조인하거나 정렬한다.


- 옵티마이저의 종류
옵티마이저는 DB서버의 두뇌와 같은 역할을 하며, 현재 대부분의 DBMS에서 사용하는 "비용 기반 최적화 ( CBO )" 방법과 예전 초기 버전의 ORACLE 에서 많이 사용했던 "규칙 기반 최적화 방법 ( RBO )" 로 크게 나눈다.

규칙 기반 최적화 방법은 대상 테이블 레코드의 건수나 선택도를 고려하지 않고 옵티마이저에 내장된 우선순위에 따라 실행 계획을 세운다. ( 항상 같은 실행 계획 ) 하지만 사용자 데이터의 분포도가 다양하기 때문에 거의 사용하지 않는다.
비용 기반 최적화 방법은 쿼리를 처리하기 위한 다양한 방법을 만들고, 각 방법의 처리 비용과 테이블의 통계 정보를 이용해 실행 계획별 비용을 산출한다. 이후 비용이 가장 낮은 방법을 채택해 사용한다.

[ 기본 데이터 처리 ]
MySQL 을 포함한 RDBMS는 쿼리의 결과가 같더라도 실행 계획은 모두 다르다.
여기서 MySQL 서버가 기본적인 가공 ( 정렬이나 그룹화 등. ) 하기 위해 어떤 알고리즘을 사용하는지 보자

- 풀 테이블 스캔과 풀 인덱스 스캔

풀 테이블 스캔은 인덱스를 사용하지 않고 테이블의 데이터를 처음부터 끝까지 읽는 것을 말한다.
MySQL 옵티마이저는 이러한 조건에 풀 테이블 스캔을 활용한다.
1. 레코드가 너무 적어 인덱스를 사용하는 것 보다 풀 테이블 스캔이 더 빠른 경우 ( 테이블이 페이지 1개인 경우 )
2. WHERE 절이나 ON 절에 인덱스를 사용할 수 있는 조건이 없는 경우
3. 인덱스 스캔이 가능하지만 조건 일치 레코드 건수가 너무 많은 경우

풀 테이블 스캔을 하는 경우 많은 디스크 쓰기가 필요하기 때문에 대부분 DBMS에서는 풀 테이블 실행 시 한꺼번에 여러개의 블록이나 페이지를 가져오는 기능을 제공한다.
MyISAM 스토리지 엔진은 디스크로부터 1개의 페이지씩 가져오지만, InnoDB 스토리지 엔진은 특정 테이블의 연속된 데이터 페이지를 읽으면 백그라운드 쓰레드에 의해 리드 어헤드가 자동으로 실행된다.
즉, 초반엔 포그라운드 쓰레드가 읽기 작업을 실행하다가 특정 시점부터는 백그라운드 쓰레드가 읽기 작업을 수행한다.
# 리드 어헤드는 데이터가 사용될 것을 예측해서 백그라운드 쓰레드가 미리 사용될 데이터들을 디스크로 부터 읽어 InnoDB 버퍼 풀에 저장하는 것을 말한다. 이렇게 버퍼 풀에 있는 데이터는 포그라운드 쓰레드가 가져가 활용하여 빠르게 처리된다.
# innodb_read_abead_threshould 시스템 변수를 활용해 몇개의 데이터 페이지가 읽히면 리드 어헤드를 실행시킬지 선택할 수 있다.
	ㄴ 처음 포그라운드 쓰레드가 innodb_read_abead_threshould 에 설정된 값 만큼 읽고 그 이후는 백그라운드 쓰레드가 실행될 것이다.

리드 어헤드는 풀 테이블 스캔에서만 사용되는 것이 아니라 풀 인덱스 스캔에서도 활용될 수 있다.
 
- 병렬 처리
MySQL 8.0 부터 한 쿼리에 대해 병렬 처리가 가능해졌다.
innodb_parallel_read_threads 라는 시스템 변수를 활용해 하나의 쿼리가 최대 몇개의 쓰레드를 이용해 처리할지 설정할 수 있다.
단, MySQL 8.0 에선 조건 없이 단순히 테이블의 전체 건수를 가져오는 쿼리에서만 병렬 처리를 할 수 있다.
# 아직 특정 쿼리에 대해 여러개의 쓰레드로 병렬 처리하게 하는 힌트나 옵션은 없다.

- Order by 처리
쿼리에서 정렬을 처리하는 방법은 인덱스를 이용하거나 Filesort 라는 방법으로 나뉠 수 있다.

인덱스는 이미 정렬되어 있기 때문에 조회가 빠르지만, 수정과 삭제 시 인덱스 작업이 필요하여 느리며 더 많은 디스크 공간이 필요하다.
Filesort의 경우 정렬해야 할 레코드가 적으면 메모리에서 실행되기 때문에 속도는 빠르지만, 정렬 작업이 쿼리 실행 시점에 시작되므로 처리 건수가 많아질 경우 성능이 떨어진다.

인덱스를 이용해 정렬하는 방법은 항상 가능하진 않다.
예를 들면 정렬 기준이 너무 많아 요건별로 인덱스를 생성할 수 없거나, GROUP BY 또는 DISTINCT 의 결과를 정렬해야 하거나, UNION 을 통해 병합한 결과를 정렬하거나,
랜덤하게 결과 레코드를 가져와야 하는 경우는 사용하지 못한다.

그래서 MySQL 서버에서 어떤 기준으로 정렬을 했는지 확인할 때 실행 계획의 Extra 컬럼에 Using filesort 여부를 통해 판단할 수 있다.

- 소트 버퍼
MySQL 서버에서 정렬을 수행하기 위해 별도의 메모리 공간을 할당받아서 사용하는데, 이 공간을 소트 버퍼라고 한다.
소트 버퍼는 정렬이 필요한 경우에 할당되며, 정렬 대상 레코드의 건수에 따라 유동적인 크기를 갖는다. 최대 사용한 크기는 sort_buffer_size 라는 시스템 변수를 통해 조절가능하며, 정렬이 완료되었을 경우 시스템에 즉시 반납한다.

만약 정렬해야 할 레코드가 소트 버퍼의 크기를 초과하면 레코드를 여러 조각으로 나눠서 처리하는데, 이떄 임시 저장을 위해 디스크를 사용한다.
이때 메모리에서 정렬을 수행해서 디스크에 저장하고, 다시 정렬된 레코드를 가져와서 다시 정렬하는 과정을 multi-merge 라고 하며 멀티 머지된 횟수는 시스템 변수인 sort_merge_passes 에 저장된다.
해당 작업들은 디스크의 쓰기와 읽기를 유발하며, 레코드의 건수가 많아질수록 성능이 떨어진다.

만약 멀티 머지 횟수를 줄이고자 더 큰 소트 버퍼 ( sort_buffer_size ) 를 할당하는 방법이 있겠지만, 소트 버퍼를 크게 잡는다 하더라도 성능이 눈에띄게 빨라지진 않는다. ( 오히려 느려질수도 있다. )
# 일반적인 트랜잭션 처리용일 경우 56kb ~ 1mb 으로 잡는게 좋다.
MySQL 서버는 글로벌 메모리 영역과 세션 메모리 영역으로 나뉘는데, 소트 버퍼는 세션 ( 로컬 ) 메모리 영역에 해당된다. 즉, 소트 버퍼는 여러 클라이언트가 공유하지 않기 때문에 정렬 작업이 많을 수록 소트 버퍼로 소비되는 메모리 공간이 커지게 된다.
이는 운영체제가 메모리 부족 현상을 겪을수도 있다. 이때 메모리 여유 공간이 없을 경우 운영체제의 OOM-Killer 가 여유 메모리 공간을 확보하기 위해 MYSQL 서버를 종료할 수 있다.
# OOM-Killer 는 메모리를 가장 많이 사용하는 프로세스를 가장 먼저 제거하기 때문에 MySQL 서버가 1순위가 된다.
# 다만 소트 버퍼의 크기가 늘리면 디스크 I/O가 덜 발생하기 때문에 성능상의 이점이 있다. ( 디스크 I/O 가 느리거나 데이터가 많을 경우.. ) 만약 대량의 데이터 정렬이 필요할 경우 해당 세션의 소트 버퍼만 일시적으로 늘리는 방법도 있다.
