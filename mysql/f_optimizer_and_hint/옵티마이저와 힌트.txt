[ 옵티마이저란 ? ]
MySQL 서버를 포함한 RDMS 에서는 옵티마이저를 가지고 있으며, 가장 복잡한 부분을 담당하고 있다.
MySQL 서버에 전달된 쿼리를 가장 빠르고 효율적으로 실행하기 위해  실행 계획을 세운다.
EXPLAIN 이라는 명령을 활용하면 옵티마이저의 실행 계획을 알 수 있고, 불합리한 부분을 찾아내, 더 최적화된 실행 계획을 전달할 수 있다.

물론 실행 계획을 알아야 가능한 부분이다.

- 쿼리의 실행 절차
1. 사용자로 부터 요청된 SQL 문장을 잘개 쪼개서 SQL 서버가 이해할 수 있는 수준으로 분리한다. ( SQL 파스 트리가 만들어진다. )
	ㄴ MySQL 서버의 SQL 파서가 "SQL 파싱"하는 단계이다. 또한 SQL 문법이 잘못되면 이 단계에서 걸러진다. 그리고 SQL 파스 트리 ( 쪼개진 SQL 문장 ) 가 만들어진다. , MySQL 서버는 해당 SQL 파스 트리를 이용해 쿼리를 실행한다.
2. 분리된 SQL 문장을 확인하여 어떤 테이블로부터 읽고 어떤 인덱스를 이용해 테이블을 읽을지 결정한다.
	ㄴ 최적화 및 실행 계획 수립단계이며 옵티마이저가 담당한다. 이 단계가 끝나면 실행 계획이 만들어진다.
3. 2 단계에서 결정된 테이블 읽기 순서나 인덱스를 이용해 스토리지 엔진으로부터 데이터를 가져온다.
	ㄴ 2단계에서 만들어진 실행 계획으로 데이터를 가져와 MySQL 엔진에서 레코드를 조인하거나 정렬한다.


- 옵티마이저의 종류
옵티마이저는 DB서버의 두뇌와 같은 역할을 하며, 현재 대부분의 DBMS에서 사용하는 "비용 기반 최적화 ( CBO )" 방법과 예전 초기 버전의 ORACLE 에서 많이 사용했던 "규칙 기반 최적화 방법 ( RBO )" 로 크게 나눈다.

규칙 기반 최적화 방법은 대상 테이블 레코드의 건수나 선택도를 고려하지 않고 옵티마이저에 내장된 우선순위에 따라 실행 계획을 세운다. ( 항상 같은 실행 계획 ) 하지만 사용자 데이터의 분포도가 다양하기 때문에 거의 사용하지 않는다.
비용 기반 최적화 방법은 쿼리를 처리하기 위한 다양한 방법을 만들고, 각 방법의 처리 비용과 테이블의 통계 정보를 이용해 실행 계획별 비용을 산출한다. 이후 비용이 가장 낮은 방법을 채택해 사용한다.

[ 기본 데이터 처리 ]
MySQL 을 포함한 RDBMS는 쿼리의 결과가 같더라도 실행 계획은 모두 다르다.
여기서 MySQL 서버가 기본적인 가공 ( 정렬이나 그룹화 등. ) 하기 위해 어떤 알고리즘을 사용하는지 보자

- 풀 테이블 스캔과 풀 인덱스 스캔

풀 테이블 스캔은 인덱스를 사용하지 않고 테이블의 데이터를 처음부터 끝까지 읽는 것을 말한다.
MySQL 옵티마이저는 이러한 조건에 풀 테이블 스캔을 활용한다.
1. 레코드가 너무 적어 인덱스를 사용하는 것 보다 풀 테이블 스캔이 더 빠른 경우 ( 테이블이 페이지 1개인 경우 )
2. WHERE 절이나 ON 절에 인덱스를 사용할 수 있는 조건이 없는 경우
3. 인덱스 스캔이 가능하지만 조건 일치 레코드 건수가 너무 많은 경우

풀 테이블 스캔을 하는 경우 많은 디스크 쓰기가 필요하기 때문에 대부분 DBMS에서는 풀 테이블 실행 시 한꺼번에 여러개의 블록이나 페이지를 가져오는 기능을 제공한다.
MyISAM 스토리지 엔진은 디스크로부터 1개의 페이지씩 가져오지만, InnoDB 스토리지 엔진은 특정 테이블의 연속된 데이터 페이지를 읽으면 백그라운드 쓰레드에 의해 리드 어헤드가 자동으로 실행된다.
즉, 초반엔 포그라운드 쓰레드가 읽기 작업을 실행하다가 특정 시점부터는 백그라운드 쓰레드가 읽기 작업을 수행한다.
# 리드 어헤드는 데이터가 사용될 것을 예측해서 백그라운드 쓰레드가 미리 사용될 데이터들을 디스크로 부터 읽어 InnoDB 버퍼 풀에 저장하는 것을 말한다. 이렇게 버퍼 풀에 있는 데이터는 포그라운드 쓰레드가 가져가 활용하여 빠르게 처리된다.
# innodb_read_abead_threshould 시스템 변수를 활용해 몇개의 데이터 페이지가 읽히면 리드 어헤드를 실행시킬지 선택할 수 있다.
	ㄴ 처음 포그라운드 쓰레드가 innodb_read_abead_threshould 에 설정된 값 만큼 읽고 그 이후는 백그라운드 쓰레드가 실행될 것이다.

리드 어헤드는 풀 테이블 스캔에서만 사용되는 것이 아니라 풀 인덱스 스캔에서도 활용될 수 있다.
 
- 병렬 처리
MySQL 8.0 부터 한 쿼리에 대해 병렬 처리가 가능해졌다.
innodb_parallel_read_threads 라는 시스템 변수를 활용해 하나의 쿼리가 최대 몇개의 쓰레드를 이용해 처리할지 설정할 수 있다.
단, MySQL 8.0 에선 조건 없이 단순히 테이블의 전체 건수를 가져오는 쿼리에서만 병렬 처리를 할 수 있다.
# 아직 특정 쿼리에 대해 여러개의 쓰레드로 병렬 처리하게 하는 힌트나 옵션은 없다.

- Order by 처리
쿼리에서 정렬을 처리하는 방법은 인덱스를 이용하거나 Filesort 라는 방법으로 나뉠 수 있다.

인덱스는 이미 정렬되어 있기 때문에 조회가 빠르지만, 수정과 삭제 시 인덱스 작업이 필요하여 느리며 더 많은 디스크 공간이 필요하다.
Filesort의 경우 정렬해야 할 레코드가 적으면 메모리에서 실행되기 때문에 속도는 빠르지만, 정렬 작업이 쿼리 실행 시점에 시작되므로 처리 건수가 많아질 경우 성능이 떨어진다.

인덱스를 이용해 정렬하는 방법은 항상 가능하진 않다.
예를 들면 정렬 기준이 너무 많아 요건별로 인덱스를 생성할 수 없거나, GROUP BY 또는 DISTINCT 의 결과를 정렬해야 하거나, UNION 을 통해 병합한 결과를 정렬하거나,
랜덤하게 결과 레코드를 가져와야 하는 경우는 사용하지 못한다.

그래서 MySQL 서버에서 어떤 기준으로 정렬을 했는지 확인할 때 실행 계획의 Extra 컬럼에 Using filesort 여부를 통해 판단할 수 있다.

- 소트 버퍼
MySQL 서버에서 정렬을 수행하기 위해 별도의 메모리 공간을 할당받아서 사용하는데, 이 공간을 소트 버퍼라고 한다.
소트 버퍼는 정렬이 필요한 경우에 할당되며, 정렬 대상 레코드의 건수에 따라 유동적인 크기를 갖는다. 최대 사용한 크기는 sort_buffer_size 라는 시스템 변수를 통해 조절가능하며, 정렬이 완료되었을 경우 시스템에 즉시 반납한다.

만약 정렬해야 할 레코드가 소트 버퍼의 크기를 초과하면 레코드를 여러 조각으로 나눠서 처리하는데, 이떄 임시 저장을 위해 디스크를 사용한다.
이때 메모리에서 정렬을 수행해서 디스크에 저장하고, 다시 정렬된 레코드를 가져와서 다시 정렬하는 과정을 multi-merge 라고 하며 멀티 머지된 횟수는 시스템 변수인 sort_merge_passes 에 저장된다.
해당 작업들은 디스크의 쓰기와 읽기를 유발하며, 레코드의 건수가 많아질수록 성능이 떨어진다.

만약 멀티 머지 횟수를 줄이고자 더 큰 소트 버퍼 ( sort_buffer_size ) 를 할당하는 방법이 있겠지만, 소트 버퍼를 크게 잡는다 하더라도 성능이 눈에띄게 빨라지진 않는다. ( 오히려 느려질수도 있다. )
# 일반적인 트랜잭션 처리용일 경우 56kb ~ 1mb 으로 잡는게 좋다.
MySQL 서버는 글로벌 메모리 영역과 세션 메모리 영역으로 나뉘는데, 소트 버퍼는 세션 ( 로컬 ) 메모리 영역에 해당된다. 즉, 소트 버퍼는 여러 클라이언트가 공유하지 않기 때문에 정렬 작업이 많을 수록 소트 버퍼로 소비되는 메모리 공간이 커지게 된다.
이는 운영체제가 메모리 부족 현상을 겪을수도 있다. 이때 메모리 여유 공간이 없을 경우 운영체제의 OOM-Killer 가 여유 메모리 공간을 확보하기 위해 MYSQL 서버를 종료할 수 있다.
# OOM-Killer 는 메모리를 가장 많이 사용하는 프로세스를 가장 먼저 제거하기 때문에 MySQL 서버가 1순위가 된다.
# 다만 소트 버퍼의 크기가 늘리면 디스크 I/O가 덜 발생하기 때문에 성능상의 이점이 있다. ( 디스크 I/O 가 느리거나 데이터가 많을 경우.. ) 만약 대량의 데이터 정렬이 필요할 경우 해당 세션의 소트 버퍼만 일시적으로 늘리는 방법도 있다.

- 정렬 알고리즘
레코드를 정렬할 때 소트 버퍼에 레코드 전체를 담을지, 혹은 정렬 기준 컬럼만 담을지에 따라 "싱글 패스"와 "투 패스" 2가지 옵션을 제공한다.
쿼리가 어떤 정렬 모드를 사용했는지는 옵티마이저 트레이스 기능으로 확인할 수 있다.

출력된 내용 중 sort_mode 필드에는 정렬 방식을 나타내며 MySQL 서버에서 정렬 방식은 다음과 같다.
1. <sort_key, rowid> : 정렬 키와 레코드의 로우 아이디만 가져와 정렬하는 방식
2. <sort_key, additional_fields> : 정렬 키와 레코드 전체를 가져와 정렬하는 방식으로, 레코드의 컬럼들은 고정된 사이즈로 메모리에 저장한다.
3. <sort_key, packed_additional_fields> : 정렬 키와 레코드 전체를 가져와 저장하는 방식으로, 레코드의 각 컬럼은 가변 사이즈로 메모리에 저장한다.

여기서 첫번째 방식을 투 패스, 두 번째와 세 번째 방식을 싱글 패스라고 한다.

- 싱글 패스 정렬 방식

소트 버퍼에 정렬 기준이 되는 컬럼을 포함해 SELECT 되는 컬럼 전부 담아서 정렬을 수행하는 정렬 방식이다.
즉, 테이블을 읽으면 정렬 기준과 SELECT 대상의 컬럼을 읽어서 소트 버퍼에서 정렬을 수행하고 해당 결과를 사용자에게 넘겨주는 방식으로 진행된다.

- 투 패스 정렬 방식
싱글 패스 정렬 방식이 나오기 전에 활용되던 방식으로 정렬 대상 컬럼과 프라이머리 키만 먼저 조회하여 소트 버퍼에서 정렬을 수행하고, 정렬된 순서대로 프라이머리 키를 활용해
레코드를 다시 읽어 SELECT 할 컬럼을 가져오는 방식이다.
# 물론 MySQL 8.0 에서는 특정 조건에서 투 패스 정렬 방식을 사용한다.

이는 테이블을 두번 읽어야 하는 불합리함이 있다. 다만 소트 버퍼의 크기를 싱글 패스 방식보다 덜 활용한다는 특징이 있다.
MySQL 서버가 최신 버전일 경우 일반적으로 싱글 패스 정렬 방식을 주로 사용한다. 하지만 항상 싱글 패스 정렬 방식을 사용하는 경우는 아니며 하단의 조건에 맞을 경우 투 패스 정렬 방식을 활용한다.
1. 레코드의 크기가 max_length_for_sort_data 시스템 변수에 설정된 값 보다 클 때
2. SELECT 대상의 컬럼이 BLOB 이나 TEXT 타입일 때

싱글 패스 정렬 방식은 정렬 대상의 레코드가 적거나 크키가 작을 때 유용하며, 투 패스 정렬 방식은 정렬 대상의 레코드의 크기가 크거나 건수가 많을 때 효율적이다.
# 위와 같은 이유로 정렬 버퍼의 효율성을 위해 SELECT 시에 필요한 컬럼만 조회하도록 조회하는 것이 좋다. ( 정렬이 필요한 SELECT의 경우 포함 )
# 이는 정렬 버퍼에만 영향을 미치는 것이 아닌 임시 테이블에도 영향을 미친다.

- 정렬 처리 방법
쿼리에서 ORDER BY 가 적용되면 반드시 다음의 3가지 처리 방법 중 하나로 정렬된다. 일반적으로 하단으로 갈 수록 성능이 떨어진다.
정렬 처리 방법 : 실행 계획의 Extra 컬럼 내용
인덱스를 이용한 정렬 : 없음
조인에서 드라이빙 테이블만 정렬 : Using filesort
조인에서 조인 결과를 임시 테이블로 저장 후 정렬 : Using temporary; Using filesort

먼저 옵티마이저는 정렬 처리를 위해 인덱스를 사용할 수 있는지 검토를 하고 사용할 수 있다면 Filesort 과정 없이 인덱스를 순서대로 읽어 처리한다.
하지만 인덱스를 사용할 수 없다면 조건에 일치하는 레코드를 검색해 정렬 버퍼에 저장하면서 정렬을 처리할 것이다. ( Filesort )
이떄 옵티마이저는 정렬 대상 레코드를 줄이기 위해 2가지 방법 중 하나를 선택한다.
1. 조인의 드라이빙 테이블만 정렬한 다음 조인
2. 조인이 끝나고 일치하는 레코드를 대상으로 정렬

보통 조인이 수행되면서 레코드의 건수와 레코드의 크기는 더욱 늘어나기 떄문에 가능하다면 드라이빙 테이블만 정렬한 다음 조인을 수행하는 것이 효과적이다.

- 인덱스를 이용한 정렬
인덱스를 이용한 정렬을 위해서 ORDER BY에 사용된 컬럼이 가장 먼저 조회된 테이블 ( 드라이빙 테이블 ) 에 속해야 하고, 순서대로 생성된 인덱스가 있어야 한다.
또한 WHERE 절에 사용된 컬럼이 있을 경우 ORDER BY 와 같은 인덱스를 사용할 수 있어야 한다.
B-Tree 계열에서만 사용할 수 있으며, 여러 테이블이 조인되는 경우 Nested-loop 방식의 조인에서만 사용할 수 있다.

다만 인덱스는 이미 정렬된 상태를 유지하기 때문에 ORDER BY 에 사용된 컬럼이 이미 정렬된 인덱스라면 정렬을 위한 추가 작업을 하지 않는다.
또한 정렬이 수행될 때 정렬된 드라이빙 테이블에서 순서대로 조인해서 데이터를 가져오기 때문에 ( Nested-loop ) 방식 별도의 추가 정렬 작업은 수행하지 않는다.
하지만 조인의 쿼리 실행 계획이 조인 버퍼라면 순서가 바뀔 수 있으므로 조심해야 한다.

- 조인의 드라이빙 테이블만 정렬
일반적으로 조인이 수행되면 결과 레코드의 건수가 늘어나고, 레코드의 크기도 늘어난다. 그래서 조인을 수행하기 전 첫 번째 테이블 ( 드라이빙 테이블 ) 의 레코드를 먼저 정렬하고
다음 조인을 수행하는 것이 좋다. 이때 해당 방법을 활용하기 위해서 드라이빙 테이블의 컬럼만으로 ORDER BY 를 작성해야 한다.
그러면 해당 컬럼이 인덱스가 아니더라도 드라이빙 테이블만 조회해서 정렬을 먼저 수행하고 이후 조인을 수행한다.

- 임시테이블을 이용한 정렬
2개 이상의 테이블을 조인해서 그 결과를 정렬하려면 임시테이블이 필요할 수 있다. ( 1개는 불 필요 )
이 패턴은 조인의 결과를 임시 테이블에 저장하고 결과를 다시 정렬한다. 그렇기 때문에 정렬해야 할 레코드가 많기 때문에 위의 3가지 방법 중 가장 느리다.

"조인의 드라이빙 테이블만 정렬" 방식에서 드라이빙 테이블의 컬럼으로 ORDER BY 를 구성하는 게 아닌 드리븐 테이블의 컬럼으로 구성할 경우, 정렬이 수행되기 전에 2개의 테이블을 읽고 정렬을 수행해야 한다.
즉, 조인된 결과를 가지고 정렬을 수행해야 한다. 