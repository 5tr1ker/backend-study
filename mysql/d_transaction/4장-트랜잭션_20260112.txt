[ 트랜잭션 ]
트랜잭션은 작업의 완전성을 보장해주는 것이다.
즉, 작업 셋을 모두 완벽하게 처리하거나, 처리하지 못할 경우 원 상태로 복구하여 작업의 일부만 적용되는 현상을 막아준다.
스토리지 엔진 중 MyISAM 과 MEMORY는 트랜잭션을 지원하지않으며, InnoDB는 트랜잭션을 제공한다.

- 잠금과 트랜잭션
잠금은 동시성을 제어하기 위한 기능이고, 트랜잭션은 데이터의 정합성을 보장하기 위한 기능이다.
잠금은 여러 커넥션이 하나의 자원에 접근하려 할 때, 한번에 하나의 커넥션만 접근할 수 있게 제어를 한다.

- MySQL 에서의 트랜잭션
트랜잭션은 하나의 작업의 셋에 몇개의 쿼리가 존재하든 전체가 적용되거나 모두 적용되지 않아야 한다.

CREATE TABLE tab_myisam(fdpk int not null, primary key (fdpk) ) engine=MyISAM;
INSERT INTO tab_myisam values (3);
CREATE TABLE tab_innodb(fdpk int not null, primary key (fdpk) ) engine=innoDB;
INSERT INTO tab_innodb values (3);

INSERT INTO tab_myisam values (1),(2),(3),(4),(5);
INSERT INTO tab_innodb values (1),(2),(3),(4),(5);

위의 쿼리를 실행하면 모든 테이블이 키 중복 ( 3 ) 으로 인해 오류가 발생하지만, MyISAM 같은 경우 실패 전 1,2가 저장이 된다. ( 4 , 5 는 저장되지 않았음 )
	ㄴ 이러한 현상을 부분 업데이트라고 하며 테이블 데이터의 정합성을 맞추는데 어려움을 준다.
	ㄴ 부분 업데이트 현상으로 발생한 실패한 데이터들을 다시 제거해야 하는 작업을 해야할 수도 있다. 데이터의 양이 작으면 쉽겠지만, 양이 많아지면 보통일이 아닐것이다. 물론 해당 작업도 잘못될 경우
	테이블에 쓰레드 데이터가 남을 수 있다.
	
반대로 innodb 는 트랜잭션의 원칙으로 INSERT 가 실행되기 전으로 복구된다.

- 주의사항
트랜잭션은 꼭 필요한 최소의 코드에만 적용하는 것이 좋다. 즉, 프로그램의 트랜잭션의 범위를 최소화해야한다.
데이터베이스 커넥션을 생성하고 트랜잭션을 사용하는 범위가 넓어질수록, 커넥션 풀 내에 있는 커넥션을 사용할 수 있는 개수가 줄어들 것이고 다른 작업에서 커넥션을 기다려야 하는 상황이 발생한다.
또한 외부 시스템와 연동하는 부분이 있을 경우 트랜잭션 내에서 제거하는 것이 좋다.

읽기 작업의 경우 트랜잭션이 필요하지 않기 때문에 분리하고, 네트워크 작업이 있는 경우 분리해야 한다.
즉, 프로그램 코드에서 데이터베이스의 커넥션을 가지고 있는 범위와 트랜잭션이 활성화 되는 범위를 줄여야 한다.

[ MySQL 엔진의 잠금 ]
MySQL 에서 사용되는 잠금은 스토리지 엔진 레벨과 MySQL 엔진 레벨로 나눌 수 있다.
MySQL 엔진 레벨의 잠금은 스토리지 엔진에 영향을 미치지만, 스토리지 엔진 레벨의 잠금은 스토리지 엔진간에만 영향을 미친다. 

- 글로벌 락
글로벌 락은 FLUSH TABLES WITH READ LOCK 명령으로 얻을 수 있으며 MySQL 에서 제공하는 잠금 중 가장 크다.
이 락은 MySQL 서버 전체에 영향을 미치며 테이블이나 데이터베이스가 다르더라도 영향을 받는다.

글로벌 락이 실행되면 ( 한 세션이 락을 획득하면 ) 다른 세션들은 SELECT 를 제외한 대부분의 DDL 이나 DML 문장이 대기 상태가 된다.


# 글로벌 락은 서로 다른 데이터베이스에 존재하는 테이블에 대해 백업을 해야 할 때 사용된다.
# 글로벌 락은 전체 MySQL 서버에 영향을 미치기 때문에 웹 서비스 환경에서는 사용하지 않는 것이 좋다.

- 테이블 락
테이블 락은 특정 테이블 단위로 설정되는 잠금으로, 명시적 또는 묵시적으로 특정 테이블의 락을 획득할 수 있다.
명시적으로는 LOCK TABLES table_name [ READ || WRITE ] 명령으로 획득할 수 있다.
명시적으로 설정한 LOCK 은 UNLOCK TABLES 로 풀 수 있다.
다만, 테이블 락도 특별한 상황이 아니면 사용할 일이 없다. 이는 온라인 작업에 영향을 많이 미치기 때문이다.

묵시적인 경우에는 MyISAM 과 MEMORY 테이블은 데이터가 변경되는 작업에 대해 자동으로 MySQL 서버에서 락을 건다.
InnoDB 테이블의 경우 스토리지 엔진에서 레코드 잠금을 제공하기 떄문에 단순 테이블 잠금은 설정되진 않는다. 단 DDL 과 같은 스키마 변경에서는 설정된다.

- 네임드 락
네임드 락은 임의의 문자열에 대해 잠금을 설정할 수 있다.
사용자가 지정한 문자열에 대해 락을 획득하고 반환한다.

SELECT GET_LOCK('mylock', 20000);
select IS_FREE_LOCK('mylock');
select RELEASE_LOCK('mylock');

- 메타데이터 락
메타데이터 락은 데이터베이스의 객체 ( 뷰, 테이블 등 ) 의 이름이나 구조를 변경할 때 사용하는 잠금이다.
메타데이터 락은 묵시적으로만 가져올 수 있는데 RENAME TABLE 과 같이 테이블의 이름을 변경하고자 할 때 잠금을 획득하고 반납한다.

# MySQL 서버의 DDL은 단일 쓰레드로 동작한다.

[ InnoDB 스토리지 엔진 잠금 ]
InnoDB 스토리지 엔진은 MySQL 에서 제공하는 잠금 외에 스토리지 엔진 내에서 레코드 기반의 잠금 방식을 제공한다.
그렇기 떄문에 MyISAM 보다 더 뛰어난 동시성 처리를 제공한다.

InnoDB 스토리지 엔진은 다른 DBMS와는 다르게 레코드와 레코드 사이의 갭을 잠그는 갭 락 이라는게 있다.

- 레코드 락
InnoDB는 레코드를 잠그는 기능을 가지고 있다. 이는 다른 상용 DBMS의 레코드 락과 동일한 역할을 하지만 InnoDB는 인덱스의 레코드를 잠근다.
	ㄴ 인덱스가 없을 경우 자동 생성된 클러스터 인덱스를 이용해 잠근다.
	ㄴ 다른 상용 DBMS는 레코드 자체를 잠근다.

- 갭 락
레코드 자체가 아니라 레코드 사이에 있는 간격인 갭을 잠그는 것을 말한다.
갭 락은 레코드와 레코드 사이의 간격에 새로운 레코드가 생성되는 것을 제어한다.

- 넥스트 키 락
레코드락과 갭 락을 합쳐놓은 형태를 말한다.

- 자동 증가 락
MySQL에서 자동 증가하는 숫자 값을 추출하기 위해 AUTO_INCREMENT 라는 속성을 활용한다.
MySQL 5.0 버전 이전에서는 innoDB에서는 내부적으로 AUTO_INCREMENT 락이라고 하는 테이블 수준에서의 락을 활용한다.
이때 INSERT문이나 REPLACE 문으로 AUTO_INCREMENT 값을 가져올 때 락이 걸렸다가 해제된다. 해당 락은 단 하나만 존재하기 때문에 두개의 INSERT 문이 동시에 실행될 경우 하나의 요청은 기다려야 한다.
AUTO_INCREMENT락은 명시적으로 획득하는 방법은 없다.

MySQL 5.1 버전 이후로는 innodb_autoinc_lock_mode 라는 변수를 활용해 자동 증가 락의 작동 방식을 조정할 수 있다.
값이 0 일 경우 5.0 버전의 방식이 , 5.7일 경우 기본 값이 1 , 8.0 부터는 기본 값이 2 이다.

- 인덱스와 잠금
innoDB의 경우 인덱스와 잠금은 서로 연관성이 깊은데 innoDB에서 레코드 락은 레코드를 잠그는 것이 아니라 인덱스를 잠그는 방식으로 처리된다.
즉, 변경해야 할 레코드를 찾기위해 검색된 인덱스의 레코드가 전부 락이 걸린다.
	ㄴ 예를 들어 1개의 데이터를 찾기 위해 사용된 인덱스에 500건의 데이터가 있을 경우 500개의 데이터는 모두 잠겨버린다.
	ㄴ 따라서 UPDATE를 위한 적절한 인덱스가 준비되어 있지 않다면, 동시성이 떨어지게 될 것이다.
	
만약 인덱스가 하나도 없다면 ㄷ테이블을 풀 스캔하면서 UPDATE 작업을 수행하는데 그러면 모든 레코드를 잠그게 된다.

- 레코드 수준의 잠금 확인 및 해제
innoDB 스토리지 엔진에서 레코드 수준의 잠금은 문제가 잘 발견되지 않는다.
해당 레코드가 잘 사용되지 않는다면 오랫동안 잠겨있을 경우에도 발견하기가 어렵다. 이전 버전에서는 레코드 잠금에 대한 정보도 없었기 때문에 더 어려운 부분이 있다.
강제로 잠금을 해제하려면 KILL 명령을 이용해 MySQL 서버의 프로세스를 강제로 제거하면 된다.
ex ) mysql> KILL 17;


잠금 대기 순서를 확인 하려면 performance_schema에 data_locks 테이블과 data_lock_waits 테이블을 조인해서 확인하면 된다.
만약 특정 쓰레드가 어떤 잠금을 가지고 있는지 확인하려면 performance_schema 의 data_locks 테이블을 확인하면 된다.

[ MySQL 격리 수준 ]
트랜잭션 격리 수준은 한 트랜잭션이 다른 트랜잭션에서 데이터를 변경하거나 조회하는 데이터를 조회할 수 있게 할지 말지를 선택하는 것이다.
격리 수준은 READ UNCOMMITTED , READ COMMITTED , REPEATABLE READ , SERIALIZABLE 4가지로 나뉜다.
왼쪽에서 뒤로갈 수록 트랜잭션 간 데이터 격리는 높아지며 동시 처리 성능도 떨어진다.
READ UNCOMMITTED 과 SERIALIZABLE 는 잘 사용하지 않는다.

데이터베이스 격리 수준에는 항상 3가지의 부정합 문제점이 발생한다. ( DIRTY READ , NON-REPEATABLE READ , PHANTOM READ )
이 부정합은 격리 수준의 레벨에 따라 발생할 수 있고 발생하지 않을 수 있다.

일반적으로 READ COMMITTED 와 REPEATABLE READ 를 많이 사용하며, MySQL 에서는 REPEATABLE READ 가 기본값으로 되어 있다.

- READ UNCOMMITTED
해당 격리 수준은 한 트랜잭션이 데이터를 커밋되기도 전에 조회할 수 있는 수준이다.
이는 알 수 없는 문제로 데이터가 롤백이 되었을 때, 롤백되기 전 데이터를 읽고 처리하는 문제가 발생할 수 있다.

이때 처리되지 않은 데이터를 조회할 수 있는 현상인 DIRTY READ가 발생하며, 해당 현상은 데이터가 나타났다가 사라지는 현상이 발생한다.

- READ COMMITTED
커밋된 읽기는 오라클 DBMS 에서 기본으로 적용되며, 온라인 서비스에서 많이 사용된다.
커밋된 읽기는 변경된 데이터가 COMMIT이 되어야 다른 트랜잭션에서 조회할 수 있다. 그렇기 때문에 DIRTY READ는 발생하지 않는다.

즉, 한 트랜잭션이 UPDATE를 했다 하더라도 COMMIT되기 전이라면 변경되기 전의 데이터가 조회되며 COMMIT이 완료되어야 변경된 내용의 데이터를 조회할 수 있게된다.

다만 한 트랜잭션이 같은 쿼리를 2번 실행했을 때 실행 결과가 다른 NON-REPEATABLE READ 가 발생할 수 있다.
이는 다른 트랜잭션이 UPDATE 를 통해 데이터를 수정하거나 데이터가 추가되었을 경우 해당 문제가 발생하며, 해당 문제로 인해 한 트랜잭션 내에서 항상 같은 결과를 얻어야 하는 REPEATABLE READ 정합성에 어긋난다.

해당 격리 수준 까지는 트랜잭션 내에 실행되는 SELECT 와 트랜잭션 없이 실행되는 SELECT 와는 차이가 별로 없다.
하지만 REPEATABLE READ 격리 수준에서는 SELECT 쿼리도 트랜잭션 내에서 작동한다. ( 즉, 트랜잭션을 시작한 상태에서 같은 쿼리를 실행할 경우 같은 결과를 얻게 된다. )

- REPEATABLE READ
반복 가능한 읽기는 MySQL에서 InnoDB 스토리지 엔진이 기본으로 사용하는 격리 수준이다.
해당 격리 수준에서는 NON-REPEATABLE READ 부정합이 발생하지 않는다.

REPEATABLE READ 는 데이터가 변경될 경우 변경된 데이터를 언두 공간에 백업해두고 실제 레코드를 변경한다.
이를 통해 한 트랜잭션 내 동일한 쿼리를 발생시켰을 경우 항상 동일한 결과를 반환한다.

하지만 해당 격리 수준에서도 새로운 데이터가 생겼다가 사라졌다가 하는 PHANTOM READ 가 발생한다.
	ㄴ 이는 다른 트랜잭션에서 데이터를 INSERT 할 경우 없었던 데이터가 생기는 현상을 말한다.
해당 현상은 SELECT 하는 레코드에 쓰기 잠금을 걸어야 하는데 언두 레코드에는 잠금을 걸 수 없다. 그래서 SELECT 에서 조회되는 데이터는 언두 영역이 아닌 현재 레코드에서 값을 가져와서 발생한다.


- SERIALIZABLE
격리 수준이 가장 높은 단계이며 다른 트랜잭션보다 동시 처리 수준이 떨어진다.
이는 쓰는 작업 뿐만 아니라 읽기 작업도 공유 잠금을 획득해야한다. 즉, 읽고 쓰는 트랜잭션이 존재하면 다른 트랜잭션은 절대 접근할 수 없다.
그렇기 떄문에 PHANTOM READ 불정합이 발생하진 않는다.

# InnoDB 테이블에서는 순수한 SELECT 작업에 대해 어떤 레코드도 잠금을 하지 않고 조회한다. ( Non-locking consistent read )
# InnoDB는 스토리지 엔진에서 갭 락과 넥스트 키 락을 제공하기 때문에 REPEATABLE READ 격리 수준에서도 PHANTOM READ 가 발생하지 않는다. 그렇기 때문에 굳이 SERIALIZABLE 을 사용할 필요가 없다.
