[ ref 칼럼 ]
접근 방법이 ref일 경우 참조 조건으로 어떤 값이 제공됐는지 보여준다.
상수 값일 경우 const로 표시되고, 다른 테이블의 칼럼이면 테이블.칼럼 으로 표기된다.

이때 func 일 경우 ( function ) 참조용으로 사용되는 값이 그대로 사용된 것이 아닌 콜레이션 변환이나 연산을 거쳐 사용됐다는 것을 의미한다.

SELECT * FROM table_1 t1 , table_2 t2 WHERE t1.key = ( t2.key + 1 )
위의 쿼리와 같이 참조 조건의 값을 변환해서 사용할 때 ref 칼럼의 값이 func가 된다.

다만 사용자가 명시적으로 변환하는 것이 아닌 MySQL 서버가 내부적으로 값을 변환할 떄에도 ref 칼럼이 func가 될 수 있다.
이는 문자타입일 일치하지 않거나, 숫자 타입과 문자 타입의 칼럼을 조인할 때에 해당된다.

[ rows 칼럼 ]
rows 컬럼은 실행 계획의 효율성 판단을 위해 읽어야 할 레코드 건수를 예측하여 보여준다.
이는 각 스토리지 엔진이 가지고 있는 통계 정보를 활용해 MySQL 옵티마이저가 산출한 예상 값이라서 정확하지 않다.
rows 칼럼에 있는 정수 값은 실제 반환되는 레코드 건수가 아닌, 얼마나 많은 레코드를 읽고 체크해야 하는지를 위미한다.

MySQL 옵티마이저는 해당 컬럼을 통해 읽어야할 레코드의 예측 건수가 많을 경우, 인덱스를 사용할 수 있음에도 풀 테이블 스캔을 수행할 수 있다.

# rows 컬럼의 값은 인덱스를 사용하는 조건에만 일치하는 레코드를 예측할 수 있다.

[ filtered 칼럼 ]
filtered 칼럼은 인덱스를 사용할 수 없는 조건에 대해 조건에 일치하는 레코드 건수를 예측한 수치이다.

인덱스 조건에 일치하는 건수를 rows 컬럼으로 나왔다면, 다음 인덱스 없는 조건에 대해 일치하는 레코드 비율을 해당 컬럼을 통해 보면 된다.
# filtered 컬럼은 0~100 까지의 수치를 나타내며 16.08 은 조건에 일치하는 레코드가 16.08%가 된다는 뜻이다.

여기서 filtered 칼럼은 인덱스를 사용하지 못하는 모든 조건들의 만족하는 레코드의 비율 수치가 된다.
filtered 의 값은 조인에서 잘 활용될 수 있는데, 모든 조건에 만족하는 ( 예측한 수치 ) 레코드가 작은 테이블을 드라이빙 테이블로 선정하여 좋은 실행 계획을 세울 수 있을 것이다.
MYSQL 8.0 은 filtered 를 더 정확히 예측할 수 있게 히스토그램이 도입되었다.

[ Extra 컬럼 ]
실행 계획의 성능과 관련된 중요한 내용이 Extra 컬럼에 표시되며, 일반적으로 2~3개씩 함께 표시가 된다.

- const row not found
쿼리의 실행 계획에서 const 접근 방법으로 테이블을 읽었지만, 조건에 일치하는 레코드가 1건도 존재하지 않을 때 표시된다.

- deleting all rows
MyISAM 스토리지 엔진과 같이 스토리지 엔진의 핸들러 차원에서 테이블의 모든 레코드를 삭제하는 기능을 제공하는 스토리지 엔진을 사용하는 테이블에서 볼 수 있다.
이는 WHERE 조건 절이 없는 DELETE 문장을 호출할 때 확인할 수 있다.

이는 테이블의 모든 레코드를 삭제하는 핸들러 기능을 한번 호출함으로써 처리됐다는 것을 의미한다.
# 다만 모든 레코드를 제거애햐 한다면 TRUNCATE TABLE 명령을 사용하는 것이 더 좋다.
# 기존에는 모든 레코드를 삭제하기 위해 핸들러 함수를 레코드 건수만큼 호출해서 삭제했어야 했다.

- distinct
유니크한 값을 가져오기 위해, 조인하지 않아도 되는 항목은 무시하고 필요한 것만 조인한다.
이는 드라이빙 테이블에서 레코드를 하나씩 읽고 드리븐 테이블에서 데이터를 조회할 때, 이미 존재하는 것을 확인했다면 드라이빙 테이블은 더이상 읽지 않고 바로 다음 레코드를 읽는다.

즉, 드리븐 테이블에 데이터가 더 있으나, 필요치 않은 경우라면 더이상 읽지 않는다.

- FirstMatch
세미 조인의 여러 최적화 중 FirstMatch가 사용되었을 때, FirstMatch(table_name) 메세지가 출력된다.

FirstMatch 메세지와 함께 표시되는 테이블명은 기준 테이블 명을 의미하는데, 기준 테이블을 기준으로 서브 쿼리에 있는 테이블에서 첫 번째로 일치하는 것만 읽는 다는 것을 의미한다.

- Full scan on NULL key
해당 처리는 col1 IN (SELECT col2 FROM ..) 와 같은 조건을 가진 쿼리에서 자주 발생하며, col1 의 값이 NULL 이 된다면 조건은 NULL IN (SELECT col2 FROM ...) 으로 바뀐다.

SQL 표준에서는 NULL에 대한 연산 규칙이 있다. 그 규칙으로 연산을 수행하려면 다음과 같이 비교해야 한다.
1. 서브 쿼리가 1건이라도 레코드를 반환한다면 최종 비교 결과는 NULL
2. 서브쿼리가 1건의 레코드도 가지지 않는다면 최종 비교 결과는 FALSE

이 결과를 얻으러면 col1 가 NULL일 경우 서브 쿼리에 있는 테이블들은 풀 테이블 스캔을 해야 한다.
이는 MySQL 서버가 col1 가 NULL일 경우 차선책으로 서브 쿼리에 있는 테이블들을 풀 테이블 스캔할 것이라는 것을 알려주는 키워드이다.

만약 col1 이 NOT NULL 일 경우 이러한 차선책은 사용하지 않고, Extra 칼럼에도 표시되지 않을 것이다.
혹은 NULL 이 될 수 없음을 옵티마이저에게 알려주면 된다. 대표적인 방법으로는 col1 컬럼의 조건 앞에 col1 IS NOT NULL 조건을 붙이면 된다.
# 혹은 col1 컬럼이 NULL 이 오지 않는 경우라면 크게 문제되지 않는다. ( Extra 컬럼에 표시된다고 하더라도.. )

- impossible HAVING
쿼리 내에서 HAVING 조건에 만족하는 레코드가 1건도 없을 때 해당 키워드가 출력된다.

만약 해당 쿼리가 출력된다면 쿼리가 제대로 작성되지 못한 경우이기 때문에 쿼리를 다시 점검하는 것이 좋다.

- Impossible WHERE
Impossible HAVING 과 같이 WHERE 조건이 항상 FALSE 가 되는 경우 해당 키워드가 출력된다.

NOT NULL 컬럼에 대해 col1 IS NULL 으로 NULL 여부를 확인하는 WHERE 절에서 확인될 수 있다.

- LooseScan
세미 조인 최적화 중 LooseScan 최적화 전략이 사용되면 해당 키워드가 출력된다.

- No match min/max row
일반적으로 WHERE 조건에 만족하는 레코드가 존재하지 않을 경우 Impossible WHERE 가 출력되는데, 해당 쿼리에 MIN() , MAX() 집합 함수가 쿼리에 있을 때 No match min/max row 를 출력한다.
그리고 MIN() , MAX() 결과로 NULL 이 반환된다.

- no matching row in const table
조인이 사용된 테이블에서 const 방법으로 접근할 때 조건에 일치하는 레코드가 하나도 없다면 해당 키워드를 출력한다.

SELECT * from table_1 , (SELECT col1 FROM table_2 WHERE col1=0) WHERE table_1.col1 = table_2.col2 AND table_1.col2 = 'DA';
이는 Impossible WHERE 와 같은 종류로 실행 계획을 만들기 위한 기초 자료 ( 레코드 ) 가 없음을 의미한다.

- No matching rows after partition pruning
이는 파티션된 테이블에 대해 UPDATE 또는 DELETE 를 수행할 때, 해당 파티션에 UPDATE 하거나 DELETE 할 대상이 없을 때 표시된다.
만약 테이블이 col1 컬럼을 기준으로 값이 40 까지 파티션되어 있는데, col1 값이 60보다 큰 조건에서만 삭제할 경우 해당 메세지가 표시된다.
이는 DELETE 혹은 UPDATE 할 대상 레코드가 아닌, 대상 파티션이 없다는 것을 의미한다.
# 이떄 실행 계획에서 partitions 컬럼도 비어있다. ( NULL )

만약 대상 파티션은 존재하지만, 삭제할 레코드가 존재한다면 해당 메세지는 뜨지 않는다.

- No tables used
FROM 절이 없는 쿼리 문장이나, FROM DUAL 형태의 쿼리에서 해당 키워드가 출력된다.

SELECT 1 혹은 SELECT 1 FROM dual
# DUAL 은 상수 테이블을 의미하며 칼럼과 레코드를 각각 1개씩만 가지는 가상의 상수 테이블이다.

- Not exists
해당 키워드는 아우터 조인을 이용해 안티-조인을 수행하는 쿼리에서 해당 키워드가 출력된다.

안티-조인은 NOT IN(subquery) 나 NOT EXISTS 연산자를 활용한 형태를 조인을 의미한다.
이는 똑같은 처리를 아우터 조인을 이용해서 처리할 수 있다.
# A테이블에는 없지만 B테이블에 있는 값을 조회할 때 안티-조인으로 처리하는 것이 일반적이긴 하나, 레코드의 건수가 많을 때에는 아우터 조인을 활용해서 처리하는 경우 빠른 성능을 낼 수 있다.

해당 키워드는 옵티마이저가 아우터 조인을 수행할 때 아우터 조인에 있는 테이블의 레코드가 존재하는지 아닌지만 판단하는 것을 의미한다.
즉, 조건에 일치하는 레코드가 여러 건 있다 하더라도 1건만 보고 처리를 완료하는 최적화를 의미한다.
# FROM table_1 LEFT JOIN table_2 ON t1=t2 WHERE table_2.col1 IS NULL;

- Plan isn't ready yet
해당 키워드는 EXPLAIN FOR CONNECTION 명령을 통해 다른 커넥션이 수립한 실행 계획을 볼 때,
해당 커넥션이 쿼리에 대한 실행 계획을 아직 세우지 못하였을 때 해당 키워드가 뜬다.

# EXPLAIN FOR CONNECTION 2 으로 다른 커넥션 id 의 실행 계획을 보려면 우선 SHOW PROCESSLIST; 를 통해 쿼리를 처리중인 리스트에서 id 값을 추출해야 한다.

- Range checked for each record(index map: N)
해당 키워드는 레코드마다 인덱스 레인지 스캔을 체크하는 키워드이다.

SELECT * FROM table_1 , table_2 WHERE table_1.emp_no >= table_2.emp_no
위와 같은 쿼리가 있을 때 인덱스는 table_1 에 있는 레코드를 순서대로 읽으면서 table_2 테이블을 풀 테이블 스캔할지 레인지 인덱스 스캔할 지 선택한다.
그 이유는 table_1 에 emp_no 의 값은 레코드 조회마다 항상 달라져, 쿼리 처리 비용이 항상 바뀌기 때문이다.
# emp_no 의 값이 1일 때와 큰 값일 때의 조건에 일치하는 레코드의 수가 바뀌기 때문이다.

이때 실행 계획의 type 에는 ALL이 표시된다.
이는 항상 풀 테이블 스캔으로 처리하는 것이 아니라 옵티마이저가 레코드를 한 건씩 읽으면서 해당 레코드에 대해 드리븐 테이블을 인덱스를 사용할지 풀 테이블 스캔을 할지 구분한다.
이때 어떤 인덱스를 사용할 수 있는지에 대한 정보는 Extra 컬럼 뒤에 (index map: 0x1) 값으로 판단할 수 있다.
해당 값은 16진수로 2진수로 바꾸어야 한다. 2진수로 바꾸었을 때 1로 표시된 자릿수의 인덱스 순번이 사용할 수 있는 인덱스 후보가 된다.

여기서 인덱스 순번이란 SHOW CREATE TABLE table_1 쿼리를 통해 조회한 테이블 구조에서 나타나는 인덱스의 순서이다.
# 맨 윗줄에 있는 인덱스는 1순번 , N번째 있는 인덱스는 N순번이다.

만약 0x19 일때 2진수로 바꾸면 11001 이 되며, 이는 5,4,1번째 인덱스 (5번째, 4번째 ,1번째 줄 인덱스)가 인덱스 사용후보가 된다.
# 각 레코드마다 어떤 인덱스가 사용됐는지는 알 수 없다. 
# 그리고 프라이머리 키 또한 인덱스에 포함된다.

- Recursive
CTE를 이용한 재귀 쿼리를 사용할 경우 해당 키워드가 출력된다.

# MySQL 8.0 버전부터는 CTE를 이용한 재귀 쿼리를 작성할 수 있게 되었다.
# 일반 CTE를 사용한 경우에는 해당 키워드가 발생하지 않는다.

- Rematerialize
쿼리에서 레터럴 조인을 활용해서 조인을 처리할 때 해당 키워드가 표시된다.

쿼리에 레터럴 조인이 사용된 경우, 선행 테이블의 레코드마다 서브쿼리를 실행하고 그 결과를 임시 테이블에 저장한다.
그 후 선행 테이블과 임시 테이블을 조인한다. 이때 선행 테이블의 레코드마다 임시 테이블이 새로 생성된다.

# 레터럴 조인은 MySQL 8.0 버전에 탄생했다.

- select tables optimized away
MIN() , MAX() 만 사용되거나, GROUP BY를 통해 MIN() , MAX() 를 사용하는 쿼리에서 인덱스의 오름차순이나 내림차순으로 1건만 읽는 최적화가 사용되면 해당 키워드를 출력한다.
MyISAM 테이블에서는 GROUP BY 없이 COUNT(*) 를 SELECT 할 떄에도 해당 키워드가 출력된다.
# MyISAM 테이블은 전체 레코드 건수를 별도로 관리하기 떄문이다. 이때 WHERE 절이 있는 경우 최적화를 사용하지 못한다.

즉 해당 컬럼에 인덱스가 있을 때, 인덱스는 정렬된 순서이기 때문에 정렬된 레코드의 맨 앞 혹은 맨 뒷 레코드 1건만 가져오면 된다.

이때 조건 절이 있는 경우 WHERE 절과 SELECT 절에 인덱스가 있는 경우에도 해당 최적화를 사용할 수 있다.
예를 들어 SELECT MIN(col1) FROM ... WHERE col2 = 2 쿼리가 있을 떄 (col2 , col1) 인덱스가 있다면 해당 최적화를 사용할 수 있다.

- Start temporary, End temporary
세미조인 최적화 중 Duplicate Weed-out 최적화 전략이 사용되면 Extra 컬럼에 Start temporary, End temporary 를 표시하게 된다.

조인되어 내부 임시 테이블에 저장되는 테이블을 식별할 수 있게 조인의 첫번째 테이블에 Start temporary 를 보여주고,
조인이 끝나는 부분에 End temporary 문구를 표시한다.

- unique row not found
두 테이블이 각각 프라이머리키나 유니크키로 아우터 조인을 수행하는 쿼리에서 아우터 테이블에 일치하는 레코드가 존재하지 않을 때 해당 키워드가 표시된다.

예를 들어 FROM table_1 LEFT JOIN table_2 ... 라는 쿼리가 있을 때 table_1 테이블의 컬럼에는 데이터가 존재하지만, table_2 테이블의 컬럼에 데이터가 없을 때에 해당된다.

- Using filesort
해당 키워드는 ORDER BY 가 사용된 쿼리에서만 확인할 수 있으며, ORDER BY 정렬에 대해 인덱스를 사용하지 못해 MySQL 서버가 조회된 레코드를 다시 한번 정렬할 때 해당 키워드가 출력된다.
이때 MySQL 옵티마이저는 조회된 레코드를 정렬용 메모리 버퍼 ( 소트 버퍼 ) 에 복사해 퀵 소트나 힙 소트 알고리즘을 이용해 정렬을 수행한다.

해당 키워드는 쿼리에 많은 부하를 일으키기 때문에 쿼리를 튜닝하거나 인덱스를 생성하는 것이 좋다.
# 보통 ORDER BY 대상 컬럼에 인덱스가 없을 때 문제가 발생한다.

- Using index ( 커버링 인덱스 )
쿼리가 데이터 파일을 읽지 않고, 인덱스만 활용해서 처리할 수 있는 경우 해당 키워드가 출력된다.

즉, 쿼리를 처리할 때 해당 레코드를 읽기 위해 데이터 파일에 접근하지 않고, 인덱스에 있는 컬럼만으로 쿼리를 처리할 수 있는 것을 커버링 인덱스라고 한다.
# 쿼리를 처리할 때 해당 레코드에 데이터를 가져오기 위해 데이터 파일에 접근하는 것은 성능을 저하를 유발한다.
# 혹여나 쿼리가 인덱스 레인지 스캔을 사용할 수 있다고 해도, 조회된 모든 레코드가 데이터 파일에서 추가로 컬럼을 읽어와야 한다면 풀 테이블 스캔으로 처리될 수 있다.
# 인덱스 레인지 스캔이랑 커버링 인덱스가 함께 사용되면 성능이 빨라진다

같은 쿼리에 대해 커버링 인덱스를 사용할 수 있을 때와 사용할 수 없을 때에는 성능 차이가 많이 발생한다.
그렇다고 인덱스에 많은 컬럼을 넣으면 데이터의 추가와 변경의 성능이 떨어질 수 있고, 인덱스의 크기 증가로 메모리 낭비가 심해질 것이다.
# InnoDB 의 모든 테이블은 클러스터링 인덱스로 구성된다. 이는 세컨더리 인덱스는 데이터 주소를 프라이머리 키 값을 가진다는 것을 의마하는데, 이는 인덱스에 자동적으로 프라이머리 키가 추가된다.

해당 키워드는 접근 방법이 인덱스를 사용하는 실행 계획에서 표시될 수 있으며, 인덱스 레인지 스캔으로 처리될 때에만 출력되는 것이 아니다.

- Using index condition
MySQL 옵티마이저가 인덱스 컨디션 푸시다운 최적화를 사용하면 Extra 컬럼에 해당 키워드를 출력한다.

- Using index for group-by
GROUP BY 처리를 할 때 인덱스를 활용하는 방법을 루스 인덱스 스캔이라고 한다.
이때 GROUP BY 처리에 인덱스를 이용하게 되면 해당 키워드가 출력된다.

이떄 GROUP BY 작업은 해당 컬럼을 정렬하고 그루핑 작업을 수행하는 고부하 작업인데, 해당 컬럼이 인덱스일 경우 ( B-Tree에 한해 )
정렬 작업 없이, 그대로 필요한 부분만 읽으면 되기 때문에 효율적으로 처리된다.

이때 GROUP BY 작업에 인덱스를 사용할 수 있더라도 AVG() , SUM() , COUNT() 집계 함수와 같이 모든 인덱스를 모두 읽어야 할 때에는
해당 키워드가 출력되지 않는다. 그 이유는 루스 인덱스 스캔이라는 필요한 부분을 읽을 수 없기 때문이다.
결론적으로 GROUP BY가 인덱스를 사용할 수 있어야 하고, 루스 인덱스 스캔을 사용할 수 있어야 한다.

또한 인덱스에 여러 컬럼이 존재할 때, GROUP BY 에서 인덱스를 사용할 수 있어야 하고 WHERE 절을 사용할 때에도 인덱스를 사용할 수 있어야 한다.
즉, WHERE 절의 조건과 GROUP BY 처리에 같은 인덱스를 사용할 수 있어 루스 인덱스 스캔을 사용할 수 있다.

# 만약 WHERE 조건에 일치하는 레코드 건수가 적은 경우 옵티마이저는 루스 인덱스 스캔을 사용하지 않을 수 있다.
# 데이터의 양이 적은 경우 루스 인덱스 스캔을 사용하지 않아도 빠르기 때문이다.

- Using index for skip scan
쿼리에서 인덱스 스킵 스캔 최적화를 사용하면 해당 키워드가 출력된다.

이는 MySQL 8.0 버전부터 루스 인덱스 스캔 최적화를 확장한 개념으로 부족한 부분은 있지만 최적화하는데 중요한 기능이다.

- Using join Buffer(Blocked Nested Loop / Batched Key Access / hash join )
조인을 수행하는 컬럼에서는 인덱스는 중요한 역할을 한다. 여기서 드리븐 테이블의 조인 컬럼의 인덱스가 필요하다.
MySQL 옵티마이저는 조인 대상의 컬럼에 인덱스가 없으면 드라이빙 테이블로 선택하고, 인덱스가 있으면 드리븐 테이블로 선택해서 처리한다.

이때 조인에 적절한 인덱스가 없으면 블록 네스티드 조인이나 해시 조인을 활용한다.
이때 MySQL 은 조인버퍼를 사용해야 하는데, 조인 버퍼가 사용되면 해당 키워드가 출력된다.

그리고 괄호 안에는 조인 버퍼나 블록 네스티드 조인 등 어떤 조인 알고리즘이 사용됐는지 표시가 된다.