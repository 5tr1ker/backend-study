[ ref 칼럼 ]
접근 방법이 ref일 경우 참조 조건으로 어떤 값이 제공됐는지 보여준다.
상수 값일 경우 const로 표시되고, 다른 테이블의 칼럼이면 테이블.칼럼 으로 표기된다.

이때 func 일 경우 ( function ) 참조용으로 사용되는 값이 그대로 사용된 것이 아닌 콜레이션 변환이나 연산을 거쳐 사용됐다는 것을 의미한다.

SELECT * FROM table_1 t1 , table_2 t2 WHERE t1.key = ( t2.key + 1 )
위의 쿼리와 같이 참조 조건의 값을 변환해서 사용할 때 ref 칼럼의 값이 func가 된다.

다만 사용자가 명시적으로 변환하는 것이 아닌 MySQL 서버가 내부적으로 값을 변환할 떄에도 ref 칼럼이 func가 될 수 있다.
이는 문자타입일 일치하지 않거나, 숫자 타입과 문자 타입의 칼럼을 조인할 때에 해당된다.

[ rows 칼럼 ]
rows 컬럼은 실행 계획의 효율성 판단을 위해 읽어야 할 레코드 건수를 예측하여 보여준다.
이는 각 스토리지 엔진이 가지고 있는 통계 정보를 활용해 MySQL 옵티마이저가 산출한 예상 값이라서 정확하지 않다.
rows 칼럼에 있는 정수 값은 실제 반환되는 레코드 건수가 아닌, 얼마나 많은 레코드를 읽고 체크해야 하는지를 위미한다.

MySQL 옵티마이저는 해당 컬럼을 통해 읽어야할 레코드의 예측 건수가 많을 경우, 인덱스를 사용할 수 있음에도 풀 테이블 스캔을 수행할 수 있다.

# rows 컬럼의 값은 인덱스를 사용하는 조건에만 일치하는 레코드를 예측할 수 있다.

[ filtered 칼럼 ]
filtered 칼럼은 인덱스를 사용할 수 없는 조건에 대해 조건에 일치하는 레코드 건수를 예측한 수치이다.

인덱스 조건에 일치하는 건수를 rows 컬럼으로 나왔다면, 다음 인덱스 없는 조건에 대해 일치하는 레코드 비율을 해당 컬럼을 통해 보면 된다.
# filtered 컬럼은 0~100 까지의 수치를 나타내며 16.08 은 조건에 일치하는 레코드가 16.08%가 된다는 뜻이다.

여기서 filtered 칼럼은 인덱스를 사용하지 못하는 모든 조건들의 만족하는 레코드의 비율 수치가 된다.
filtered 의 값은 조인에서 잘 활용될 수 있는데, 모든 조건에 만족하는 ( 예측한 수치 ) 레코드가 작은 테이블을 드라이빙 테이블로 선정하여 좋은 실행 계획을 세울 수 있을 것이다.
MYSQL 8.0 은 filtered 를 더 정확히 예측할 수 있게 히스토그램이 도입되었다.

[ Extra 컬럼 ]
실행 계획의 성능과 관련된 중요한 내용이 Extra 컬럼에 표시되며, 일반적으로 2~3개씩 함께 표시가 된다.

- const row not found
쿼리의 실행 계획에서 const 접근 방법으로 테이블을 읽었지만, 조건에 일치하는 레코드가 1건도 존재하지 않을 때 표시된다.

- deleting all rows
MyISAM 스토리지 엔진과 같이 스토리지 엔진의 핸들러 차원에서 테이블의 모든 레코드를 삭제하는 기능을 제공하는 스토리지 엔진을 사용하는 테이블에서 볼 수 있다.
이는 WHERE 조건 절이 없는 DELETE 문장을 호출할 때 확인할 수 있다.

이는 테이블의 모든 레코드를 삭제하는 핸들러 기능을 한번 호출함으로써 처리됐다는 것을 의미한다.
# 다만 모든 레코드를 제거애햐 한다면 TRUNCATE TABLE 명령을 사용하는 것이 더 좋다.
# 기존에는 모든 레코드를 삭제하기 위해 핸들러 함수를 레코드 건수만큼 호출해서 삭제했어야 했다.

- distinct
유니크한 값을 가져오기 위해, 조인하지 않아도 되는 항목은 무시하고 필요한 것만 조인한다.
이는 드라이빙 테이블에서 레코드를 하나씩 읽고 드리븐 테이블에서 데이터를 조회할 때, 이미 존재하는 것을 확인했다면 드라이빙 테이블은 더이상 읽지 않고 바로 다음 레코드를 읽는다.

즉, 드리븐 테이블에 데이터가 더 있으나, 필요치 않은 경우라면 더이상 읽지 않는다.

- FirstMatch
세미 조인의 여러 최적화 중 FirstMatch가 사용되었을 때, FirstMatch(table_name) 메세지가 출력된다.

FirstMatch 메세지와 함께 표시되는 테이블명은 기준 테이블 명을 의미하는데, 기준 테이블을 기준으로 서브 쿼리에 있는 테이블에서 첫 번째로 일치하는 것만 읽는 다는 것을 의미한다.

- Full scan on NULL key
해당 처리는 col1 IN (SELECT col2 FROM ..) 와 같은 조건을 가진 쿼리에서 자주 발생하며, col1 의 값이 NULL 이 된다면 조건은 NULL IN (SELECT col2 FROM ...) 으로 바뀐다.

SQL 표준에서는 NULL에 대한 연산 규칙이 있다. 그 규칙으로 연산을 수행하려면 다음과 같이 비교해야 한다.
1. 서브 쿼리가 1건이라도 레코드를 반환한다면 최종 비교 결과는 NULL
2. 서브쿼리가 1건의 레코드도 가지지 않는다면 최종 비교 결과는 FALSE

이 결과를 얻으러면 col1 가 NULL일 경우 서브 쿼리에 있는 테이블들은 풀 테이블 스캔을 해야 한다.
이는 MySQL 서버가 col1 가 NULL일 경우 차선책으로 서브 쿼리에 있는 테이블들을 풀 테이블 스캔할 것이라는 것을 알려주는 키워드이다.

만약 col1 이 NOT NULL 일 경우 이러한 차선책은 사용하지 않고, Extra 칼럼에도 표시되지 않을 것이다.
혹은 NULL 이 될 수 없음을 옵티마이저에게 알려주면 된다. 대표적인 방법으로는 col1 컬럼의 조건 앞에 col1 IS NOT NULL 조건을 붙이면 된다.
# 혹은 col1 컬럼이 NULL 이 오지 않는 경우라면 크게 문제되지 않는다. ( Extra 컬럼에 표시된다고 하더라도.. )

- impossible HAVING
쿼리 내에서 HAVING 조건에 만족하는 레코드가 1건도 없을 때 해당 키워드가 출력된다.

만약 해당 쿼리가 출력된다면 쿼리가 제대로 작성되지 못한 경우이기 때문에 쿼리를 다시 점검하는 것이 좋다.

- Impossible WHERE
Impossible HAVING 과 같이 WHERE 조건이 항상 FALSE 가 되는 경우 해당 키워드가 출력된다.

NOT NULL 컬럼에 대해 col1 IS NULL 으로 NULL 여부를 확인하는 WHERE 절에서 확인될 수 있다.

- LooseScan
세미 조인 최적화 중 LooseScan 최적화 전략이 사용되면 해당 키워드가 출력된다.

- No match min/max row
일반적으로 WHERE 조건에 만족하는 레코드가 존재하지 않을 경우 Impossible WHERE 가 출력되는데, 해당 쿼리에 MIN() , MAX() 집합 함수가 쿼리에 있을 때 No match min/max row 를 출력한다.
그리고 MIN() , MAX() 결과로 NULL 이 반환된다.

- no matching row in const table
조인이 사용된 테이블에서 const 방법으로 접근할 때 조건에 일치하는 레코드가 하나도 없다면 해당 키워드를 출력한다.

SELECT * from table_1 , (SELECT col1 FROM table_2 WHERE col1=0) WHERE table_1.col1 = table_2.col2 AND table_1.col2 = 'DA';
이는 Impossible WHERE 와 같은 종류로 실행 계획을 만들기 위한 기초 자료 ( 레코드 ) 가 없음을 의미한다.

- No matching rows after partition pruning
이는 파티션된 테이블에 대해 UPDATE 또는 DELETE 를 수행할 때, 해당 파티션에 UPDATE 하거나 DELETE 할 대상이 없을 때 표시된다.
만약 테이블이 col1 컬럼을 기준으로 값이 40 까지 파티션되어 있는데, col1 값이 60보다 큰 조건에서만 삭제할 경우 해당 메세지가 표시된다.
이는 DELETE 혹은 UPDATE 할 대상 레코드가 아닌, 대상 파티션이 없다는 것을 의미한다.
# 이떄 실행 계획에서 partitions 컬럼도 비어있다. ( NULL )

만약 대상 파티션은 존재하지만, 삭제할 레코드가 존재한다면 해당 메세지는 뜨지 않는다.

- No tables used
FROM 절이 없는 쿼리 문장이나, FROM DUAL 형태의 쿼리에서 해당 키워드가 출력된다.

SELECT 1 혹은 SELECT 1 FROM dual
# DUAL 은 상수 테이블을 의미하며 칼럼과 레코드를 각각 1개씩만 가지는 가상의 상수 테이블이다.

- Not exists
해당 키워드는 아우터 조인을 이용해 안티-조인을 수행하는 쿼리에서 해당 키워드가 출력된다.

안티-조인은 NOT IN(subquery) 나 NOT EXISTS 연산자를 활용한 형태를 조인을 의미한다.
이는 똑같은 처리를 아우터 조인을 이용해서 처리할 수 있다.
# A테이블에는 없지만 B테이블에 있는 값을 조회할 때 안티-조인으로 처리하는 것이 일반적이긴 하나, 레코드의 건수가 많을 때에는 아우터 조인을 활용해서 처리하는 경우 빠른 성능을 낼 수 있다.

해당 키워드는 옵티마이저가 아우터 조인을 수행할 때 아우터 조인에 있는 테이블의 레코드가 존재하는지 아닌지만 판단하는 것을 의미한다.
즉, 조건에 일치하는 레코드가 여러 건 있다 하더라도 1건만 보고 처리를 완료하는 최적화를 의미한다.
# FROM table_1 LEFT JOIN table_2 ON t1=t2 WHERE table_2.col1 IS NULL;