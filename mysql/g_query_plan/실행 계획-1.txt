[ 통계 정보 ]
MySQL 5.7 버전 이전에는 테이블과 인덱스에 대한 정보만 가지고 실행 계획을 수립했다.
하지만 이는 테이블에 저장된 레코드의 값이 실제로 어떻게 분포되어 있는지에 대한 정보가 없기 때문에 실행 계획의 정확도가 떨어졌다.

MySQL 8.0 부터는 인덱스되지 않은 컬럼에 대해서도 데이터 분포도를 수집하는 히스토그램 기능이 도입되었다.

- 테이블 및 인덱스 통계 정보
비용 기반 최적화에서 가장 중요한 것은 통계 정보이다. 통계 정보가 정확하지 않다면 잘못된 실행 계획으로 처리될 수 있다.
예를 들어 실제 레코드에 10억 건이 들어있는데 통계 정보가 갱신되지 않아 레코드가 10건만 들어있다고 되어있다면, 옵티마이저는 테이블 풀 스캔을 실행하여 쿼리의 성능을 떨어뜨릴 것이다.

MySQL 도 다른 DBMS 처럼 비용 기반의 최적화를 사용했지만, 통계 정보의 휘발성이 강하여 정확도가 높지 않았다.
그래서 MySQL는 실행 계획을 수립할 때 실제 테이블의 레코드를 일부 분석해서 통계 정보로 활용했다.
MySQL 5.6 버전부터는 통계 정보의 정확도를 높이기 위해 점점 개선을 하였다.

- MySQL 서버의 통계 정보
MySQL 5.5 버전 까지는 테이블의 통계 정보가 메모리에 보관되어왔다. 이는 MySQL 서버가 재기동되면 통계 정보가 사라진다는 단점이 있다.
하지만 5.6 버전부터는 InnoDB 스토리지 엔진을 사용하는 테이블에 대해 통계 정보가 영구적으로 관리할 수 있게 개선되었다.
이는 mysql 데이터베이스에서 innodb_index_stats 테이블과 innodb_table_stats 테이블에 각 테이블에 대한 통계 정보를 관리하여 MySQL 서버가 재기동 되어도 데이터가 유지될 수 있게 개선됐다.

MySQL 5.6 버전부터는 테이블을 생성할 때 STATS_PERSISTENT 옵션을 통해 해당 테이블의 통계 정보를 영구적으로 관리할지 말지를 선택할 수 있다.
STATS_PERSISTENT=0 으로 할 경우 MySQL 5.5 이전 버전의 방식대로 관리한다.
STATS_PERSISTENT=1 으로 할 경우 테이블에 대한 통계 정보를 innodb_index_stats 테이블과 innodb_table_stats 테이블에 저장한다.
STATS_PERSISTENT=DEFAULT 으로 할 경우 해당 옵션을 안 붙인 것과 동일하여, innodb_stats_persistent 시스템 변수의 값에 따른다.

innodb_stats_persistent 의 기본 값은 1이며, 1로 설정될 경우 테이블의 통계 정보를 innodb_index_stats 테이블과 innodb_table_stats 테이블에 영구적으로 보관한다.
# 테이블 통계 정보 관리 여부는 ALTER TABLE 로 변경할 수 있다.
# MySQL 5.5 버전에서는 테이블의 통계 정보가 메모리에 관리되기 때문에, 서버가 재기동되면 다시 테이블의 통계 정보를 수집해야 했다.

테이블에 대한 통계 정보는 다음과 같은 이벤트가 발생하면 자동으로 통계 정보가 갱신된다.
1. 테이블이 오픈되는 경우
2. 테이블의 레코드가 대량으로 변경되는 경우 ( 전체 레코드 중 1/16 정도의 쿼리가 insert update delete 되는 경우 )
3. ANALYZE TABLE 명령이 실행되는 경우
4. SHOW TABLE STATUS 명령이나 SHOW INDEX FROM 명령이 실행되는 경우
5. InnoDB 모니터가 활성되는 경우
6. innodb_status_on_metadata 시스템 변수가 ON 인 상태에서 SHOW TABLE STATUS 명령이 실행 되는 경우

테이블의 통계 정보가 지속적으로 변경될 경우 옵티마이저가 잘못된 실행 계획을 세울수도 있다.
하지만 이는 영구적인 통계 정보가 도입되면서 의도치 않은 통계 정보 변경을 막았다.
혹은 innodb_stats_auto_recalc 시스템 변수를 OFF 로 설정하면 통계 정보가 자동으로 갱신되는 것을 막을 수 있다. ( 기본 값은 ON 이다. )
# 영구적으로 통계 정보를 관리한다면 해당 옵션은 OFF로 설정하는 것이 좋다.

또한 STATUS_AUTO_RECALC 옵션을 사용하면 각 테이블 단위로 통계 정보를 자동으로 수집할지 설정할 수 있다.
STATUS_AUTO_RECALC=1 : MySQL 5.5 버전 이전 방식을 따른다.
STATUS_AUTO_RECALC=0 : ANALYZE TABLE 명령을 수행할 때에만 수집한다.
STATUS_AUTO_RECALC=DEFAULT : 옵션을 지정하지 않은 것과 동일하며 innodb_stats_auto_recalc 시스템 변수 값을 따른다.

MySQL 5.6 버전부터는 테이블의 통계 정보를 수집할 때 innoDB 스토리지 엔진을 사용하는 테이블 블록을 샘플링하여 더 정확한 통계 정보를 만들어낼 수 있다.
innodb_stats_transient_sample_pages : 기본 값은 8 이며, 자동으로 테이블의 통계 정보를 수집할 때 임의의 8개의 페이지를 분석하고 그 결과를 통계 정보에 활용한다.
innodb_stats_persistent_sample_pages : 기본 값은 20이며 ANALYZE TABLE 명령을 실행하면 임의의 20개의 테이블을 샘플링하여 그 결과를 통계 정보에 활용한다. ( 통계 정보 테이블에 저장 )

innodb_stats_persistent_sample_pages 설정 값이 높아짐에 따라 실행 시간은 오래 걸리겠지만, 통계 정보는 쿼리의 성능을 좌우하기 때문에 긴 시간을 투자할 가치가 있다.
# 보통 쿼리의 성능은 통계 정보의 역할이 크다. 그렇기 떄문에 사용자가 별로 없는 시간대에 작업을 처리하는 것이 좋다.

[ 히스토그램 ]
MySQL 8.0 부터는 컬럼의 데이터 분포도를 참조할 수 있는 히스토그램이 탄생하였다.
히스토그램은 자동으로 수집되는 것이 아닌 ANALYZE TABLE ... UPDATE HISTOGRAM 명령으로 수동으로 수집 및 관리한다.
수집된 정보는 시스템 딕셔너리에 저장되고, MySQL 서버가 시작될 때 information_schema DB 의 column_statistics 테이블에 로드한다.

히스토그램은 2가지의 타입이 있다.
1. 싱글톤 히스토그램 : 칼럼값 개별로 레코드 건수를 관리하는 히스토그램
2. 높이 균형 히스토그램 : 칼럼값의 범위를 균등한 개수로 구분해서 관리하는 히스토그램

히스토그램은 버킷 단위로 구분되며 레코드 건수나 범위 값을 관리하는데, 
싱글톤 히스토그램은 칼럼이 가지는 값 별로 버킷이 할당되며 각 버킷에 칼럼 값과 발생 빈도 비율의 값을 가지고 있고, 
높이 균형 히스토그램은 칼럼 값의 범위별로 버킷이 할당되며 범위 시작 값과 마지막 값, 그리고 발생 빈도와 유니크한 값의 갯수를 가진다.

# 싱글톤 히스토그램은 유니크한 값의 개수가 상대적으로 적은 경우에 사용된다. 

히스토그램은 ANALYZE TABLE DROP HISTOGRAM 명령을 통해 삭제할 수 있다. 이는 테이블의 데이터를 삭제하는 것이 아니라 딕셔너리의 내용만 삭제한다.
혹은 옵티마이저 옵션인 condition_fanout_filter 를 off 로 설정을 하면 MySQL 서버의 모든 쿼리가 히스토 그램을 사용하지 않는다. 다만 해당 옵션을 사용하는 다른 최적화도 비활성화 된다.

- 히스토그램의 용도
기존 MySQL 서버의 경우 테이블의 전체 데이터 건수와 인덱스 컬럼이 가지는 유니크한 값의 갯수만 가지고 있었다.
하지만 실제 데이터는 균등한 분포도를 가지고 있지 않기 때문에 MySQL 서버는 최적의 실행 계획을 세우진 못했다.
이러한 단점을 개선하기 위해 히스토그램이 도입되었다. 히스토그램은 각 칼럼의 분포도를 가지고 있진 않지만, 범위별로 레코드의 건수와 유니크한 값의 갯수를 가지고 있기 때문에 더욱 정확한 예측을 할 수 있게 되었다.

예를 들면 레코드의 건수가 1000건이고, 유니크 컬럼의 유니크한 값의 갯수가 100건일 경우 MySQL 서버는 다른 컬럼에 대해서도 대략 10개의 레코드가 일치할 것으로 예측한다. ( 실제론 하나도 없을 수도, 아니면 모든 레코드가 일치할 수도 있다. )
이는 각 레코드의 분포도를 판단해서 조인의 순서를 정하는 실행 계획에 더 나은 계획을 세울 수 있다. ( 상황에 따라 10배 이상 차이를 보일 수도 있다. )

- 히스토그램과 인덱스
M옵티마이저는 실행 계획을 세울 때 조건에 일치하는 레코드의 갯수를 파악하기 위해 실제 인덱스의 B-Tree 를 샘플링하는 인덱스 다이브를 실행한다.
이때 해당 컬럼에 히스토그램이 있다 하더라도 인덱스 다이브를 통해 정보를 수집한다.
그 이유는 인덱스 다이브는 히스토그램보다 정확한 결과를 기대하기 때문이다.
그래서 보통 히스토그램은 인덱스 되지 않은 컬럼의 데이터 분포도를 참조하는 용도로 활용된다.

하지만 인덱스 다이브 작업도 어느정도 비용이 필요하며, 때로는 실행 계획 수립만으로도 상당한 비용이 걸릴 수도 있다. ( IN 절에 값이 많이 명시된 경우 )
MySQL 8.0 버전 기준으로는 인덱스를 사용하지 않고 히스토그램을 사용하는 최적화는 아직 없다.

- 코스트 모델
코스트 모델은 사용자의 쿼리를 처리하는데, 필요한 작업에 드는 예상 비용을 측정하는 기준을 말한다.

MySQL 5.7 버전 이전에는 MySQL 서버의 소스 코드에 상수화 되어 있었지만, 5.7 버전 부터는 DBMS 관리자가 조정할 수 있게 되었다.

MySQL 8.0 서버의 코스트 모델은 다음 2개의 테이블에 저장된 설정 값을 활용한다.
1. server_cost : 인덱스를 찾고 레코드를 비교하고 임시 테이블 처리에 대한 비용
2. engine_cost : 레코드를 가진 데이터 페이지를 가져오는 데 필요한 비용

코스트 모델에서 중요한 것은 각 단위 작업에 설정된 비용이 변경되면 어떤 실행 계획이 고비용으로 바뀌고, 어떤 실행 계획이 저 비용으로 바뀌는지 파악해야 한다.
# 디스크에서 임시테이블을 만들거나, 메모리에서 임시테이블을 만드는 등

해당 코스트 모델을 수정하는 경우 옵티마이저는 실행 계획이 변경될 수 있다. 하지만 이는 하드웨어와 서버에 대한 깊은 지식을 필요로 하기 때문에
함부로 변경하는 것은 오히려 성능을 떨어뜰리 수 있다.

[ 실행 계획 확인 ]

- 실행 계획 출력 포맷
MySQL 에서는 EXPLAIN 명령으로 실행 계획을 확인할 때 표시 방법을 선택할 수 있다.
EXPLANE FORMAT=? 를 활용해서 TREE 나 JSON 혹은 기본 값인 테이블의 표시 형식을 선택할 수 있다.

- 쿼리 실행 시간 확인
MySQL 8.0.18 버전 부터는 쿼리의 실행 계획과 단계 별로 소요된 시간 정보를 EXPLAIN ANALYZE 를 통해 볼 수 있게 되었다.
# SHOW PROFILE 을 통해 어떤 부분에서 시간이 많이 소요됐는지 알 수 있지만 실행 계획 별 단계 별로 소요 시간은 볼 수 없었다.

EXPLAIN ANALYZE 는 기본 FORMAT이 TREE 이기 때문에 변경할 수 없다.

이때 Tree 형태로 나온 결과에 대해 들여쓰기가 가장 깊게 있는 문장이 가장 먼저 실행된 것이고, 같은 깊이일 경우 상단에 있는 라인이 먼저 실행된 것이다.
이때 각 단계별로 표시되는 정보에는 actual time ( 실제 소요된 시간 ) , rows ( 처리된 레코드 건수 ) , loops ( 반복 횟수 ) 가 있다.
이때 actual time 에서는 0.001..0.002 처럼 2개의 숫자가 나오는데, 첫번째는 첫 레코드를 가져오는데 걸린 평균 시간 ( 밀리초 ) 을 말하며 두 번째 숫자는 마지막 레코드를 가져오는데 걸리는 평균 시간 ( 밀리초 ) 를 의미한다.
rows 는 조건에 일치하는 평균 레코드 건수를 의미한다.
loops 는 A 테이블에서 조회된 레코드를 이용해 B 테이블의 레코드를 찾는 작업이 반복된 횟수를 의미한다. ( 이는 테이블 A 에서 읽은 레코드 건수를 의미한다. )
# rows 나 actual time 에서 말한 "평균 시간"이라는 것은 각 loops 마다 걸린 시간의 평균 값이다.
# 즉, 각 loops 마다 평균 rows 건수를 가져오는데 걸린 평균 시간 actual time ( 뒷 숫자 ) 이라고 볼 수 있다.

# EXPLAIN ANALYZE 명령은 실제 쿼리를 실행하고, 해당 쿼리를 처리하는데 사용된 실행 계획과 소요 시간을 보여준다. 그래서 해당 쿼리가 모두 처리가 되어야 결과를 확인할 수 있다.

[ 실행 계획 분석 ]
EXPLAIN 으로 표시된 실행 계획에서 각 레코드는 쿼리에 사용된 테이블 ( 임시 테이블 포함 ) 의 개수만큼 출력된다.
실행 순서의 위쪽에 위치할 수록 ( id 컬럼의 값이 작을 수록 ) 쿼리의 바깥 부분이거나 먼저 접근한 테이블이고, 아래쪽에 위치할 수록 ( id 컬럼이 클 수록 ) 쿼리의 안쪽 부분이나 나중에 접근한 테이블이다.

- id 컬럼
실행 계획에서 가장 왼쪽에 표시되는 id 컬럼은 각 SELECT 단위 쿼리별로 부여되는 식별자 값이다.
하나의 SELECT 문 안에 서브 SELECT 가 있다면 id 컬럼은 총 2개로 표시된다.

이때 만약 하나의 SELECT 문에서 여러개의 테이블을 조인하면, 조인되는 테이블의 개수만큼 레코드가 출력되지만 id 값은 같다.
만약 조인이 아닌 일반 SELECT 쿼리 여러개를 쓴다면 서로 다른 id 값을 가지게 된다.

주의해야 할 것은 id 컬럼의 값이 테이블의 접근 순서를 의미하지 않는다. 즉 id 값이 작은게 먼저 실행된 것은 아니다.
이때 EXPLAIN FORMAT=TREE 로 확인하면 가장 안쪽에 들여쓰기 된 부분이 먼저 실행된 것을 알 수 있다.

- select_type 칼럼
각 단위 SELECT 쿼리가 어떤 타입의 쿼리인지 표시되는 컬럼이다. 이때 표시될 수 있는 정보는 다음과 같다.

1. SIMPLE
UNION이나 서브쿼리를 사용하지 않은 간단한 SELECT 쿼리인 경우에 해당된다. ( 조인을 포함한 경우에도 해당 )
쿼리 문장이 복잡하더라도 select_Type 이 SIMPLE 인 단위 쿼리는 하나만 존재한다. ( 보통 제일 바깥 SELECT 쿼리 )

2. PRIMARY
UNION이나 서브쿼리를 가지는 SELECT 쿼리일 경우 제일 바깥쪽에 있는 단위 쿼리는 PRIMARY 가 된다.
SIMPLE과 마찬가지고 select_type 이 PRIMARY 인 단위 쿼리는 하나만 존재한다. ( 보통 제일 바깥 SELECT 쿼리 )

3. UNION
UNION 으로 결합되는 여러 단위 SELECT 쿼리에 대해, 첫 번째를 제외한 단위 SELECT 쿼리들은 UNION이 된다.
첫 번째 단위 SELECT 쿼리는 UNION 되는 쿼리 결과들을 모아서 저장하는 임시 테이블 ( DERIVED ) 로 표시된다.

4. DEPENDENT UNION
UNION 으로 여러 단위 SELECT 쿼리를 결합되며, 결합된 쿼리가 외부 쿼리에 영향을 받는 것을 말한다.

예를 들어 IN 절 안에 서브 쿼리가 있을 경우, 옵티마이저는 먼저 외부의 쿼리를 실행하고 그 다음 서브 쿼리를 실행한다.
이때 외부 쿼리의 결과가 서브 쿼리에 영향을 줄 때, 혹은 내부 쿼리가 외부 쿼리의 값을 참조할 때 DEPENDENT 키워드가 추가된다.

5. UNION RESULT
UNION 결과를 담아두는 테이블을 의미한다.
MySQL 8.0 이후 버전에서는 UNION ALL의 경우 임시 테이블을 사용하지 않게 성능이 개선되었지만, UNION 이나 UNION DISTINCT 는 여전히 임시 테이블에 결과를 버퍼링한다.
이때 임시 테이블을 사용한 경우 select_Type 이 UNION RESULT 가 된다. 또한 단위 SELECT 쿼리가 아니므로 id 값이 부여되지 않는다.

또한 table 칼럼에 <union1,2> 로 표시가 되는데, 이는 실행 계획에서 id 값이 1과 2인 단위 SELECT 쿼리의 결과를 병합했음을 의미한다.

6. SUBQUERY
FROM 절 이외에 사용되는 서브 쿼리인 경우 select_type 이 SUBQUERY 가 된다.
FROM 절에 사용된 서브 쿼리는 select_Type이 DERIVED 로 표시된다.

7. DEPENDENT SUBQUERY
서브쿼리가 바깥쪽 SELECT 쿼리에 정의된 칼럼을 사용하는 경우 DEPENDENT SUBQUERY 가 된다.
이는 DEPENDENT UNION 과 같이 외부 쿼리가 먼저 실행된 후 내부 쿼리가 실행되어야 하기 때문에 일반 서브쿼리보다 처리 속도가 느릴때가 많다.

8. DERIVED
DERIVED 는 단위 SELECT 쿼리의 실행 결과가 메모리나 디스크에 임시 테이블을 생성하는 것을 의미한다.
이때 임시 테이블은 파생 테이블이라고도 한다.

MySQL 5.6 버전부터는 옵티마이저 옵션에 따라 FROM 절에 서브쿼리를 외부 쿼리와 통합하는 최적화를 수행하며, 임시 테이블에서 인덱스를 추가해서 사용할 수 있게 최적화 되었다.

쿼리를 튜닝할 때에는 select_type 가 DERIVED 인 경우에는 반드시 해결해 주는 것이 좋다. 이는 서브쿼리 보다는 조인으로 사용하는 것이 성능상 이점이 좋다는 것이다.
MySQL 8.0 버전부터는 서브 쿼리를 조인으로 최적화를 해주지만, 옵티마이저의 한계가 있어 되도록이면 최적화된 쿼리를 직접 작성해주는 것이 좋다.
# 그 이전의 버전이라면 실행 계획을 확인 후 직접 고쳐주는 것이 좋다.

9. DEPENDENT DERIVED
MYSQL 8.0 버전부터는 레터럴 조인을 활용하여 FROM 절에 있는 서브 쿼리에서 외부 컬럼을 참조할 수 있다.
이때 레터럴 조인을 활용하여 FROM 절의 서브 쿼리가 외부 컬럼을 참조할 때 해당 실행 계획을 갖는다.

10. UNCACHEABLE SUBQUERY
하나의 쿼리에서 서브 쿼리가 하나만 있다 하더라도, 해당 서브쿼리는 한번만 실행되는 것은 아니다.
그러나 조건이 똑같은 서브 쿼리에 대해 다시 실행하지 않고 이전 실행 결과를 그대로 사용할 수 있게 내부 캐시 공간에 담아둔다.

# SUBQUERY 의 경우 내부 서브 쿼리의 값이 캐시되며, DEPENDENCY 인 경우 외부 쿼리의 값을 캐시해서 사용한다.

이때 이러한 캐시를 사용할 수 없을 때에는 UNCACHEABLE SUBQUERY 로 표시가 된다. 캐시를 사용할 수 없는 경우는 다음과 같다.
11.1. 사용자 변수가 서브 쿼리에 사용된 경우
11.2. NOT-DETERMINISTIC 속성의 스토어드 루틴이 서브쿼리 내에 사용된 경우
11.3. UUID() 나 RAND() 와 같이 결과 값이 호출할 떄 마다 달라지는 경우

11. UNCACHEABLE UNION 

12. MATERIALIZED
MySQL 5.6 버전부터 도입된 타입으로, 주로 FROM (subquery) 나 IN (subquery) 형태의 서브 쿼리를 최적화하기 위해 사용된다.

MySQL 5.6 버전까지는 IN (subquery) 에 대해 FROM 에 있는 테이블의 레코드 하나를 읽고, 서브 쿼리가 실행되는 형태로 처리됐다. 
하지만 MySQL 5.7 부터는 서브 쿼리의 내용을 임시 테이블로 구체화한 후, 임시 테이블과 FROM 테이블과 조인하는 형태로 최적화 된다.

# select_Type 이 MATERIALIZED 는 DERIVED 처럼 쿼리의 내용을 임시 테이블로 저장한다는 공통점이 있다.

[ Table 컬럼 ]
MySQL 서버의 실행 계획은 Table 기준으로 표시된다. 이때 테이블에 별칭을 명시했을 경우 별칭으로 표시된다.
만약 FROM 절을 사용하지 않았다면 NULL 이 표기된다.

이때 table 컬럼에 <> 로 둘러싸인 이름이 명시된 경우 이 테이블은 임시 테이블을 말한다. 이때 <> 안에 표시되는 숫자는 단위 SELECT 쿼리의 id 값을 지칭한다.
예를 들어 <derived2> 일 경우 단위 SELECT 쿼리의 id 값이 2인 실행 계획에서 만들어진 결과를 임시 테이블에 저장한다는 뜻이다.
select_type 이 MATERIALIZED 인 경우 table 컬럼에 <subquery N> 이 보일텐데, 이는 <derived N> 처럼 단위 SELECT 쿼리의 id 값이 N 인 결과를 임시 테이블로 만들어 저장했다는 뜻이다.

[ partitions 칼럼 ]
해당 칼럼은 옵티마이저가 쿼리 처리를 위해 필요한 파티션들의 목록을 보여준다.

MySQL 5.7 버전까지 옵티마이저가 참조한 파티션의 목록은 EXPLAIN PARTITION 명령으로 확인해야 했지만, MySQL 8.0 버전부터는 EXPLAIN 명령에 포함되었다.

# 테이블 생성 시 파티션을 잘 생성하면, 옵티마이저는 쿼리만 보고 필요한 파티션을 판단한다. 이 과정에서 어떤 파티션을 접근해야 하는지 데이터 분포 등의 분석을 하지 않는다.
# 또한 MySQL 을 포함한 RDBMS 에서의 파티션은 물리적으로 개별 테이블처럼 별도의 저장 공간을 갖는다.

[ type 칼럼 ]
쿼리의 실행 계획에서 type 컬럼 이후로는 MySQL 서버가 각 테이블의 레코드를 어떻게 읽었는지를 나타낸다.
여기서 type 을 통해 인덱스를 이용해 레코드를 읽었는지, 아니면 테이블을 처음부터 끝까지 읽었는지 등을 알 수 있다. 그렇기 때문에 쿼리를 튜닝할 때는 type 칼럼을 잘 보아야 한다.
그 이유는 인덱스를 효율적으로 잘 사용했는지 확인하는 지표가 되기 때문이다.
type 컬럼은 테이블의 접근 방법으로 해석하면 된다.

type 칼럼에 표시될 수 있는 정보는 system , const , eq_req , ref , fulltext , ref_or_null , unique_subquery , index_subquery , range , index_merge , index , ALL 이 있다.
위의 12가지 접근 방법 중 ALL 을 제외하고는 모두 인덱스를 사용한다. ALL 은 테이블의 처음부터 끝까지 모두 조회하는 풀테이블 스캔이다.
그리고 하나의 단위 SELECT 쿼리는 위의 12가지 접근 방법 중 1개만 사용할 수 있다.
# index_merge 를 제외한 나머지 접근 방법들은 인덱스를 단 하나만 사용한다.
# 그리고 위에 나열한 12가지의 접근 방법은 성능이 빠른 순서대로 나열한 것이다. ( 왼쪽이 가장 성능이 좋음 )

- system
레코드가 1건 이하인 테이블을 참조하는 형태의 접근 방법을 말한다.
해당 접근 방법은 InnoDB 스토리지 엔진을 사용하는 테이블에서는 나타나지 않으며, MyISAM 이나 MEMORY 스토리지 엔진을 사용하는 테이블에서만 나타난다.

- const
테이블의 레코드 건수에 관계 없이 쿼리가 프라이머리 키나 유니크 키 칼럼을 활용하는 WHERE 조건절을 가지고 있으며, 반드시 1건을 반환하는 처리 방식을 말한다.
쉽게 말하면 조인의 순서에 관계 없이 프라이머리 키나 유니크 키의 모든 컬럼을 동등 조건으로 검색하여 반드시 1건의 레코드를 가지고 오는 접근 방법이다.
다른 DBMS에서는 유니크 인덱스 스캔이라고 말한다.

단, 프라이머리 키나 유니크 키가 다중으로 이루어진 경우, 이중 일부 컬럼만 조건으로 사용하는 경우애 const 가 아닌 ref 로 사용한다.
그 이유는 MySQL 엔진은 데이터를 읽어보기 전까지 실제로 조건에 만족하는 데이터가 1건이라고 확인할 수 없기 떄문이다.
그래서 다중 컬럼으로 구성된 경우 해당 컬럼을 모두 명시해야 const 를 사용할 수 있다.

- eq_ref
해당 접근 방법은 쿼리에서 여러 테이블이 조인될 때 표시된다. 
처음 읽은 테이블의 칼럼 값을, 그 다음 읽을 테이블의 프라이머리 키나 유니크 키 칼럼을 검색 조건으로 활용하는 경우에 해당된다.
이떄 두번쨰 테이블 부터 eq_ref 가 표시된다.

이때 두번째 테이블부터 유니크 키를 활용하는 경우 해당 컬럼이 NOT NULL 이어야 하며, 프라이머리 키나 유니크 인덱스가 다중 컬럼으로 이루어져 있을 때 모든 컬럼이 검색 조건에 포함되어야 한다.
즉, 두번째 테이블의 조인 조건 결과가 반드시 1건만 있어야 할 때 사용할 수 있다.

- ref
해당 접근 방법은 eq_req와는 달리 조인의 순서에 관계없으며, 또한 프라이머리 키와 유니크 키의 제약이 없다.
인덱스의 종류 상관 없이 동등 조건 ( = ) 으로 검색할 떄에는 해당 접근 방법을 사용한다.

해당 타입은 결과 레코드가 1건이라는 보장이 없으므로 const , eq_ref 보다는 느리지만, 동등 조건으로만 비교되기 때문에 빠른 레코드 조회 방법 중 하나이다.

# 여기서 테이블의 모든 인덱스를 ( 인덱스가 다중 컬럼으로 구성된 경우 ) 동등 조건으로 비교할 경우 검색 조건이 항상 1건이 된다. , 물론 다중 컬럼 인덱스 중 일부만 동등 조건을 사용할 경우 1건이라는 보장이 없다.
# ref 는 eq_ref 와 const 와는 달리 레코드의 조회 결과가 1건이라는 보장이 없다. 다만 모두 동등 조건 ( = ) 을 사용한다는 공통점이 있으며, 3가지 접근 방법은 모두 좋은 접근 방법이기 때문에 ( 인덱스 분포도가 나쁘지 않다는 가정 ) 튜닝할 때 해당 접근 방법들은
# 크게 신경쓰지 않아도 된다.

여기서 다중 컬럼으로 구성된 인덱스에 대해 일부만 동등 조건으로 비교할 경우 ref 접근 방식을, 다중 컬럼을 모두 동등 조건으로 사용한다면 const 접근 방식을 사용할 것이다.

- fulltext
MySQL 서버의 전문 검색 인덱스를 활용해 레코드에 접근하는 방법을 의미한다.

MySQL 서버의 전문 검색 조건은 우선순위가 높다. 쿼리에서 전문 인덱스와 일반 인덱스가 있을 때, 일반 인덱스의 접근 방법이 const , eq_req , req 가 아니면 MySQL은 전문 인덱스를 사용한다.
즉 조회 조건이 여러개 있을 때 앞선 조회 조건이 const , eq_req, req 가 아니라면 fulltext 로 검색하게 될 것이다.

전문 검색 인덱스는 MATCH ... AGAINST .. 구문을 사용해야 하는데, 해당 테이블에는 전문 검색 인덱스가 있어야 한다.
만약 전문 인덱스가 없다면 오류가 발생한다.

# 하지만 range 접근 방법이 fulltext 보다 빠른 경우가 있었다. 이는 조건에 따라 성능을 비교해보는 것이 좋다.

- ref_or_null
해당 접근 방법은 ref 접근 방법과 같으나, NULL 비교가 추가된 형태이다.
이름 그대로 ref 접근 방식 또는 NULL 비교 접근 방식을 의미한다.

_ unique_subquery
WHERE 조건절에서 IN(subquery) 형태의 쿼리를 위한 접근 방법이다.
이름 그대로 서브 쿼리가 유니크한 값만 반환할 떄 해당 접근 방법을 사용한다.

# 해당 실행 계획은 세미 조인 최적화로 인해서 다른 실행 계획이 보일 수도 있다.

- index_subquery
WHERE 조건절에서 IN(subquery) 형태의 쿼리를 위한 접근 방법이다.
서브 쿼리가 중복된 값을 가지고 있을 때 인덱스를 활용해 중복을 제거하여 처리할 떄 사용하는 접근 방법이다.

보통 IN(subquery) 나 IN(상수) 형태의 쿼리는 괄호 안에 있는 값들의 중복을 먼저 제거해야 한다.

# 해당 실행 계획은 세미 조인 최적화로 인해서 다른 실행 계획이 보일 수도 있다.

- range
range 는 인덱스 레인지 스캔의 접근 방법이다.
range 는 인덱스를 하나가 아닌 범위로 검색하는 경우에 사용된다.
주로 < , > , IN NULL , BETWEEN , IN , LIKE 등의 연산자를 이용해 인덱스를 검색할 떄 사용한다.

# 어플리케이션 쿼리가 가장 많이 사용하는 접근 방법이다. 

- index_merge
해당 접근 방식은 2개 이상의 인덱스를 활용해 검색 결과를 각각 만들어낸 후, 그 결과를 병합하는 접근 방법이다.

해당 접근 방법에는 다음과 같은 특징이 있다.
1. 여러 인덱스를 읽어야 하기 때문에 range 접근 방법보다 효율성이 낮다.
2. 전문 검색 인덱스를 사용하는 쿼리에서 index_merge는 사용되지 않는다.
3. 2개 이상의 결과 집합에 대해 중복제거 , 합집합 , 교집합 등 부가 작업이 더 필요하다.
# MySQL 메뉴얼에는 원래 ref_or_null 다음에 위치하지만, 해당 내용은 위의 이유로 range 밑으로 내렸다.

- index
해당 접근 방법은 인덱스를 처음부터 끝까지 읽는 인덱스 풀 스캔 접근 방법이다.
인덱스 풀 스캔은 풀테이블 스캔보다 성능은 뛰어나다. 그 이유는 데이터 파일 크기보다 인덱스가 더 작기 때문이다. ( 풀 테이블 스캔과 인덱스 풀 스캔은 읽어야할 레코드 건수는 같다. )
그리고 정렬된 상태이기 때문에 인덱스의 장점을 활용할 수 있다.

해당 접근 방법을 사용하기 위해서는 1번 3번이 만족하거나 1번 2번이 만족해야한다.
1. range 나 const, ref 같은 접근 방법으로 인덱스를 사용할 수 없다.
2. 인덱스에 포함된 컬럼만으로 쿼리를 처리할 수 있는 경우
3. 인덱스를 이용해 정렬이나 그루핑 작업을 해야하는 경우

# 위의 조건을 만족하려면 where 절이 없어 range 나 const, ref 를 사용할 수 없으며, 정렬이 필요한 컬럼이 인덱스 키인 경우에 해당될 수 있다.

- ALL
해당 접근 방법은 풀 테이블 스캔이다.
해당 접근 방법은 위의 처리 방법으로는 모두 불가능할 때 선택하는 가장 비효율적인 방법이다.

[ possible_keys 칼럼 ]
해당 칼럼은 MySQL 옵티마이저가 최적의 실행 계획을 세울 때 후보로 선정했던 접근 방법의 인덱스 목록이다.
즉, 실제로 사용된 것이 아니며, 사용될법했던 인덱스 목록이다.

이는 실제로 사용된 인덱스와는 거리가 있기 때문에 해당 컬럼은 신경쓰지 않아도 된다.

[ key 칼럼 ]
해당 칼럼은 최종 선정된 실행 계획에서 사용된 인덱스를 의미한다.
즉 key 칼럼에 PRIMARY 가 적혀있다면 프라이머리 키를 사용한 것이며, 그 외의 값은 해당 인덱스를 생성할 때 부여했던 고유 이름이다.

실행 계획의 type 컬럼이 index_merge 가 아닌 경우에는 테이블당 하나의 인덱스가 사용되며, 만약 인덱스를 사용하지 못한 경우라면 NULL 이 표시된다.

[ key_len 칼럼 ]
key_len 칼럼은 다중 컬럼으로 구성된 인덱스에 대해 몇개의 칼럼까지 사용했는지 알려준다.
정확하게는 인덱스의 각 레코드에서 몇 바이트까지 사용됐는지 알려준다.

예를 들어 테이블에 A(4byte),B(3byte),C(2byte) 칼럼을 하나의 프라이머리 키로 묶었을 때, 쿼리가 인덱스 칼럼 중 A만 사용했다면 key_len 칼럼은 4 를 표시한다.
A와 B 모두 사용했다면 7을 출력한다.

이때 A 가 4byte 인데 5 로 출력되는 경우가 있다. ( 타입 Size + 1 )
그 이유는 A가 NOT NULL 이 아닐 때 ( NULL 이 저장될 수 있는 NULLABLE 일 때 ) , MySQL 서버는 NULL 인지 여부를 체크하기 위해 추가로 1바이트를 사용한다.