[ 통계 정보 ]
MySQL 5.7 버전 이전에는 테이블과 인덱스에 대한 정보만 가지고 실행 계획을 수립했다.
하지만 이는 테이블에 저장된 레코드의 값이 실제로 어떻게 분포되어 있는지에 대한 정보가 없기 때문에 실행 계획의 정확도가 떨어졌다.

MySQL 8.0 부터는 인덱스되지 않은 컬럼에 대해서도 데이터 분포도를 수집하는 히스토그램 기능이 도입되었다.

- 테이블 및 인덱스 통계 정보
비용 기반 최적화에서 가장 중요한 것은 통계 정보이다. 통계 정보가 정확하지 않다면 잘못된 실행 계획으로 처리될 수 있다.
예를 들어 실제 레코드에 10억 건이 들어있는데 통계 정보가 갱신되지 않아 레코드가 10건만 들어있다고 되어있다면, 옵티마이저는 테이블 풀 스캔을 실행하여 쿼리의 성능을 떨어뜨릴 것이다.

MySQL 도 다른 DBMS 처럼 비용 기반의 최적화를 사용했지만, 통계 정보의 휘발성이 강하여 정확도가 높지 않았다.
그래서 MySQL는 실행 계획을 수립할 때 실제 테이블의 레코드를 일부 분석해서 통계 정보로 활용했다.
MySQL 5.6 버전부터는 통계 정보의 정확도를 높이기 위해 점점 개선을 하였다.

- MySQL 서버의 통계 정보
MySQL 5.5 버전 까지는 테이블의 통계 정보가 메모리에 보관되어왔다. 이는 MySQL 서버가 재기동되면 통계 정보가 사라진다는 단점이 있다.
하지만 5.6 버전부터는 InnoDB 스토리지 엔진을 사용하는 테이블에 대해 통계 정보가 영구적으로 관리할 수 있게 개선되었다.
이는 mysql 데이터베이스에서 innodb_index_stats 테이블과 innodb_table_stats 테이블에 각 테이블에 대한 통계 정보를 관리하여 MySQL 서버가 재기동 되어도 데이터가 유지될 수 있게 개선됐다.

MySQL 5.6 버전부터는 테이블을 생성할 때 STATS_PERSISTENT 옵션을 통해 해당 테이블의 통계 정보를 영구적으로 관리할지 말지를 선택할 수 있다.
STATS_PERSISTENT=0 으로 할 경우 MySQL 5.5 이전 버전의 방식대로 관리한다.
STATS_PERSISTENT=1 으로 할 경우 테이블에 대한 통계 정보를 innodb_index_stats 테이블과 innodb_table_stats 테이블에 저장한다.
STATS_PERSISTENT=DEFAULT 으로 할 경우 해당 옵션을 안 붙인 것과 동일하여, innodb_stats_persistent 시스템 변수의 값에 따른다.

innodb_stats_persistent 의 기본 값은 1이며, 1로 설정될 경우 테이블의 통계 정보를 innodb_index_stats 테이블과 innodb_table_stats 테이블에 영구적으로 보관한다.
# 테이블 통계 정보 관리 여부는 ALTER TABLE 로 변경할 수 있다.
# MySQL 5.5 버전에서는 테이블의 통계 정보가 메모리에 관리되기 때문에, 서버가 재기동되면 다시 테이블의 통계 정보를 수집해야 했다.

테이블에 대한 통계 정보는 다음과 같은 이벤트가 발생하면 자동으로 통계 정보가 갱신된다.
1. 테이블이 오픈되는 경우
2. 테이블의 레코드가 대량으로 변경되는 경우 ( 전체 레코드 중 1/16 정도의 쿼리가 insert update delete 되는 경우 )
3. ANALYZE TABLE 명령이 실행되는 경우
4. SHOW TABLE STATUS 명령이나 SHOW INDEX FROM 명령이 실행되는 경우
5. InnoDB 모니터가 활성되는 경우
6. innodb_status_on_metadata 시스템 변수가 ON 인 상태에서 SHOW TABLE STATUS 명령이 실행 되는 경우

테이블의 통계 정보가 지속적으로 변경될 경우 옵티마이저가 잘못된 실행 계획을 세울수도 있다.
하지만 이는 영구적인 통계 정보가 도입되면서 의도치 않은 통계 정보 변경을 막았다.
혹은 innodb_stats_auto_recalc 시스템 변수를 OFF 로 설정하면 통계 정보가 자동으로 갱신되는 것을 막을 수 있다. ( 기본 값은 ON 이다. )
# 영구적으로 통계 정보를 관리한다면 해당 옵션은 OFF로 설정하는 것이 좋다.

또한 STATUS_AUTO_RECALC 옵션을 사용하면 각 테이블 단위로 통계 정보를 자동으로 수집할지 설정할 수 있다.
STATUS_AUTO_RECALC=1 : MySQL 5.5 버전 이전 방식을 따른다.
STATUS_AUTO_RECALC=0 : ANALYZE TABLE 명령을 수행할 때에만 수집한다.
STATUS_AUTO_RECALC=DEFAULT : 옵션을 지정하지 않은 것과 동일하며 innodb_stats_auto_recalc 시스템 변수 값을 따른다.

MySQL 5.6 버전부터는 테이블의 통계 정보를 수집할 때 innoDB 스토리지 엔진을 사용하는 테이블 블록을 샘플링하여 더 정확한 통계 정보를 만들어낼 수 있다.
innodb_stats_transient_sample_pages : 기본 값은 8 이며, 자동으로 테이블의 통계 정보를 수집할 때 임의의 8개의 페이지를 분석하고 그 결과를 통계 정보에 활용한다.
innodb_stats_persistent_sample_pages : 기본 값은 20이며 ANALYZE TABLE 명령을 실행하면 임의의 20개의 테이블을 샘플링하여 그 결과를 통계 정보에 활용한다. ( 통계 정보 테이블에 저장 )

innodb_stats_persistent_sample_pages 설정 값이 높아짐에 따라 실행 시간은 오래 걸리겠지만, 통계 정보는 쿼리의 성능을 좌우하기 때문에 긴 시간을 투자할 가치가 있다.
# 보통 쿼리의 성능은 통계 정보의 역할이 크다. 그렇기 떄문에 사용자가 별로 없는 시간대에 작업을 처리하는 것이 좋다.

[ 히스토그램 ]
MySQL 8.0 부터는 컬럼의 데이터 분포도를 참조할 수 있는 히스토그램이 탄생하였다.
히스토그램은 자동으로 수집되는 것이 아닌 ANALYZE TABLE ... UPDATE HISTOGRAM 명령으로 수동으로 수집 및 관리한다.
수집된 정보는 시스템 딕셔너리에 저장되고, MySQL 서버가 시작될 때 information_schema DB 의 column_statistics 테이블에 로드한다.

히스토그램은 2가지의 타입이 있다.
1. 싱글톤 히스토그램 : 칼럼값 개별로 레코드 건수를 관리하는 히스토그램
2. 높이 균형 히스토그램 : 칼럼값의 범위를 균등한 개수로 구분해서 관리하는 히스토그램

히스토그램은 버킷 단위로 구분되며 레코드 건수나 범위 값을 관리하는데, 
싱글톤 히스토그램은 칼럼이 가지는 값 별로 버킷이 할당되며 각 버킷에 칼럼 값과 발생 빈도 비율의 값을 가지고 있고, 
높이 균형 히스토그램은 칼럼 값의 범위별로 버킷이 할당되며 범위 시작 값과 마지막 값, 그리고 발생 빈도와 유니크한 값의 갯수를 가진다.

# 싱글톤 히스토그램은 유니크한 값의 개수가 상대적으로 적은 경우에 사용된다. 

히스토그램은 ANALYZE TABLE DROP HISTOGRAM 명령을 통해 삭제할 수 있다. 이는 테이블의 데이터를 삭제하는 것이 아니라 딕셔너리의 내용만 삭제한다.
혹은 옵티마이저 옵션인 condition_fanout_filter 를 off 로 설정을 하면 MySQL 서버의 모든 쿼리가 히스토 그램을 사용하지 않는다. 다만 해당 옵션을 사용하는 다른 최적화도 비활성화 된다.

- 히스토그램의 용도
기존 MySQL 서버의 경우 테이블의 전체 데이터 건수와 인덱스 컬럼이 가지는 유니크한 값의 갯수만 가지고 있었다.
하지만 실제 데이터는 균등한 분포도를 가지고 있지 않기 때문에 MySQL 서버는 최적의 실행 계획을 세우진 못했다.
이러한 단점을 개선하기 위해 히스토그램이 도입되었다. 히스토그램은 각 칼럼의 분포도를 가지고 있진 않지만, 범위별로 레코드의 건수와 유니크한 값의 갯수를 가지고 있기 때문에 더욱 정확한 예측을 할 수 있게 되었다.

예를 들면 레코드의 건수가 1000건이고, 유니크 컬럼의 유니크한 값의 갯수가 100건일 경우 MySQL 서버는 다른 컬럼에 대해서도 대략 10개의 레코드가 일치할 것으로 예측한다. ( 실제론 하나도 없을 수도, 아니면 모든 레코드가 일치할 수도 있다. )
이는 각 레코드의 분포도를 판단해서 조인의 순서를 정하는 실행 계획에 더 나은 계획을 세울 수 있다. ( 상황에 따라 10배 이상 차이를 보일 수도 있다. )

- 히스토그램과 인덱스
M옵티마이저는 실행 계획을 세울 때 조건에 일치하는 레코드의 갯수를 파악하기 위해 실제 인덱스의 B-Tree 를 샘플링하는 인덱스 다이브를 실행한다.
이때 해당 컬럼에 히스토그램이 있다 하더라도 인덱스 다이브를 통해 정보를 수집한다.
그 이유는 인덱스 다이브는 히스토그램보다 정확한 결과를 기대하기 때문이다.
그래서 보통 히스토그램은 인덱스 되지 않은 컬럼의 데이터 분포도를 참조하는 용도로 활용된다.

하지만 인덱스 다이브 작업도 어느정도 비용이 필요하며, 때로는 실행 계획 수립만으로도 상당한 비용이 걸릴 수도 있다. ( IN 절에 값이 많이 명시된 경우 )
MySQL 8.0 버전 기준으로는 인덱스를 사용하지 않고 히스토그램을 사용하는 최적화는 아직 없다.

- 코스트 모델
코스트 모델은 사용자의 쿼리를 처리하는데, 필요한 작업에 드는 예상 비용을 측정하는 기준을 말한다.

MySQL 5.7 버전 이전에는 MySQL 서버의 소스 코드에 상수화 되어 있었지만, 5.7 버전 부터는 DBMS 관리자가 조정할 수 있게 되었다.

MySQL 8.0 서버의 코스트 모델은 다음 2개의 테이블에 저장된 설정 값을 활용한다.
1. server_cost : 인덱스를 찾고 레코드를 비교하고 임시 테이블 처리에 대한 비용
2. engine_cost : 레코드를 가진 데이터 페이지를 가져오는 데 필요한 비용

코스트 모델에서 중요한 것은 각 단위 작업에 설정된 비용이 변경되면 어떤 실행 계획이 고비용으로 바뀌고, 어떤 실행 계획이 저 비용으로 바뀌는지 파악해야 한다.
# 디스크에서 임시테이블을 만들거나, 메모리에서 임시테이블을 만드는 등

해당 코스트 모델을 수정하는 경우 옵티마이저는 실행 계획이 변경될 수 있다. 하지만 이는 하드웨어와 서버에 대한 깊은 지식을 필요로 하기 때문에
함부로 변경하는 것은 오히려 성능을 떨어뜰리 수 있다.
